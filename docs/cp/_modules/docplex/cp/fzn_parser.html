

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    
    <title>docplex.cp.fzn_parser &#8212; DOcplex.CP: Constraint Programming Modeling for Python V2.6 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     'V2.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DOcplex.CP: Constraint Programming Modeling for Python V2.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for docplex.cp.fzn_parser</h1><div class="highlight"><pre>
<span></span><span class="c1"># --------------------------------------------------------------------------</span>
<span class="c1"># Source file provided under Apache License, Version 2.0, January 2004,</span>
<span class="c1"># http://www.apache.org/licenses/</span>
<span class="c1"># (c) Copyright IBM Corp. 2015, 2016</span>
<span class="c1"># --------------------------------------------------------------------------</span>
<span class="c1"># Author: Olivier OUDOT, IBM Analytics, France Lab, Sophia-Antipolis</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Parser converting a FZN file to internal model representation.</span>

<span class="sd">This parser does not support the complete set of predicates described in the specifications of FlatZinc</span>
<span class="sd">that can be found here: http://www.minizinc.org/downloads/doc-1.6/flatzinc-spec.pdf</span>

<span class="sd">Basically, it supports essentially integer expressions, some floating point expressions and custom</span>
<span class="sd">predicates related to scheduling.</span>

<span class="sd">The predicates that are supported are:</span>

<span class="sd"> * *array predicates*</span>

<span class="sd">   array_bool_and, array_bool_element, array_bool_or, array_bool_xor,</span>
<span class="sd">   array_float_element, array_int_element, array_set_element,</span>
<span class="sd">   array_var_bool_element, array_var_float_element, array_var_int_element, array_var_set_element.</span>

<span class="sd"> * *boolean predicates*</span>

<span class="sd">   bool2int, bool_and, bool_clause, bool_eq, bool_eq_reif, bool_le, bool_le_reif,</span>
<span class="sd">   bool_lin_eq, bool_lin_le, bool_lt, bool_lt_reif, bool_not, bool_or, bool_xor.</span>

<span class="sd"> * *integer predicates*</span>

<span class="sd">   int_abs, int_div, int_eq, int_eq_reif, int_le, int_le_reif, int_lin_eq, int_lin_eq_reif,</span>
<span class="sd">   int_lin_le, int_lin_le_reif, int_lin_ne, int_lin_ne_reif, int_lt, int_lt_reif, int_max, int_min,</span>
<span class="sd">   int_mod, int_ne, int_ne_reif, int_plus, int_times, int2float.</span>

<span class="sd"> * *float predicates*</span>

<span class="sd">   float_abs, float_exp, float_ln, float_log10, float_log2, float_sqrt, float_eq, float_eq_reif,</span>
<span class="sd">   float_le, float_le_reif, float_lin_eq, float_lin_eq_reif, float_lin_le, float_lin_le_reif, float_lin_lt,</span>
<span class="sd">   float_lin_lt_reif, float_lin_ne, float_lin_ne_reif, float_lt, float_lt_reif, float_max, float_min,</span>
<span class="sd">   float_ne, float_ne_reif, float_plus.</span>

<span class="sd"> * *set predicates*</span>

<span class="sd">   set_in, set_in_reif.</span>

<span class="sd"> * *custom predicates*</span>

<span class="sd">   all_different_int, subcircuit, count_eq_const, table_int, inverse,</span>
<span class="sd">   lex_lesseq_bool, lex_less_bool, lex_lesseq_int, lex_less_int, int_pow, cumulative</span>


<span class="sd">Detailed description</span>
<span class="sd">--------------------</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">docplex.cp.fzn_tokenizer</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">docplex.cp.expression</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">docplex.cp.solution</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">docplex.cp.model</span> <span class="k">import</span> <span class="n">CpoModel</span>
<span class="kn">import</span> <span class="nn">docplex.cp.modeler</span> <span class="k">as</span> <span class="nn">modeler</span>
<span class="kn">import</span> <span class="nn">docplex.cp.config</span> <span class="k">as</span> <span class="nn">config</span>
<span class="kn">import</span> <span class="nn">docplex.cp.expression</span> <span class="k">as</span> <span class="nn">expression</span>
<span class="kn">import</span> <span class="nn">collections</span>


<span class="c1">###############################################################################</span>
<span class="c1">## Constants</span>
<span class="c1">###############################################################################</span>

<span class="c1"># Mapping of FlatZinc predicates to CPO expressions expressed as a list of couples</span>
<span class="c1"># Key is the name or list of names list of names of FZN predicates,</span>
<span class="c1"># Value is a lambda expression taking predicate arguments and returning CPO expression</span>
<span class="n">PREDICATES_MAP</span> <span class="o">=</span> \
<span class="p">{</span>
    <span class="c1"># Basic predicates</span>
    <span class="s1">&#39;array_bool_and&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">min_of</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
    <span class="s1">&#39;array_bool_element&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="s1">&#39;array_bool_or&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">max_of</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
    <span class="s1">&#39;array_bool_xor&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;array_float_element&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="s1">&#39;array_int_element&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="s1">&#39;array_set_element&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;array_var_bool_element&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="s1">&#39;array_var_float_element&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="s1">&#39;array_var_int_element&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="s1">&#39;array_var_set_element&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1">#&#39;bool2int&#39;: lambda a, b: a == b,</span>
    <span class="s1">&#39;bool_and&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
    <span class="c1">#&#39;bool_clause&#39;: lambda a, b: (modeler.max_of(a) &gt; 0) | (modeler.min_of(b) == 0),</span>
    <span class="s1">&#39;bool_clause&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_bool_clause</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;bool_eq&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;bool_eq_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;bool_le&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;bool_le_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;bool_lin_eq&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">),</span>
    <span class="s1">&#39;bool_lin_le&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">less_or_equal</span><span class="p">),</span>
    <span class="s1">&#39;bool_lt&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;bool_lt_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span> <span class="o">==</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;bool_not&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span> <span class="o">==</span> <span class="n">modeler</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
    <span class="s1">&#39;bool_or&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span> <span class="o">==</span> <span class="n">modeler</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;bool_xor&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;float_abs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">abs_of</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span>
    <span class="s1">&#39;float_acos&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;float_asin&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;float_atan&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;float_cos&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;float_cosh&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;float_exp&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">exponent</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span>
    <span class="s1">&#39;float_ln&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span>
    <span class="s1">&#39;float_log10&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">modeler</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">modeler</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))),</span>
    <span class="s1">&#39;float_log2&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">modeler</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">modeler</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))),</span>
    <span class="s1">&#39;float_sqrt&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)),</span>
    <span class="s1">&#39;float_sin&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;float_sinh&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;float_tan&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;float_tanh&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;float_eq&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;float_eq_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;float_le&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;float_le_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;float_lin_eq&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">),</span>
    <span class="s1">&#39;float_lin_eq_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="o">==</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">),</span>
    <span class="s1">&#39;float_lin_le&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">less_or_equal</span><span class="p">),</span>
    <span class="s1">&#39;float_lin_le_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="o">==</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">less_or_equal</span><span class="p">),</span>
    <span class="s1">&#39;float_lin_lt&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">less</span><span class="p">),</span>
    <span class="s1">&#39;float_lin_lt_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="o">==</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">less</span><span class="p">),</span>
    <span class="s1">&#39;float_lin_ne&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">diff</span><span class="p">),</span>
    <span class="s1">&#39;float_lin_ne_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="o">==</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">diff</span><span class="p">),</span>
    <span class="s1">&#39;float_lt&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;float_lt_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span> <span class="o">==</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;float_max&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">max_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;float_min&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">min_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;float_ne&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;float_ne_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;float_plus&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;int_abs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span> <span class="o">==</span> <span class="n">modeler</span><span class="o">.</span><span class="n">abs_of</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
    <span class="s1">&#39;int_div&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">//</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;int_eq&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;int_eq_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;int_le&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;int_le_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)),</span>
    <span class="c1">#&#39;int_lin_eq&#39;: lambda a, b, r: _scal_prod(a, b, r, modeler.equal),</span>
    <span class="s1">&#39;int_lin_eq_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="o">==</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">),</span>
    <span class="s1">&#39;int_lin_le&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">less_or_equal</span><span class="p">),</span>
    <span class="s1">&#39;int_lin_le_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="o">==</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">less_or_equal</span><span class="p">),</span>
    <span class="s1">&#39;int_lin_ne&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">diff</span><span class="p">),</span>
    <span class="s1">&#39;int_lin_ne_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="o">==</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">diff</span><span class="p">),</span>
    <span class="s1">&#39;int_lt&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;int_lt_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;int_max&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">max_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;int_min&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">min_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;int_mod&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;int_ne&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">,</span>
    <span class="s1">&#39;int_ne_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;int_plus&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;int_times&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;int2float&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;set_card&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_diff&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_eq&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_eq_reif&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_in&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">allowed_assignments</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;set_in_reif&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">allowed_assignments</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span>
    <span class="s1">&#39;set_intersect&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_le&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_lt&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_ne&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_ne_reif&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_subset&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_subset_reif&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_symdiff&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;set_union&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>

    <span class="c1"># Custom predicates</span>
    <span class="s1">&#39;all_different_int&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">all_diff</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
    <span class="s1">&#39;subcircuit&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">_subcircuit</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
    <span class="s1">&#39;count_eq_const&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span> <span class="o">==</span> <span class="n">modeler</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
    <span class="s1">&#39;table_int&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_table_int</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span>
    <span class="s1">&#39;inverse&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_inverse</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;lex_lesseq_int&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">lexicographic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;lex_lesseq_bool&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">modeler</span><span class="o">.</span><span class="n">lexicographic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;lex_less_int&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_lex_less_int</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;lex_less_bool&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_lex_less_int</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
    <span class="s1">&#39;int_pow&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span> <span class="o">==</span> <span class="p">(</span><span class="n">a</span> <span class="o">**</span> <span class="n">b</span><span class="p">),</span>
<span class="p">}</span>

<span class="c1"># Dictionary of predicates implemented as parser methods</span>
<span class="c1"># Key is name of the predicate, Value is name of the CpoParser function that implements the predicate.</span>
<span class="n">SELF_PREDICATES_MAP</span> <span class="o">=</span> \
<span class="p">{</span>
    <span class="s1">&#39;cumulative&#39;</span><span class="p">:</span> <span class="s1">&#39;_pred_cumulative&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bool2int&#39;</span><span class="p">:</span>   <span class="s1">&#39;_pred_bool2int&#39;</span><span class="p">,</span>
    <span class="s1">&#39;int_lin_eq&#39;</span><span class="p">:</span> <span class="s1">&#39;_pred_int_lin_eq&#39;</span>
<span class="p">}</span>


<span class="c1">###############################################################################</span>
<span class="c1">## Public classes</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="FznParserException"><a class="viewcode-back" href="../../../docplex.cp.fzn_parser.py.html#docplex.cp.fzn_parser.FznParserException">[docs]</a><span class="k">class</span> <span class="nc">FznParserException</span><span class="p">(</span><span class="n">CpoException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; The base class for exceptions raised by the CPO parser</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a new exception</span>
<span class="sd">        Args:</span>
<span class="sd">            msg: Error message</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FznParserException</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

<span class="c1"># Parameter descriptor</span>
<span class="n">FznParameter</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;FznParameter&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span>   <span class="c1"># Variable name</span>
                                                       <span class="s1">&#39;type&#39;</span><span class="p">,</span>   <span class="c1"># Variable type (string)</span>
                                                       <span class="s1">&#39;size&#39;</span><span class="p">,</span>   <span class="c1"># Array size (if array), None for variable</span>
                                                       <span class="s1">&#39;value&#39;</span><span class="p">,</span>  <span class="c1"># Value</span>
                                                       <span class="p">))</span>

<span class="c1"># Variable descriptor</span>
<span class="n">FznVariable</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;FznVariable&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span>       <span class="c1"># Variable name</span>
                                                     <span class="s1">&#39;domain&#39;</span><span class="p">,</span>     <span class="c1"># Domain</span>
                                                     <span class="s1">&#39;introduced&#39;</span><span class="p">,</span> <span class="c1"># Introduced indicator</span>
                                                     <span class="s1">&#39;size&#39;</span><span class="p">,</span>       <span class="c1"># Array size (if array), None for variable</span>
                                                     <span class="s1">&#39;value&#39;</span><span class="p">,</span>      <span class="c1"># Value</span>
                                                     <span class="p">))</span>

<span class="c1"># Constraint descriptor</span>
<span class="n">FznConstraint</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;FznConstraint&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;predicate&#39;</span><span class="p">,</span>   <span class="c1"># Name of the predicate</span>
                                                         <span class="s1">&#39;args&#39;</span><span class="p">,</span>        <span class="c1"># Arguments</span>
                                                         <span class="s1">&#39;defvar&#39;</span><span class="p">,</span>      <span class="c1"># Name of the variable defined by this constraint</span>
                                                         <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="c1"># Annotations</span>
                                                         <span class="p">))</span>

<span class="c1"># Constraint descriptor</span>
<span class="n">FznObjective</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;FznObjective&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;operation&#39;</span><span class="p">,</span>   <span class="c1"># Objective operation in &#39;satisfy&#39;, &#39;minimize&#39;, &#39;maximize&#39;</span>
                                                       <span class="s1">&#39;expr&#39;</span><span class="p">,</span>        <span class="c1"># Target expression</span>
                                                       <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="c1"># Annotations</span>
                                                       <span class="p">))</span>


<div class="viewcode-block" id="FznReader"><a class="viewcode-back" href="../../../docplex.cp.fzn_parser.py.html#docplex.cp.fzn_parser.FznReader">[docs]</a><span class="k">class</span> <span class="nc">FznReader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reader of FZN file format &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;source_file&#39;</span><span class="p">,</span>  <span class="c1"># Source file</span>
                 <span class="s1">&#39;tokenizer&#39;</span><span class="p">,</span>    <span class="c1"># Reading tokenizer</span>
                 <span class="s1">&#39;token&#39;</span><span class="p">,</span>        <span class="c1"># Last read token</span>

                 <span class="s1">&#39;parameters&#39;</span><span class="p">,</span>   <span class="c1"># List of parameters</span>
                 <span class="s1">&#39;variables&#39;</span><span class="p">,</span>    <span class="c1"># List of variables</span>
                 <span class="s1">&#39;constraints&#39;</span><span class="p">,</span>  <span class="c1"># List of model constraints</span>
                 <span class="s1">&#39;objective&#39;</span><span class="p">,</span>    <span class="c1"># Model objective</span>
                 <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a new FZN reader</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FznReader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="FznReader.parse"><a class="viewcode-back" href="../../../docplex.cp.fzn_parser.py.html#docplex.cp.fzn_parser.FznReader.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parse a FZN file</span>

<span class="sd">        Args:</span>
<span class="sd">            cfile: FZN file to read</span>
<span class="sd">        Raises:</span>
<span class="sd">            FznParserException: Parsing exception</span>
<span class="sd">        Return:</span>
<span class="sd">            Model result of the parsing, object of class :class:`~docplex.cp.model.CpoModel`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store file name if first file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_file</span> <span class="o">=</span> <span class="n">cfile</span>
        <span class="k">with</span> <span class="n">open_utf8</span><span class="p">(</span><span class="n">cfile</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">FznTokenizer</span><span class="p">(</span><span class="n">cfile</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_document</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="FznReader.parse_string"><a class="viewcode-back" href="../../../docplex.cp.fzn_parser.py.html#docplex.cp.fzn_parser.FznReader.parse_string">[docs]</a>    <span class="k">def</span> <span class="nf">parse_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parse a string</span>

<span class="sd">        Result of the parsing is added to the current result model.</span>

<span class="sd">        Args:</span>
<span class="sd">            str: String to parse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">FznTokenizer</span><span class="p">(</span><span class="s2">&quot;String&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_document</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="FznReader.write"><a class="viewcode-back" href="../../../docplex.cp.fzn_parser.py.html#docplex.cp.fzn_parser.FznReader.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write the model.</span>

<span class="sd">        If the given output is a string, it is considered as a file name that is opened by this method</span>
<span class="sd">        using &#39;utf-8&#39; encoding.</span>

<span class="sd">        Args:</span>
<span class="sd">            out (Optional): Target output stream or file name. If not given, default value is sys.stdout.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check file</span>
        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">open_utf8</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="c1"># Check default output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>

        <span class="c1"># Write model content</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">out</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_read_document</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read all FZN document</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_predicate</span><span class="p">():</span>
                <span class="k">pass</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_parameter_or_variable</span><span class="p">():</span>
                <span class="k">pass</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_constraint</span><span class="p">():</span>
                <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_objective</span><span class="p">()</span>


        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">traceback</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">!=</span> <span class="n">TOKEN_EOF</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Unexpected token &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_read_predicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read a predicate declaration</span>

<span class="sd">        This function is called with first token already read and terminates with next token already read.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if a predicate has been read, False if nothing to process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="s2">&quot;predicate&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Read predicate declaration</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">TOKEN_SEMICOLON</span><span class="p">,</span> <span class="n">TOKEN_EOF</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">!=</span> <span class="n">TOKEN_SEMICOLON</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Semicolon &#39;;&#39; expected at the end of a predicate declaration.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>


    <span class="k">def</span> <span class="nf">_read_parameter_or_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read a parameter or variable declaration</span>

<span class="sd">        This function is called with first token already read and terminates with next token already read.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if a parameter has been read, False if nothing to process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_SYMBOL</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Read array size if any</span>
        <span class="n">arsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_array_size</span><span class="p">()</span>

        <span class="c1"># Check if variable declaration</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_variable</span><span class="p">(</span><span class="n">arsize</span><span class="p">)</span>

        <span class="c1"># Check type name</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">(),</span> <span class="n">TOKEN_SYMBOL_OF</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">(),</span> <span class="n">TOKEN_SYMBOL_INT</span><span class="p">)</span>

        <span class="c1"># Check separating colon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">(),</span> <span class="n">TOKEN_COLON</span><span class="p">)</span>

        <span class="c1"># Check parameter name</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_SYMBOL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Symbol expected as parameter name.&quot;</span><span class="p">)</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">(),</span> <span class="n">TOKEN_EQUAL</span><span class="p">)</span>

        <span class="c1"># Read expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_expression</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span>
            <span class="n">arsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">,</span> <span class="n">TOKEN_SEMICOLON</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>

        <span class="c1"># Build result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FznParameter</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">arsize</span><span class="p">,</span> <span class="n">expr</span><span class="p">))</span>

        <span class="k">return</span> <span class="kc">True</span>


    <span class="k">def</span> <span class="nf">_read_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arsize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read a variable declaration</span>

<span class="sd">        This function is called with first token already read and terminates with next token already read.</span>

<span class="sd">        Args:</span>
<span class="sd">            arsize:  Array size if any</span>
<span class="sd">        Returns:</span>
<span class="sd">            True if a variable has been read, False if nothing to process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read domain</span>
        <span class="n">dom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_var_domain</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">,</span> <span class="n">TOKEN_COLON</span><span class="p">)</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_SYMBOL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Symbol expected as variable name.&quot;</span><span class="p">)</span>
        <span class="n">vid</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>

        <span class="c1"># Check annotations</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_annotations</span><span class="p">()</span>
        <span class="c1"># print(&quot;Annotations: {}&quot;.format(annotations))</span>
        <span class="n">is_introduced</span> <span class="o">=</span> <span class="s1">&#39;var_is_introduced&#39;</span> <span class="ow">in</span> <span class="n">annotations</span>

        <span class="c1"># Check expression</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="n">TOKEN_EQUAL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_expression</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">dom</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="k">elif</span> <span class="n">expr</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">dom</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
            <span class="k">elif</span> <span class="n">is_int</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">dom</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr</span><span class="p">,)</span>

        <span class="c1"># Read ending semicolon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">,</span> <span class="n">TOKEN_SEMICOLON</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>

        <span class="c1"># Create variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FznVariable</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">dom</span><span class="p">,</span> <span class="n">is_introduced</span><span class="p">,</span> <span class="n">arsize</span><span class="p">,</span> <span class="n">expr</span><span class="p">))</span>

        <span class="k">return</span> <span class="kc">True</span>


    <span class="k">def</span> <span class="nf">_read_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read a constraint</span>

<span class="sd">        This function is called with first token already read and terminates with next token already read.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if a variable has been read, False if nothing to process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check constraint token</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">!=</span> <span class="n">TOKEN_SYMBOL_CONSTRAINT</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Read constraint name</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_SYMBOL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Constraint name &#39;</span><span class="si">{}</span><span class="s2">&#39; should be a symbol.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span>
        <span class="n">cname</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Read parameters</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">(),</span> <span class="n">TOKEN_PARENT_OPEN</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">!=</span> <span class="n">TOKEN_PARENT_CLOSE</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_expression</span><span class="p">())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="ow">is</span> <span class="n">TOKEN_COMMA</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>

        <span class="c1"># Check annotations</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_annotations</span><span class="p">()</span>
        <span class="n">defvar</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;defines_var&#39;</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Read ending semicolon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">,</span> <span class="n">TOKEN_SEMICOLON</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>

        <span class="c1"># Store constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FznConstraint</span><span class="p">(</span><span class="n">cname</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">defvar</span><span class="p">,</span> <span class="n">annotations</span><span class="p">))</span>

        <span class="k">return</span> <span class="kc">True</span>


    <span class="k">def</span> <span class="nf">_read_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read solve objective</span>

<span class="sd">        This function is called with first token already read and terminates with next token already read.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if a variable has been read, False if nothing to process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check constraint token</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">!=</span> <span class="n">TOKEN_SYMBOL_SOLVE</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>

        <span class="c1"># Check annotations</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_annotations</span><span class="p">()</span>

        <span class="c1"># Read solve objective</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_SYMBOL</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;satisfy&#39;</span><span class="p">,</span> <span class="s1">&#39;minimize&#39;</span><span class="p">,</span> <span class="s1">&#39;maximize&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span>
                <span class="s2">&quot;Solve objective &#39;</span><span class="si">{}</span><span class="s2">&#39; should be a symbol in &#39;satisfy&#39;, &#39;minimize&#39;, &#39;maximize&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>

        <span class="c1"># Read expression if any</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="s1">&#39;satisfy&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_expression</span><span class="p">()</span>

        <span class="c1"># Read ending semicolon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">,</span> <span class="n">TOKEN_SEMICOLON</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>

        <span class="c1"># Store objective</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective</span> <span class="o">=</span> <span class="n">FznObjective</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">annotations</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>


    <span class="k">def</span> <span class="nf">_read_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read an expression</span>

<span class="sd">        First expression token is already read.</span>
<span class="sd">        Function exits with current token following the last expression token</span>

<span class="sd">        Returns:</span>
<span class="sd">            Expression that has been read</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>

        <span class="c1"># Check int constant</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TOKEN_INTEGER</span><span class="p">:</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="c1"># Check set const</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="n">TOKEN_INTERVAL</span><span class="p">:</span>
                <span class="n">tok2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">tok2</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_INTEGER</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Set upper bound </span><span class="si">{}</span><span class="s2"> should be an integer constant.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tok2</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tok2</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">v1</span><span class="p">,)</span> <span class="k">if</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span> <span class="k">else</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">v1</span>

        <span class="c1"># Check float constant</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TOKEN_FLOAT</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># Set of integer constant</span>
        <span class="k">if</span> <span class="n">tok</span> <span class="o">==</span> <span class="n">TOKEN_BRACE_OPEN</span><span class="p">:</span>
            <span class="n">lints</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>
            <span class="k">while</span> <span class="n">tok</span> <span class="o">!=</span> <span class="n">TOKEN_BRACE_CLOSE</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_INTEGER</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Set element </span><span class="si">{}</span><span class="s2"> should be an integer constant.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span>
                <span class="n">lints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">tok</span> <span class="o">==</span> <span class="n">TOKEN_COMMA</span><span class="p">:</span>
                    <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">lints</span>

        <span class="c1"># Check symbols</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TOKEN_SYMBOL</span><span class="p">:</span>
            <span class="n">sid</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span>
            <span class="c1"># Check boolean constant</span>
            <span class="k">if</span> <span class="n">sid</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">sid</span> <span class="o">==</span> <span class="s2">&quot;false&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Check array access</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="n">TOKEN_HOOK_OPEN</span><span class="p">:</span>
                <span class="n">tok2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">tok2</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_INTEGER</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Array index &#39;</span><span class="si">{}</span><span class="s2">&#39; should be an integer constant.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tok2</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">(),</span> <span class="n">TOKEN_HOOK_CLOSE</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
                <span class="c1"># Build array access as a tuple (arr_name, index)</span>
                <span class="k">return</span> <span class="n">sid</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">tok2</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="c1"># Check annotation function call</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="n">TOKEN_PARENT_OPEN</span><span class="p">:</span>
                <span class="n">lexprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">sid</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">!=</span> <span class="n">TOKEN_PARENT_CLOSE</span><span class="p">:</span>
                    <span class="n">lexprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_expression</span><span class="p">())</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="n">TOKEN_COMMA</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lexprs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sid</span>

        <span class="c1"># Array of expressions</span>
        <span class="k">if</span> <span class="n">tok</span> <span class="o">==</span> <span class="n">TOKEN_HOOK_OPEN</span><span class="p">:</span>
            <span class="n">lexprs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">!=</span> <span class="n">TOKEN_HOOK_CLOSE</span><span class="p">:</span>
                <span class="n">lexprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_expression</span><span class="p">())</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="n">TOKEN_COMMA</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">lexprs</span>

        <span class="c1"># Unknown</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Invalid expression start: &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_read_array_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read an array size declaration</span>

<span class="sd">        First expression token is already read.</span>
<span class="sd">        Function exits with current token following the last expression token</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array size as int if given,</span>
<span class="sd">            -1 if size is not precised,</span>
<span class="sd">            None if no array specified</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check array token</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">!=</span> <span class="n">TOKEN_SYMBOL_ARRAY</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Read array specs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">(),</span> <span class="n">TOKEN_HOOK_OPEN</span><span class="p">)</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tok</span> <span class="o">==</span> <span class="n">TOKEN_SYMBOL_INT</span><span class="p">:</span>
            <span class="n">arsize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">TOKEN_INTEGER_ONE</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">(),</span> <span class="n">TOKEN_INTERVAL</span><span class="p">)</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_INTEGER</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Array size &#39;</span><span class="si">{}</span><span class="s2">&#39; should be integer.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tok</span><span class="p">))</span>
            <span class="n">arsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">(),</span> <span class="n">TOKEN_HOOK_CLOSE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">(),</span> <span class="n">TOKEN_SYMBOL_OF</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">arsize</span>


    <span class="k">def</span> <span class="nf">_read_var_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read the domain of a variable.</span>

<span class="sd">        First expression token is already read.</span>
<span class="sd">        Function exits with current token following the last expression token</span>

<span class="sd">        Returns:</span>
<span class="sd">            Variable domain</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get token</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>

        <span class="c1"># Check boolean domain</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">BINARY_DOMAIN</span>

        <span class="c1"># Check undefined domain</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">DEFAULT_INTEGER_VARIABLE_DOMAIN</span>

        <span class="c1"># Read set of integers or interval</span>
        <span class="k">if</span> <span class="n">tok</span> <span class="o">==</span> <span class="n">TOKEN_BRACE_OPEN</span><span class="p">:</span>
            <span class="n">lint</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_expression</span><span class="p">())</span>
            <span class="n">dom</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">llen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lint</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">llen</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">llen</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lint</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">lint</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">dom</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lint</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lint</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lint</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dom</span><span class="p">)</span>

        <span class="c1"># Check integer domain</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_INTEGER</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Variable domain should start by an integer constant.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="n">TOKEN_INTERVAL</span><span class="p">:</span>
            <span class="n">tok2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tok2</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_INTEGER</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Domain upper bound </span><span class="si">{}</span><span class="s2"> should be an integer constant.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tok2</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tok2</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">v1</span><span class="p">,</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),)</span>

        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_INTEGER</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Variable domain should end with an integer constant.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">value</span><span class="p">),)</span>


    <span class="k">def</span> <span class="nf">_read_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read a list of annotations</span>

<span class="sd">        First expression token is already read.</span>
<span class="sd">        Function exits with current token following the last expression token</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary of annotations. Key is name, value is list or parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Check annotation start token</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="n">TOKEN_DOUBLECOLON</span><span class="p">:</span>
            <span class="c1"># Read annotation name</span>
            <span class="n">anm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">anm</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TOKEN_SYMBOL</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Annotation name &#39;</span><span class="si">{}</span><span class="s2">&#39; should be a symbol.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">anm</span><span class="p">))</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tok</span> <span class="o">==</span> <span class="n">TOKEN_PARENT_OPEN</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">!=</span> <span class="n">TOKEN_PARENT_CLOSE</span><span class="p">:</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_expression</span><span class="p">())</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">==</span> <span class="n">TOKEN_COMMA</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_next_token</span><span class="p">()</span>
            <span class="n">result</span><span class="p">[</span><span class="n">anm</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>


    <span class="k">def</span> <span class="nf">_next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read next token</span>
<span class="sd">        Returns:</span>
<span class="sd">            Next read token, None if end of input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">next_token</span><span class="p">()</span>
        <span class="c1"># print(&quot;Line {}, col {}, tok &#39;{}&#39;&quot;.format(self.tokenizer.line_number, self.tokenizer.read_index, self.token))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>


    <span class="k">def</span> <span class="nf">_check_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">etok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check that a read token is a given one an raise an exception if not</span>
<span class="sd">        Args:</span>
<span class="sd">            tok: Read token</span>
<span class="sd">            etok: Expected token</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tok</span> <span class="o">!=</span> <span class="n">etok</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_unexpected_token</span><span class="p">(</span><span class="n">etok</span><span class="p">,</span> <span class="n">tok</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_raise_unexpected_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tok</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Raise a &quot;Unexpected token&quot; exception</span>
<span class="sd">        Args:</span>
<span class="sd">            tok:  Unexpected token</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tok</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span>
        <span class="k">if</span> <span class="n">expect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Unexpected token &#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Read &#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39; instead of expected &#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expect</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_raise_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Raise a Parsing exception</span>
<span class="sd">        Args:</span>
<span class="sd">            msg:  Exception message</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">FznParserException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">build_error_string</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span></div>



<div class="viewcode-block" id="FznParser"><a class="viewcode-back" href="../../../docplex.cp.fzn_parser.py.html#docplex.cp.fzn_parser.FznParser">[docs]</a><span class="k">class</span> <span class="nc">FznParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reader of FZN file format &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span>        <span class="c1"># Read model</span>
                 <span class="s1">&#39;compiled&#39;</span><span class="p">,</span>     <span class="c1"># Model compiled indicator</span>
                 <span class="s1">&#39;reader&#39;</span><span class="p">,</span>       <span class="c1"># FZN reader</span>
                 <span class="s1">&#39;cpo_exprs&#39;</span><span class="p">,</span>    <span class="c1"># Dictionary of CPO expressions. Key=name, value = CPO expr</span>
                 <span class="s1">&#39;predicates&#39;</span><span class="p">,</span>   <span class="c1"># Dictionnary of predicates</span>
                 <span class="s1">&#39;reduce&#39;</span><span class="p">,</span>       <span class="c1"># Reduce model indicator</span>
                 <span class="s1">&#39;defined_var&#39;</span><span class="p">,</span>  <span class="c1"># Variable defined by the currently compiled constraint</span>
                 <span class="s1">&#39;interval_gen&#39;</span><span class="p">,</span> <span class="c1"># Name generator for interval var expressions</span>
                 <span class="s1">&#39;cumul_gen&#39;</span><span class="p">,</span>    <span class="c1"># Name generator for cumul atom expressions</span>
                 <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mdl</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a new CPO format parser</span>

<span class="sd">        Args:</span>
<span class="sd">            mdl:  Model to fill, None (default) to create a new one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FznParser</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">mdl</span> <span class="k">if</span> <span class="n">mdl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">CpoModel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span> <span class="o">=</span> <span class="n">FznReader</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval_gen</span> <span class="o">=</span> <span class="n">IdAllocator</span><span class="p">(</span><span class="s2">&quot;IntervalVar_&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumul_gen</span> <span class="o">=</span> <span class="n">IdAllocator</span><span class="p">(</span><span class="s2">&quot;VarCumulAtom_&quot;</span><span class="p">)</span>

        <span class="c1"># Do not store location information (would store parser instead of real lines)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">source_loc</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Initialize predicates map with those implemented in parser</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">PREDICATES_MAP</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">SELF_PREDICATES_MAP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicates</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># Set model reduction indicator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">fzn_reduce</span>


<div class="viewcode-block" id="FznParser.get_model"><a class="viewcode-back" href="../../../docplex.cp.fzn_parser.py.html#docplex.cp.fzn_parser.FznParser.get_model">[docs]</a>    <span class="k">def</span> <span class="nf">get_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the model that have been parsed</span>

<span class="sd">        Return:</span>
<span class="sd">            CpoModel result of the parsing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compile_to_model</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span></div>


<div class="viewcode-block" id="FznParser.parse"><a class="viewcode-back" href="../../../docplex.cp.fzn_parser.py.html#docplex.cp.fzn_parser.FznParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parse a FZN file</span>

<span class="sd">        Args:</span>
<span class="sd">            cfile: FZN file to read</span>
<span class="sd">        Raises:</span>
<span class="sd">            FznParserException: Parsing exception</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">source_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">source_file</span> <span class="o">=</span> <span class="n">cfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">cfile</span><span class="p">)</span></div>


<div class="viewcode-block" id="FznParser.parse_string"><a class="viewcode-back" href="../../../docplex.cp.fzn_parser.py.html#docplex.cp.fzn_parser.FznParser.parse_string">[docs]</a>    <span class="k">def</span> <span class="nf">parse_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parse a string</span>

<span class="sd">        Result of the parsing is added to the current result model.</span>

<span class="sd">        Args:</span>
<span class="sd">            str: String to parse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_cpo_expr_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; For testing, get the map of CPO expressions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_model</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpo_exprs</span>


    <span class="k">def</span> <span class="nf">_compile_to_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compile FZN model into CPO model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cpo_exprs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Compile parameters</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compile_parameter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># Compile variables</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compile_variable</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># Compile constraints</span>
        <span class="c1"># for k, v in self.cpo_exprs.items():</span>
        <span class="c1">#     print(&quot;{} -&gt; {}&quot;.format(k, id(v)))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">constraints</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compile_constraint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># Compile objective</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compile_objective</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">objective</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_compile_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compile a FZN parameter into CPO model</span>
<span class="sd">        Args:</span>
<span class="sd">            fp: Flatzinc parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fp</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># Build array</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_cpo_expr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">fp</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">expr</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cpo_exprs</span><span class="p">[</span><span class="n">fp</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span>


    <span class="k">def</span> <span class="nf">_compile_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fv</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compile a FZN variable into CPO model</span>
<span class="sd">        Args:</span>
<span class="sd">            fv: Flatzinc variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print(&quot;Compile var: {}&quot;.format(fv))</span>
        <span class="k">if</span> <span class="n">fv</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># Build array of variables</span>
            <span class="k">if</span> <span class="n">fv</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_cpo_expr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">fv</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fv</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">integer_var</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">fv</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">fv</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">integer_var</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">fv</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="n">expr</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">fv</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cpo_exprs</span><span class="p">[</span><span class="n">fv</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span>


    <span class="k">def</span> <span class="nf">_compile_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compile a FZN constraint into CPO model</span>
<span class="sd">        Args:</span>
<span class="sd">            fv: Flatzinc constraint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print(&quot;Compile constraint {}&quot;.format(fc))</span>
        <span class="c1"># Search for corresponding predicate</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicates</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">fc</span><span class="o">.</span><span class="n">predicate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pred</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_exception</span><span class="p">(</span><span class="s2">&quot;Unable to convert predicate &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fc</span><span class="o">.</span><span class="n">predicate</span><span class="p">))</span>
        <span class="c1"># Convert arguments</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_cpo_expr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">fc</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="c1"># Call predicate implementation to build corresponding CPO expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defined_var</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">fc</span><span class="o">.</span><span class="n">defvar</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cpo_expr</span><span class="p">(</span><span class="n">fc</span><span class="o">.</span><span class="n">defvar</span><span class="p">)</span>
        <span class="n">cexpr</span> <span class="o">=</span> <span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># Add to model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cexpr</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_compile_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compile a FZN objective into CPO model</span>
<span class="sd">        Args:</span>
<span class="sd">            fo: Flatzinc objective</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print(&quot;Compile objective {}&quot;.format(fo))</span>
        <span class="k">if</span> <span class="n">fo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">fo</span><span class="o">.</span><span class="n">operation</span> <span class="o">!=</span> <span class="s1">&#39;satisfy&#39;</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cpo_expr</span><span class="p">(</span><span class="n">fo</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
            <span class="n">oxpr</span> <span class="o">=</span> <span class="n">modeler</span><span class="o">.</span><span class="n">maximize</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">if</span> <span class="n">fo</span><span class="o">.</span><span class="n">operation</span> <span class="o">==</span> <span class="s1">&#39;maximize&#39;</span> <span class="k">else</span> <span class="n">modeler</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">oxpr</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_get_cpo_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; retrieve a CPO expression from its FZN representation</span>
<span class="sd">        Args:</span>
<span class="sd">            expr:  FZN expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check basic types</span>
        <span class="n">etyp</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">etyp</span> <span class="ow">in</span> <span class="n">INTEGER_TYPES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">if</span> <span class="n">etyp</span> <span class="ow">in</span> <span class="n">STRING_TYPES</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpo_exprs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">FznParserException</span><span class="p">(</span><span class="s2">&quot;Can not find element </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="c1"># Check array access</span>
        <span class="k">if</span> <span class="n">etyp</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="c1"># Check tuple of integers</span>
            <span class="k">if</span> <span class="n">is_int</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="c1"># Access to array element</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpo_exprs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">FznParserException</span><span class="p">(</span><span class="s2">&quot;Can not find array </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">arr</span><span class="p">)[</span><span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># List</span>
        <span class="k">if</span> <span class="n">etyp</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="c1"># res = build_cpo_expr([self._get_cpo_expr(x) for x in expr])</span>
            <span class="c1"># # For testing purpose, check if each array element is correct</span>
            <span class="c1"># for x, n in zip(res.value, expr):</span>
            <span class="c1">#     if isinstance(x, CpoExpr) and x.name != n:</span>
            <span class="c1">#         print(&quot;Cache size: {}&quot;.format(expression._CPO_VALUES_FROM_PYTHON.size()))</span>
            <span class="c1">#         raise Exception(&quot;Array element found with wrong name {} instead of {} in {}&quot;.format(x.name, n, expr))</span>
            <span class="c1"># return res</span>
            <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_cpo_expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">])</span>

        <span class="c1"># Boolean</span>
        <span class="k">if</span> <span class="n">etyp</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">true</span><span class="p">()</span> <span class="k">if</span> <span class="n">expr</span> <span class="k">else</span> <span class="n">modeler</span><span class="o">.</span><span class="n">false</span><span class="p">()</span>

        <span class="c1"># Unknown</span>
        <span class="k">raise</span> <span class="n">FznParserException</span><span class="p">(</span><span class="s2">&quot;Can not find element </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_pred_cumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stime</span><span class="p">,</span> <span class="n">tdur</span><span class="p">,</span> <span class="n">rreq</span><span class="p">,</span> <span class="n">bnd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Requires that a set of tasks given by start times s, durations d, and resource requirements r,</span>
<span class="sd">        never require more than a global resource bound b at any one time.</span>
<span class="sd">        Args:</span>
<span class="sd">            stime:  Tasks start time</span>
<span class="sd">            tdur:   Tasks tasks durations</span>
<span class="sd">            rreq:   Task resource requirements</span>
<span class="sd">            bnd:    Global resource bound</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create interval vars and cumul atoms</span>
        <span class="n">cumul_atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_get_value</span><span class="p">(</span><span class="n">stime</span><span class="p">),</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">tdur</span><span class="p">),</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">rreq</span><span class="p">)):</span>
            <span class="n">vname</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># Get start time</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">_get_domain_bounds</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CpoIntVar</span><span class="p">):</span>
                <span class="n">vname</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>
            <span class="c1"># Get duration</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="n">_get_domain_bounds</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vname</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">CpoIntVar</span><span class="p">):</span>
                <span class="n">vname</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span>
            <span class="c1"># Get requirement</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="n">_get_domain_bounds</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vname</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">CpoIntVar</span><span class="p">):</span>
                <span class="n">vname</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">name</span>

            <span class="c1"># Create interval variable</span>
            <span class="k">if</span> <span class="n">vname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_gen</span><span class="o">.</span><span class="n">allocate</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vname</span> <span class="o">=</span> <span class="s2">&quot;Itv_&quot;</span> <span class="o">+</span> <span class="n">vname</span>
                <span class="k">if</span> <span class="n">vname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpo_exprs</span><span class="p">:</span>
                    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">nname</span> <span class="o">=</span> <span class="n">vname</span> <span class="o">+</span> <span class="s2">&quot;@1&quot;</span>
                    <span class="k">while</span> <span class="n">nname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cpo_exprs</span><span class="p">:</span>
                        <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">nname</span> <span class="o">=</span> <span class="n">vname</span> <span class="o">+</span> <span class="s2">&quot;@&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
                    <span class="n">vname</span> <span class="o">=</span> <span class="n">nname</span>
            <span class="c1"># Create interval variable</span>
            <span class="n">ivar</span> <span class="o">=</span> <span class="n">interval_var</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">ds</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="n">INTERVAL_MIN</span><span class="p">,</span> <span class="n">INTERVAL_MAX</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">dd</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">vname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cpo_exprs</span><span class="p">[</span><span class="n">vname</span><span class="p">]</span> <span class="o">=</span> <span class="n">ivar</span>

            <span class="c1"># Create pulse</span>
            <span class="n">pulse</span> <span class="o">=</span> <span class="n">modeler</span><span class="o">.</span><span class="n">pulse</span><span class="p">(</span><span class="n">ivar</span><span class="p">,</span> <span class="n">dr</span><span class="p">)</span>
            <span class="n">cumul_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pulse</span><span class="p">)</span>
            <span class="c1"># Replace previous variable by a start of interval variable</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CpoIntVar</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">modeler</span><span class="o">.</span><span class="n">start_of</span><span class="p">(</span><span class="n">ivar</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">CpoIntVar</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">modeler</span><span class="o">.</span><span class="n">size_of</span><span class="p">(</span><span class="n">ivar</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">CpoIntVar</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">modeler</span><span class="o">.</span><span class="n">height_at_start</span><span class="p">(</span><span class="n">ivar</span><span class="p">,</span> <span class="n">pulse</span><span class="p">))</span>

        <span class="c1"># Create final constraint</span>
        <span class="c1"># cumf = CpoFunctionCall(Oper__cumul_function, Type_CumulFunction, (CpoValue(cums, Type_CumulAtomArray), CpoValue([], Type_CumulAtomArray)))</span>
        <span class="n">cumf</span> <span class="o">=</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_sum</span><span class="p">,</span> <span class="n">Type_CumulFunction</span><span class="p">,</span> <span class="p">(</span><span class="n">CpoValue</span><span class="p">(</span><span class="n">cumul_atoms</span><span class="p">,</span> <span class="n">Type_CumulAtomArray</span><span class="p">),))</span>
        <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">greater_or_equal</span><span class="p">(</span><span class="n">bnd</span><span class="p">,</span> <span class="n">cumf</span><span class="p">)</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pred_bool2int</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span> <span class="n">ix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert a boolean expression into integer</span>
<span class="sd">        Args:</span>
<span class="sd">            bx:  Boolean expression</span>
<span class="sd">            ix:  Integer expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bx</span> <span class="o">==</span> <span class="n">ix</span>


    <span class="k">def</span> <span class="nf">_pred_int_lin_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefs</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Scalar product</span>
<span class="sd">        Args:</span>
<span class="sd">            coefs:  Array of integer coefficients</span>
<span class="sd">            vars:   Array of variables</span>
<span class="sd">            res:    Result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defined_var</span>
        <span class="k">if</span> <span class="n">defvar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Call default implementation</span>
            <span class="k">return</span> <span class="n">_scal_prod</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">)</span>

        <span class="c1"># Arrange expression to have defined variable on the left</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">coefs</span><span class="p">)</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="n">_get_value</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
        <span class="c1"># print(&quot;Def_var: {}, id:{}&quot;.format(defvar, id(defvar)))</span>
        <span class="c1"># print(&quot;Vars:&quot;)</span>
        <span class="c1"># for v in vars:</span>
        <span class="c1">#     print(&quot;   {}, id:{}&quot;.format(v, id(v)))</span>
        <span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="nb">vars</span><span class="p">[</span><span class="n">vx</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defvar</span><span class="p">:</span>
                <span class="n">vx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FznParserException</span><span class="p">(</span><span class="s2">&quot;Defined variable </span><span class="si">{}</span><span class="s2"> not found in array of variables&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">defvar</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">vcoef</span> <span class="o">=</span> <span class="n">coefs</span><span class="p">[</span><span class="n">vx</span><span class="p">]</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">[:</span><span class="n">vx</span><span class="p">]</span> <span class="o">+</span> <span class="nb">vars</span><span class="p">[</span><span class="n">vx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">coefs</span> <span class="o">=</span> <span class="n">coefs</span><span class="p">[:</span><span class="n">vx</span><span class="p">]</span> <span class="o">+</span> <span class="n">coefs</span><span class="p">[</span><span class="n">vx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">vcoef</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vcoef</span> <span class="o">=</span> <span class="o">-</span><span class="n">vcoef</span>
            <span class="n">coefs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="o">-</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coefs</span><span class="p">])</span>
            <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">res</span>

        <span class="c1"># Check number of coefs not to 1</span>
        <span class="c1"># if [c != 1 and c != -1 for c in coefs].count(True) &gt; 1:</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coefs</span><span class="p">):</span>
            <span class="n">coefs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="o">-</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coefs</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">modeler</span><span class="o">.</span><span class="n">scal_prod</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">modeler</span><span class="o">.</span><span class="n">scal_prod</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Build expression as a sum</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="nb">vars</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">_mutl_by_int</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">_mutl_by_int</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">-</span> <span class="n">_mutl_by_int</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="c1"># Add result coef if any</span>
        <span class="k">if</span> <span class="n">vcoef</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">/</span> <span class="n">vcoef</span>

        <span class="c1"># Build final equality</span>
        <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">defvar</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">## Custom predicates implementation</span>
<span class="c1">###############################################################################</span>

<span class="k">def</span> <span class="nf">_scal_prod</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Scalar product</span>
<span class="sd">    Args:</span>
<span class="sd">        vals:  Array of values</span>
<span class="sd">        vars:  Array of variables</span>
<span class="sd">        res:   Expected result</span>
<span class="sd">        op:    Comparison operation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if vals are only 1 or -1</span>
    <span class="n">vvals</span> <span class="o">=</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vvals</span><span class="p">):</span>
        <span class="c1"># Replace with a sum</span>
        <span class="n">left</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vvals</span><span class="p">,</span> <span class="n">_get_value</span><span class="p">(</span><span class="nb">vars</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">right</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">_create_sum_of_expr</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">_create_sum_of_expr</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>

    <span class="c1"># General case</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">modeler</span><span class="o">.</span><span class="n">scal_prod</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="nb">vars</span><span class="p">),</span> <span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_subcircuit</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the elements of x to define a subcircuit where x[i] = j means that j is the successor of i and x[i] = i means that i is not in the circuit.</span>
<span class="sd">    Args:</span>
<span class="sd">        x: Array of variables</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper__sub_circuit</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">_insert_zero</span><span class="p">(</span><span class="n">_get_value</span><span class="p">(</span><span class="n">x</span><span class="p">))),))</span>


<span class="k">def</span> <span class="nf">_inverse</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">invf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains two arrays of int variables, f and invf, to represent inverse functions. All the values in each array must be within the index set of the other array.</span>
<span class="sd">    Args:</span>
<span class="sd">        f:     First function as array of int</span>
<span class="sd">        invf:  Inverse function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">_insert_zero</span><span class="p">(</span><span class="n">_get_value</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
    <span class="n">invf</span> <span class="o">=</span> <span class="n">_insert_zero</span><span class="p">(</span><span class="n">_get_value</span><span class="p">(</span><span class="n">invf</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_inverse</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">invf</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_table_int</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Implement custom predicate table_int</span>
<span class="sd">    Args:</span>
<span class="sd">        vars:    Array of variables</span>
<span class="sd">        values:  List of values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Split value array in tuples</span>
    <span class="nb">vars</span> <span class="o">=</span> <span class="n">_get_value</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
    <span class="n">tsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">true</span><span class="p">()</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">tuples</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="n">tsize</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">tsize</span><span class="p">)]</span>

    <span class="c1"># Build allowed assignment expression</span>
    <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">allowed_assignments</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">tuples</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_lex_less_int</span><span class="p">(</span><span class="n">vars1</span><span class="p">,</span> <span class="n">vars2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Requires that the array vars1 is strictly lexicographically less than array vars2</span>
<span class="sd">    Args:</span>
<span class="sd">        vars1:  First array of variables</span>
<span class="sd">        vars2:  Second array of variables</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Add 0 and 1 at the end of arrays to force inequality</span>
    <span class="n">vars1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_get_value</span><span class="p">(</span><span class="n">vars1</span><span class="p">))</span>
    <span class="n">vars1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">vars2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_get_value</span><span class="p">(</span><span class="n">vars2</span><span class="p">))</span>
    <span class="n">vars2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Build lexicographic expression</span>
    <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">lexicographic</span><span class="p">(</span><span class="n">vars1</span><span class="p">,</span> <span class="n">vars2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_bool_clause</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Implementation of bool_clause predicate</span>
<span class="sd">    Args:</span>
<span class="sd">        a:  First array of booleans</span>
<span class="sd">        b:  Second array of booleans</span>
<span class="sd">    Returns:</span>
<span class="sd">        Model expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Default implementation</span>
    <span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_get_value</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">sum_of</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>

    <span class="c1"># Alternative implementation</span>
    <span class="c1"># return (modeler.max_of(a) &gt; 0) | (modeler.min_of(b) == 0)</span>

    <span class="c1"># Other alternative implementation</span>
    <span class="c1"># expr = None</span>
    <span class="c1"># for x in _get_value(a):</span>
    <span class="c1">#     x = x &gt; 0</span>
    <span class="c1">#     expr = x if expr is None else modeler.logical_or(expr, x)</span>
    <span class="c1"># for x in _get_value(b):</span>
    <span class="c1">#     x = x == 0</span>
    <span class="c1">#     expr = x if expr is None else modeler.logical_or(expr, x)</span>
    <span class="c1"># return expr</span>



<span class="c1">###############################################################################</span>
<span class="c1">## Utility functions</span>
<span class="c1">###############################################################################</span>

<span class="k">def</span> <span class="nf">_get_value</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get the python value of an expression</span>
<span class="sd">    Args:</span>
<span class="sd">        expr: Expression (python or CPO)</span>
<span class="sd">    Returns:</span>
<span class="sd">        Python value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">CpoValue</span><span class="p">)</span> <span class="k">else</span> <span class="n">expr</span>


<span class="k">def</span> <span class="nf">_insert_zero</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Insert a zero at the beginning of a python array</span>
<span class="sd">    Args:</span>
<span class="sd">        arr: Source array (list)</span>
<span class="sd">    Returns:</span>
<span class="sd">        Same list with zero inserted at the beginning</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_get_domain_bounds</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get min and max bounds of an expression, integer variable or integer</span>
<span class="sd">    Args:</span>
<span class="sd">        expr: Integer variable or domain</span>
<span class="sd">    Returns:</span>
<span class="sd">        Tuple (min, max)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CpoIntVar</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">get_domain_min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">get_domain_max</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CpoValue</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="n">is_int</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">_create_sum_of_expr</span><span class="p">(</span><span class="n">lexprs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create an expression building the sum of expressions</span>
<span class="sd">    Args:</span>
<span class="sd">        lexprs: List of expressions</span>
<span class="sd">    Returns:</span>
<span class="sd">        Expression that sums all expressions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nbexpr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lexprs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nbexpr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">nbexpr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lexprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nbexpr</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lexprs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">plus</span><span class="p">(</span><span class="n">lexprs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lexprs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_constraint_expr_domain</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create an expression that constrain the domain of an expression to the domain of a variable</span>
<span class="sd">    Args:</span>
<span class="sd">        expr: Expression to constrain</span>
<span class="sd">        var:  Integer var to take domain from</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Use range</span>
        <span class="n">dom</span> <span class="o">=</span> <span class="n">dom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">dom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dom</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># Use allowed assignment</span>
    <span class="k">return</span> <span class="n">modeler</span><span class="o">.</span><span class="n">allowed_assignments</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">domain_iterator</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_mutl_by_int</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create an expression that multiply an expression by an integer</span>
<span class="sd">    Args:</span>
<span class="sd">        expr: Expression to constrain</span>
<span class="sd">        val:  Integer value to multiply expression with</span>
<span class="sd">    Returns:</span>
<span class="sd">        New expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">expr</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">val</span> <span class="o">*</span> <span class="n">expr</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DOcplex.CP: Constraint Programming Modeling for Python V2.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, IBM.
    </div>
  </body>
</html>