

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>docplex.cp.modeler &#8212; DOcplex.CP: Constraint Programming Modeling for Python V2.15 documentation</title>
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DOcplex.CP: Constraint Programming Modeling for Python V2.15 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for docplex.cp.modeler</h1><div class="highlight"><pre>
<span></span><span class="c1"># --------------------------------------------------------------------------</span>
<span class="c1"># Source file provided under Apache License, Version 2.0, January 2004,</span>
<span class="c1"># http://www.apache.org/licenses/</span>
<span class="c1"># (c) Copyright IBM Corp. 2015, 2016, 2017, 2018</span>
<span class="c1"># --------------------------------------------------------------------------</span>
<span class="c1"># Author: Olivier OUDOT, IBM Analytics, France Lab, Sophia-Antipolis</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the functions that allows to construct all operations</span>
<span class="sd">and constraints that can be used in a *CP Optimizer* model.</span>

<span class="sd">There is one Python function per *CP Optimizer* operation or constraint.</span>
<span class="sd">As many operations have multiple combinations of parameters,</span>
<span class="sd">the functions of this module are generally declared with a variable number</span>
<span class="sd">of arguments.</span>
<span class="sd">The valid combinations are detailed in the description of the function.</span>

<span class="sd">Following is the list of textual expressions used to identify the different data types that</span>
<span class="sd">are used by the modeling methods:</span>

<span class="sd"> * *integer expression* represents any integer expression including integer constants, integer variables, and</span>
<span class="sd">   modeling operations that take only integer expressions as arguments.</span>
<span class="sd"> * *boolean expression* represents a logical value true or false.</span>
<span class="sd">   It can be used as integer expressions, with value 1 for true, and 0 for false.</span>
<span class="sd"> * *float expression* represents any floating point expression, including float constants, integer expressions, and</span>
<span class="sd">   modeling operations that take at least one float expression as argument.</span>
<span class="sd"> * *array of xxxx expression* represents a Python list or tuple of *xxxx expression*.</span>
<span class="sd"> * *constraint expression* is an expression that can not be used as an argument of another expression.</span>
<span class="sd"> * *cumul expression* is an expression that represents the sum of individual contributions of intervals.</span>

<span class="sd">In the following, the different modeling functions are briefly presented.</span>

<span class="sd">Core CP modeling functions</span>
<span class="sd">--------------------------</span>

<span class="sd">**Arithmetic expressions**</span>

<span class="sd">The following functions are used to construct arithmetic expressions.</span>
<span class="sd">When exists, the corresponding operator are also overloaded to make easier the writing of expressions.</span>

<span class="sd"> * :meth:`plus`: Addition of two expressions.</span>
<span class="sd"> * :meth:`minus`: Difference between two expressions, or unary minus of a single one.</span>
<span class="sd"> * :meth:`times`: Multiplication of two expressions.</span>
<span class="sd"> * :meth:`int_div`: Integer division of two expressions.</span>
<span class="sd"> * :meth:`float_div`: Floating point division of two expressions.</span>
<span class="sd"> * :meth:`mod`: Modulo of two expressions.</span>
<span class="sd"> * :meth:`abs`:  Absolute value of an expression.</span>
<span class="sd"> * :meth:`square`: Square of an expression.</span>
<span class="sd"> * :meth:`power`: Power of an expression by another.</span>
<span class="sd"> * :meth:`log`: Logarithm of an expression.</span>
<span class="sd"> * :meth:`exponent`: Exponentiation of an expression.</span>
<span class="sd"> * :meth:`sum`: Sum of multiple expressions.</span>
<span class="sd"> * :meth:`min`: Minimum of multiple expressions.</span>
<span class="sd"> * :meth:`max`: Maximum of multiple expressions.</span>

<span class="sd">**Logical expressions**</span>

<span class="sd">The following functions are used to construct logical expressions.</span>
<span class="sd">As for arithmetic, the corresponding operators are also overloaded.</span>

<span class="sd"> * :meth:`logical_and`: Logical AND of two boolean expressions or an array of expressions.</span>
<span class="sd"> * :meth:`logical_or`: Logical OR of two boolean expressions or an array of expressions.</span>
<span class="sd"> * :meth:`logical_not`: Logical NOT of a boolean expression.</span>
<span class="sd"> * :meth:`equal`: Equality between two expressions.</span>
<span class="sd"> * :meth:`diff`: Inequality between two expressions.</span>
<span class="sd"> * :meth:`greater`: An expression is greater than another.</span>
<span class="sd"> * :meth:`greater_or_equal`: An expression is greater or equal to another.</span>
<span class="sd"> * :meth:`less`: An expression is less than another.</span>
<span class="sd"> * :meth:`less_or_equal`: An expression is less or equal to another.</span>
<span class="sd"> * :meth:`true`: Always true boolean expression.</span>
<span class="sd"> * :meth:`false`: Always false boolean expression.</span>

<span class="sd">**General purpose**</span>

<span class="sd">Following functions allow to construct general purpose expressions and constraints.</span>

<span class="sd"> * :meth:`all_diff`: Constrains multiple expressions to be all different.</span>
<span class="sd"> * :meth:`abstraction`: Abstracts the values of one array as values in another array.</span>
<span class="sd"> * :meth:`bool_abstraction`: Abstracts the values of one array as boolean values in another array.</span>
<span class="sd"> * :meth:`count`: Counts the occurrences of an expression in an array of integer expressions.</span>
<span class="sd"> * :meth:`count_different`: Counts the number of different values in an array of integer expressions.</span>
<span class="sd"> * :meth:`scal_prod`: Scalar product of two vectors.</span>
<span class="sd"> * :meth:`pack`: Maintains the load on a set of containers given objects sizes and assignments.</span>
<span class="sd"> * :meth:`distribute`: Calculates and/or constrains the distribution of values taken by an array of integer expressions.</span>
<span class="sd"> * :meth:`sequence`:  Constrains the number of occurrences of the values taken by the different subsets of consecutive *k* variables.</span>
<span class="sd"> * :meth:`constant`: Creates an expression from a numeric constant.</span>
<span class="sd"> * :meth:`element`: Access to an element of an array using an integer expression.</span>
<span class="sd"> * :meth:`range`: Restricts the bounds of an integer or floating-point expression.</span>
<span class="sd"> * :meth:`all_min_distance`: Constraint on the minimum absolute distance between a pair of integer expressions in an array.</span>
<span class="sd"> * :meth:`if_then`: Creates and returns the new constraint e1 =&gt; e2.</span>
<span class="sd"> * :meth:`inverse`: Constrains elements of one array to be inverses of another.</span>
<span class="sd"> * :meth:`allowed_assignments`: Explicitly defines allowed assignments for one or more integer expressions.</span>
<span class="sd"> * :meth:`forbidden_assignments`: Explicitly defines forbidden assignments for one or more integer expressions.</span>
<span class="sd"> * :meth:`lexicographic`: Constraint which maintains two arrays to be lexicographically ordered.</span>
<span class="sd"> * :meth:`standard_deviation`: Standard deviation of the values of the variables in an array.</span>
<span class="sd"> * :meth:`strong`: Encourage CP Optimizer to produce stronger (higher inference) constraints.</span>
<span class="sd"> * :meth:`slope_piecewise_linear`: Evaluates piecewise-linear function given by set of breaking points and slopes.</span>
<span class="sd"> * :meth:`coordinate_piecewise_linear`: Evaluates piecewise-linear function given by set of breaking points and values.</span>

<span class="sd">**Objective**</span>

<span class="sd">Following functions are used to express what expression(s) is to be minimized or maximized.</span>

<span class="sd"> * :meth:`minimize`: Specify one expression to minimize.</span>
<span class="sd"> * :meth:`minimize_static_lex`: Specify several expressions to minimize.</span>
<span class="sd"> * :meth:`maximize`: Specify one expression to maximize.</span>
<span class="sd"> * :meth:`maximize_static_lex`: Specify several expressions to maximize.</span>


<span class="sd">Scheduling functions</span>
<span class="sd">--------------------</span>

<span class="sd">**Interval variables**</span>

<span class="sd">Following functions allow to construct expressions concerning interval variables.</span>

<span class="sd"> * :meth:`start_of`: Start of an interval variable.</span>
<span class="sd"> * :meth:`end_of`: End of an interval variable.</span>
<span class="sd"> * :meth:`length_of`: Length of an interval variable.</span>
<span class="sd"> * :meth:`size_of`: Size of an interval variable.</span>
<span class="sd"> * :meth:`presence_of`: Presence status of an interval variable.</span>
<span class="sd"> * :meth:`start_at_start`: Constrains the delay between the starts of two interval variables.</span>
<span class="sd"> * :meth:`start_at_end`: Constrains the delay between the start of one interval variable and end of another one.</span>
<span class="sd"> * :meth:`start_before_start`: Constrains the minimum delay between starts of two interval variables.</span>
<span class="sd"> * :meth:`start_before_end`: Constrains minimum delay between the start of one interval variable and end of another one.</span>
<span class="sd"> * :meth:`end_at_start`: Constrains the delay between the end of one interval variable and start of another one.</span>
<span class="sd"> * :meth:`end_at_end`:  Constrains the delay between the ends of two interval variables.</span>
<span class="sd"> * :meth:`end_before_start`: Constrains minimum delay between the end of one interval variable and start of another one.</span>
<span class="sd"> * :meth:`end_before_end`: Constrains the minimum delay between the ends of two interval variables.</span>
<span class="sd"> * :meth:`forbid_start`: Forbids an interval variable to start during specified regions.</span>
<span class="sd"> * :meth:`forbid_end`: Forbids an interval variable to end during specified regions.</span>
<span class="sd"> * :meth:`forbid_extent`: Forbids an interval variable to overlap with specified regions.</span>
<span class="sd"> * :meth:`overlap_length`: Length of the overlap of two interval variables.</span>
<span class="sd"> * :meth:`start_eval`: Evaluates a segmented function at the start of an interval variable.</span>
<span class="sd"> * :meth:`end_eval`: Evaluates a segmented function at the end of an interval variable.</span>
<span class="sd"> * :meth:`size_eval`: Evaluates a segmented function on the size of an interval variable.</span>
<span class="sd"> * :meth:`length_eval`: Evaluates segmented function on the length of an interval variable.</span>
<span class="sd"> * :meth:`span`: Creates a span constraint between interval variables.</span>
<span class="sd"> * :meth:`alternative`: Creates an alternative constraint between interval variables.</span>
<span class="sd"> * :meth:`synchronize`: Creates a synchronization constraint between interval variables.</span>
<span class="sd"> * :meth:`isomorphism`: Creates a isomorphism constraint between two sets of interval variables.</span>

<span class="sd">**Sequence variables**</span>

<span class="sd">Following functions allow to construct expressions concerning sequence variables.</span>

<span class="sd"> * :meth:`first`: Constrains an interval variable to be the first in a sequence.</span>
<span class="sd"> * :meth:`last`: Constrains an interval variable to be the last in a sequence.</span>
<span class="sd"> * :meth:`before`: Constrains an interval variable to be before another interval variable in a sequence.</span>
<span class="sd"> * :meth:`previous`: Constrains an interval variable to be previous to another interval variable in a sequence.</span>
<span class="sd"> * :meth:`start_of_next`: Start of the interval variable that is next in a sequence.</span>
<span class="sd"> * :meth:`start_of_prev`: Start of the interval variable that is previous in a sequence.</span>
<span class="sd"> * :meth:`end_of_next`: End of the interval variable that is next in a sequence.</span>
<span class="sd"> * :meth:`end_of_prev`: End of the interval variable that is previous in a sequence.</span>
<span class="sd"> * :meth:`length_of_next`: Length of the interval variable that is next in a sequence.</span>
<span class="sd"> * :meth:`length_of_prev`: Length of the interval variable that is previous in a sequence.</span>
<span class="sd"> * :meth:`size_of_next`: Size of the interval variable that is next in a sequence.</span>
<span class="sd"> * :meth:`size_of_prev`: Size of the interval variable that is previous in a sequence.</span>
<span class="sd"> * :meth:`type_of_next`: Type of the interval variable that is next in a sequence.</span>
<span class="sd"> * :meth:`type_of_prev`: Type of the interval variable that is previous in a sequence.</span>
<span class="sd"> * :meth:`no_overlap`: Constrains a set of interval variables not to overlap each others</span>
<span class="sd"> * :meth:`same_sequence`: creates a same-sequence constraint between two sequence variables.</span>
<span class="sd"> * :meth:`same_common_subsequence`: Creates a same-common-subsequence constraint between two sequence variables.</span>

<span class="sd">**Cumulative expressions**</span>

<span class="sd">A cumul function expression is an expression whose value in a solution is a function from the set of integers</span>
<span class="sd">to the set of non-negative integers.</span>
<span class="sd">A cumul function expression represents the sum of individual contributions of intervals.</span>
<span class="sd">A panel of elementary cumul function expressions is available to describe the individual contribution of</span>
<span class="sd">an interval variable (or a fixed interval) to a cumul function expression:</span>

<span class="sd"> * A pulse function is an elementary function defined by an interval variable (or a fixed interval) whose value is</span>
<span class="sd">   equal to 0 outside the interval and equal to a non-negative constant on the interval.</span>
<span class="sd">   This value is called the height of the pulse function.</span>
<span class="sd"> * A step function is an elementary function defined by one of the end-points of an interval variable</span>
<span class="sd">   (its start or end) whose value is equal to 0 before this end-point and equal to a non-negative constant</span>
<span class="sd">   after the end-point.</span>
<span class="sd">   This value is called the height of the step function.</span>
<span class="sd"> * A cumul function expression is defined as the sum of the above elementary functions or their opposite.</span>
<span class="sd">   Several constraints over cumul function expressions are provided.</span>
<span class="sd">   These constraints allow restricting the possible values of the function over the complete horizon or over</span>
<span class="sd">   some fixed or variable interval:</span>

<span class="sd">Available methods are:</span>

<span class="sd"> * :meth:`pulse`: Elementary cumul function of constant value between the start and the end of an interval.</span>
<span class="sd"> * :meth:`step_at`: Elementary cumul function of constant value after a given point.</span>
<span class="sd"> * :meth:`step_at_start`: Elementary cumul function of constant value after the start of an interval.</span>
<span class="sd"> * :meth:`step_at_end`: Elementary cumul function of constant value after the end of an interval.</span>
<span class="sd"> * :meth:`height_at_start`: Contribution of an interval variable to a cumul function at its start point.</span>
<span class="sd"> * :meth:`height_at_end`: Contribution of an interval variable to a cumul function at its end point.</span>
<span class="sd"> * :meth:`always_in`: Restrict the possible values of a cumul expression (or a state function) to a particular range</span>
<span class="sd"> * :meth:`cumul_range`: Limits the range of a cumul function expression.</span>

<span class="sd">**State functions**</span>

<span class="sd">A state function is a decision variable whose value is a set of non-overlapping intervals over which the</span>
<span class="sd">function maintains a particular non-negative integer state.</span>
<span class="sd">In between those intervals, the state of the function is not defined, typically because of an ongoing</span>
<span class="sd">transition between two states.</span>

<span class="sd">A set of constraints are available to restrict the evolution of a state function:</span>

<span class="sd"> * :meth:`always_in`: Restrict the possible values of a state function (or a cumul expression) to a particular range.</span>
<span class="sd"> * :meth:`always_no_state`: Ensures that a state function is undefined on an interval.</span>
<span class="sd"> * :meth:`always_constant`: Ensures a constant state for a state function on an interval.</span>
<span class="sd"> * :meth:`always_equal`: Fixes a given state for a state function during a variable or fixed interval.</span>

<span class="sd">Search phases</span>
<span class="sd">-------------</span>

<span class="sd">**Variable evaluators**</span>

<span class="sd">An evaluator of integer variables is an object that is used by selectors of variables to define instantiation strategies.</span>

<span class="sd"> * :meth:`domain_size`: Number of elements in the current domain of the variable chosen by the search.</span>
<span class="sd"> * :meth:`domain_max`: Maximum value in the current domain of the variable chosen by the search.</span>
<span class="sd"> * :meth:`domain_min`: Minimum value in the current domain of the variable chosen by the search.</span>
<span class="sd"> * :meth:`var_impact`: Average reduction of the search space of the variable chosen by the search.</span>
<span class="sd"> * :meth:`var_local_impact`: Impact of the variable computed at the current node of the search tree.</span>
<span class="sd"> * :meth:`var_index`: Index of the variable in an array of variables.</span>
<span class="sd"> * :meth:`var_success_rate`: Success rate of the variable.</span>
<span class="sd"> * :meth:`impact_of_last_branch`: Domain reduction that the last instantiation made by search has achieved on the evaluated variable.</span>
<span class="sd"> * :meth:`explicit_var_eval`: Variable evaluator that gives an explicit value to variables.</span>

<span class="sd">**Value evaluators**</span>

<span class="sd">An evaluator of integer values is an object that is used by value selectors to define instantiation strategies.</span>

<span class="sd"> * :meth:`value`: Returns as evaluation the value itself.</span>
<span class="sd"> * :meth:`value_impact`: Average reduction of the search space observed so far when instantiating the selected variable to the evaluated value.</span>
<span class="sd"> * :meth:`value_success_rate`: Success rate of instantiating the selected variable to the evaluated value.</span>
<span class="sd"> * :meth:`value_index`: Index of the value in an array of integer values.</span>
<span class="sd"> * :meth:`explicit_value_eval`: Gives an explicit evaluation to values.</span>

<span class="sd">**Variable selectors**</span>

<span class="sd">A selector of integer variables is used by variable choosers to define search strategies.</span>

<span class="sd"> * :meth:`select_smallest`: Selector of integer variables having the smallest evaluation according to a given evaluator.</span>
<span class="sd"> * :meth:`select_largest`: Selector of integer variables having the largest evaluation according to a given evaluator.</span>
<span class="sd"> * :meth:`select_random_var`: Selector of integer variables that selects a variable randomly.</span>

<span class="sd">**Value selectors**</span>

<span class="sd">A selector of integer values is used by value choosers to define search strategies.</span>

<span class="sd"> * :meth:`select_smallest`: Selector of integer values having the smallest evaluation according to a given evaluator.</span>
<span class="sd"> * :meth:`select_largest`: Selector of integer values having the smallest evaluation according to a given evaluator.</span>
<span class="sd"> * :meth:`select_random_value`: Selector of integer variable value assignments that selects a domain value randomly.</span>

<span class="sd">**Search phases**</span>

<span class="sd">A search phase is used to define instantiation strategies to help the embedded CP Optimizer search.</span>

<span class="sd"> * :meth:`search_phase`: Create a new search phase.</span>


<span class="sd">Detailed description</span>
<span class="sd">--------------------</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">docplex.cp.catalog</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">docplex.cp.expression</span> <span class="k">import</span> <span class="n">CpoExpr</span><span class="p">,</span> <span class="n">CpoFunctionCall</span><span class="p">,</span> <span class="n">CpoValue</span><span class="p">,</span> <span class="n">build_cpo_expr</span><span class="p">,</span> <span class="n">build_cpo_tupleset</span><span class="p">,</span> \
                                  <span class="n">build_cpo_transition_matrix</span><span class="p">,</span> <span class="n">INTERVAL_MAX</span><span class="p">,</span> <span class="n">POSITIVE_INFINITY</span><span class="p">,</span> <span class="n">NEGATIVE_INFINITY</span>
<span class="kn">from</span> <span class="nn">docplex.cp.utils</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="k">try</span><span class="p">:</span>
   <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="k">import</span> <span class="n">Iterator</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Iterator</span>


<span class="c1">###############################################################################</span>
<span class="c1">##  Private methods</span>
<span class="c1">###############################################################################</span>

<span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Expand an argument if it is an iterator &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">):</span>
       <span class="k">return</span> <span class="p">[</span><span class="n">_expand</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">arg</span>


<span class="k">def</span> <span class="nf">_is_cpo_expr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Check if x is a CPO expression, or an array of CPO expressions &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CpoExpr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="n">builtin_all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">CpoExpr</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_is_int_couple</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Check if x is a tuple or list of 2 integers &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">is_int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_is_cpo_array</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Check if argument could be mapped into CPO array &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">CpoExpr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">is_array</span>
    <span class="k">return</span> <span class="n">is_array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">and</span> <span class="n">builtin_any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CpoExpr</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">)</span>


<span class="c1"># Map of type names</span>
<span class="n">TYPE_NAMES</span> <span class="o">=</span> <span class="p">{</span><span class="n">Type_Bool</span><span class="p">:</span>                  <span class="s2">&quot;boolean&quot;</span><span class="p">,</span>
              <span class="n">Type_BoolExpr</span><span class="p">:</span>              <span class="s2">&quot;boolean expression&quot;</span><span class="p">,</span>
              <span class="n">Type_BoolExprArray</span><span class="p">:</span>         <span class="s2">&quot;array of boolean expression&quot;</span><span class="p">,</span>
              <span class="n">Type_BoolInt</span><span class="p">:</span>               <span class="s2">&quot;boolean integer&quot;</span><span class="p">,</span>
              <span class="n">Type_Constraint</span><span class="p">:</span>            <span class="s2">&quot;constraint expression&quot;</span><span class="p">,</span>
              <span class="n">Type_CumulAtom</span><span class="p">:</span>             <span class="s2">&quot;cumul atom&quot;</span><span class="p">,</span>
              <span class="n">Type_CumulAtomArray</span><span class="p">:</span>        <span class="s2">&quot;array of cumul atoms&quot;</span><span class="p">,</span>
              <span class="n">Type_CumulExpr</span><span class="p">:</span>             <span class="s2">&quot;cumul expression&quot;</span><span class="p">,</span>
              <span class="n">Type_CumulFunction</span><span class="p">:</span>         <span class="s2">&quot;cumul function&quot;</span><span class="p">,</span>
              <span class="n">Type_Float</span><span class="p">:</span>                 <span class="s2">&quot;float value&quot;</span><span class="p">,</span>
              <span class="n">Type_FloatArray</span><span class="p">:</span>            <span class="s2">&quot;array of floats&quot;</span><span class="p">,</span>
              <span class="n">Type_FloatExpr</span><span class="p">:</span>             <span class="s2">&quot;float expression&quot;</span><span class="p">,</span>
              <span class="n">Type_FloatExprArray</span><span class="p">:</span>        <span class="s2">&quot;array of float expression&quot;</span><span class="p">,</span>
              <span class="n">Type_FloatVar</span><span class="p">:</span>              <span class="s2">&quot;float variable&quot;</span><span class="p">,</span>
              <span class="n">Type_Int</span><span class="p">:</span>                   <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
              <span class="n">Type_IntArray</span><span class="p">:</span>              <span class="s2">&quot;array of integers&quot;</span><span class="p">,</span>
              <span class="n">Type_IntExpr</span><span class="p">:</span>               <span class="s2">&quot;integer expression&quot;</span><span class="p">,</span>
              <span class="n">Type_IntExprArray</span><span class="p">:</span>          <span class="s2">&quot;array of integer expression&quot;</span><span class="p">,</span>
              <span class="n">Type_IntValueChooser</span><span class="p">:</span>       <span class="s2">&quot;chooser of integer value&quot;</span><span class="p">,</span>
              <span class="n">Type_IntValueEval</span><span class="p">:</span>          <span class="s2">&quot;evaluator of integer value&quot;</span><span class="p">,</span>
              <span class="n">Type_IntValueSelector</span><span class="p">:</span>      <span class="s2">&quot;selector of integer value&quot;</span><span class="p">,</span>
              <span class="n">Type_IntValueSelectorArray</span><span class="p">:</span> <span class="s2">&quot;array of integer value selectors&quot;</span><span class="p">,</span>
              <span class="n">Type_IntVar</span><span class="p">:</span>                <span class="s2">&quot;integer variable&quot;</span><span class="p">,</span>
              <span class="n">Type_IntVarArray</span><span class="p">:</span>           <span class="s2">&quot;array of integer variables&quot;</span><span class="p">,</span>
              <span class="n">Type_IntVarChooser</span><span class="p">:</span>         <span class="s2">&quot;chooser of integer variable&quot;</span><span class="p">,</span>
              <span class="n">Type_IntVarEval</span><span class="p">:</span>            <span class="s2">&quot;evaluator of integer variable&quot;</span><span class="p">,</span>
              <span class="n">Type_IntVarSelector</span><span class="p">:</span>        <span class="s2">&quot;selector of integer variable&quot;</span><span class="p">,</span>
              <span class="n">Type_IntVarSelectorArray</span><span class="p">:</span>   <span class="s2">&quot;array of interval variable selectors&quot;</span><span class="p">,</span>
              <span class="n">Type_IntervalArray</span><span class="p">:</span>         <span class="s2">&quot;array of intervals&quot;</span><span class="p">,</span>
              <span class="n">Type_IntervalVar</span><span class="p">:</span>           <span class="s2">&quot;interval variable&quot;</span><span class="p">,</span>
              <span class="n">Type_IntervalVarArray</span><span class="p">:</span>      <span class="s2">&quot;array of interval variables&quot;</span><span class="p">,</span>
              <span class="n">Type_Objective</span><span class="p">:</span>             <span class="s2">&quot;objective function&quot;</span><span class="p">,</span>
              <span class="n">Type_PositiveInt</span><span class="p">:</span>           <span class="s2">&quot;positive integer&quot;</span><span class="p">,</span>
              <span class="n">Type_SearchPhase</span><span class="p">:</span>           <span class="s2">&quot;search phase&quot;</span><span class="p">,</span>
              <span class="n">Type_SegmentedFunction</span><span class="p">:</span>     <span class="s2">&quot;segmented function&quot;</span><span class="p">,</span>
              <span class="n">Type_SequenceVar</span><span class="p">:</span>           <span class="s2">&quot;sequence variable&quot;</span><span class="p">,</span>
              <span class="n">Type_SequenceVarArray</span><span class="p">:</span>      <span class="s2">&quot;array of sequence variables&quot;</span><span class="p">,</span>
              <span class="n">Type_StateFunction</span><span class="p">:</span>         <span class="s2">&quot;state function&quot;</span><span class="p">,</span>
              <span class="n">Type_StepFunction</span><span class="p">:</span>          <span class="s2">&quot;step function&quot;</span><span class="p">,</span>
              <span class="n">Type_TimeInt</span><span class="p">:</span>               <span class="s2">&quot;integer representing a time&quot;</span><span class="p">,</span>
              <span class="n">Type_TransitionMatrix</span><span class="p">:</span>      <span class="s2">&quot;transition matrix&quot;</span><span class="p">,</span>
              <span class="n">Type_TupleSet</span><span class="p">:</span>              <span class="s2">&quot;tuple set&quot;</span><span class="p">,</span>
             <span class="p">}</span>


<span class="k">def</span> <span class="nf">_convert_arg</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">errmsg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert a Python value in CPO and check its value</span>
<span class="sd">    Args:</span>
<span class="sd">        val:  Value to convert</span>
<span class="sd">        name: Argument name</span>
<span class="sd">        type: Expected type</span>
<span class="sd">        errmsg: Optional error message</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">val</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="nb">type</span><span class="p">),</span> <span class="n">errmsg</span> <span class="k">if</span> <span class="n">errmsg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;Argument &#39;</span><span class="si">{}</span><span class="s2">&#39; should be a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">TYPE_NAMES</span><span class="p">[</span><span class="nb">type</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_convert_arg_bool_int</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert a Python value in CPO bool int</span>
<span class="sd">    Args:</span>
<span class="sd">        val:  Value to convert</span>
<span class="sd">        name: Argument name</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">CpoExpr</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">val</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_BoolInt</span><span class="p">),</span> <span class="s2">&quot;Argument &#39;</span><span class="si">{}</span><span class="s2">&#39; should be a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">TYPE_NAMES</span><span class="p">[</span><span class="n">Type_BoolInt</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">CpoValue</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">val</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Type_BoolInt</span><span class="p">)</span>


<span class="c1">#==============================================================================</span>
<span class="c1">#  Arithmetic expressions</span>
<span class="c1">#==============================================================================</span>


<div class="viewcode-block" id="plus"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.plus">[docs]</a><span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression that represents the addition of two expressions.</span>

<span class="sd">    The python operator &#39;+&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *plus(e1, e2)* is equivalent to write *(e1 + e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  First expression that can be integer expression, float expression or cumul expression</span>
<span class="sd">        e2:  Second expression that can be integer expression, float expression or cumul expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression representing (e1 + e2).</span>
<span class="sd">        The expression is integer expression, float expression or cumul expression depending on the type of the arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span></div>


<div class="viewcode-block" id="minus"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.minus">[docs]</a><span class="k">def</span> <span class="nf">minus</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression that represents the difference between two expressions, or the unary minus of a single one.</span>

<span class="sd">    This method can be called with one or two arguments.</span>
<span class="sd">    With one argument, it returns an expression representing the unary minus of its argument.</span>
<span class="sd">    With two arguments, it creates an expression representing the difference between the first and the second argument.</span>
<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">    The python operator &#39;-&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *minus(e1, e2)* is equivalent to write *(e1 - e2)*, and writing minus(e1) is equivalent to write *(-e1)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  First expression that can be integer expression, float expression or cumul expression</span>
<span class="sd">        e2:  Optional.</span>
<span class="sd">             Second expression that can be integer expression, float expression or cumul expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression representing (e1 - e2), or -e1 if e2 is not given.</span>
<span class="sd">        The expression is integer expression, float expression or cumul expression depending on the type of the arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">e2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__neg__</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__sub__</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span></div>


<div class="viewcode-block" id="times"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.times">[docs]</a><span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression that represents the product of two expressions.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  First expression that can be integer or float expression</span>
<span class="sd">        e2:  Second expression that can be integer or float expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression representing (e1 * e2).</span>
<span class="sd">        The expression is integer expression or float expression depending on the type of the arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e2</span><span class="p">))</span></div>


<div class="viewcode-block" id="int_div"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.int_div">[docs]</a><span class="k">def</span> <span class="nf">int_div</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the integer division of two expressions.</span>

<span class="sd">    The python operator &#39;//&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *int_div(e1, e2)* is equivalent to write *(e1 // e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  First integer expression</span>
<span class="sd">        e2:  Second integer expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression representing (e1 // e2).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__floordiv__</span><span class="p">(</span><span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e2</span><span class="p">))</span></div>


<div class="viewcode-block" id="float_div"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.float_div">[docs]</a><span class="k">def</span> <span class="nf">float_div</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the float division of two expressions.</span>

<span class="sd">    The python operator &#39;/&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *float_div(e1, e2)* is equivalent to write *(e1 / e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  First integer or float expression</span>
<span class="sd">        e2:  Second integer or float expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        A float expression representing (e1 / e2).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__truediv__</span><span class="p">(</span><span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e2</span><span class="p">))</span></div>


<div class="viewcode-block" id="mod"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.mod">[docs]</a><span class="k">def</span> <span class="nf">mod</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the modulo of two expressions.</span>

<span class="sd">    The python operator &#39;%&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *mod(e1, e2)* is equivalent to write *(e1 % e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  First integer expression</span>
<span class="sd">        e2:  Second integer expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression representing (e1 % e2).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__mod__</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span></div>


<div class="viewcode-block" id="abs_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.abs_of">[docs]</a><span class="k">def</span> <span class="nf">abs_of</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression that represents the absolute value of an expression.</span>

<span class="sd">    Function *abs_of* computes the absolute value of an integer or floating-point expression *x*.</span>
<span class="sd">    The type of the function is the same as the type of its argument.</span>

<span class="sd">    *abs_of(x)* is a more efficient way of writing *max(x, -x)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Integer or floating-point expression for which the absolute value is to be computed.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Model expression of type float or integer (same as argument type)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExpr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_abs</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,))</span>
    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_FloatExpr</span><span class="p">),</span> <span class="s2">&quot;Argument should be a integer or float expression&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_abs</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,))</span></div>


<div class="viewcode-block" id="abs"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.abs">[docs]</a><span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression that represents the absolute value of an expression.</span>

<span class="sd">    Function *abs* computes the absolute value of an integer or floating-point expression *x*.</span>
<span class="sd">    The type of the function is the same as the type of its argument.</span>

<span class="sd">    *abs(x)* is a more efficient way of writing *max(x, -x)*.</span>

<span class="sd">    Implementation of this method is proof to import all functions of this module at root level.</span>
<span class="sd">    It recalls the builtin abs() function if no model expression is found in the parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Integer or floating-point expression for which the absolute value is to be computed.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Model expression of type float or integer (same as argument type)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check call to builtin function</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_cpo_expr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">builtin_abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">abs_of</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="square"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.square">[docs]</a><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the square of a numeric expression.</span>

<span class="sd">    Function *square* computes the square of *x*.</span>
<span class="sd">    Depending on the type of *x* the result is an integer or a floating-point expression.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Integer or float expression.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression representing (x * x).</span>
<span class="sd">        Type is the same than parameter (integer expression or float expression).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExpr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_square</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,))</span>
    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_FloatExpr</span><span class="p">),</span> <span class="s2">&quot;Argument should be a integer or float expression&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_square</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,))</span></div>


<div class="viewcode-block" id="power"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.power">[docs]</a><span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression that represents the power of an expression by another.</span>

<span class="sd">    The python operator &#39;**&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *power(e1, e2)* is equivalent to write *(e1 ** e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        v:  Float expression</span>
<span class="sd">        p:  Power float expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        A float expression representing (e1 ** e2).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="fm">__pow__</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="log"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.log">[docs]</a><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the logarithm of an expression</span>

<span class="sd">    Args:</span>
<span class="sd">        x: A float expression.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A float expression representing log(*x*)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_log</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">),))</span></div>


<div class="viewcode-block" id="exponent"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.exponent">[docs]</a><span class="k">def</span> <span class="nf">exponent</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the exponentiation of an expression.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: A float expression.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A float expression representing exp(*x*)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_exponent</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">),))</span></div>


<div class="viewcode-block" id="sum_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.sum_of">[docs]</a><span class="k">def</span> <span class="nf">sum_of</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the sum of all expressions in an array of expressions.</span>

<span class="sd">    The function *sum_of* computes the sum of *x*.</span>
<span class="sd">    Depending on the type of *x* the result is an integer, floating-point or cumul expression.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array of integer, floating-point or cumul expressions.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer, float or cumul expression depending on the type of argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build model expression</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Array of integer expressions</span>
    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">):</span>
        <span class="c1"># alen = len(arr.value)</span>
        <span class="c1"># if alen == 1:</span>
        <span class="c1">#     return arr.value[0]</span>
        <span class="c1"># if alen == 2:</span>
        <span class="c1">#     return arr.value[0] + arr.value[1]</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_sum</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">arr</span><span class="p">,))</span>

    <span class="c1"># Array of float expressions</span>
    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_FloatExprArray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_sum</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">arr</span><span class="p">,))</span>

    <span class="c1"># Array of Cumul expr</span>
    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_CumulExprArray</span><span class="p">),</span> <span class="s2">&quot;Argument should be an array of integer, float or cumul expressions&quot;</span>
    <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alen</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">alen</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_sum</span><span class="p">,</span> <span class="n">Type_CumulExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">arr</span><span class="p">,))</span></div>


<div class="viewcode-block" id="sum"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.sum">[docs]</a><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the sum of all expressions in an array of expressions.</span>

<span class="sd">    The function *sum* computes the sum of all expressions in array *x*.</span>
<span class="sd">    If all elements of *x* are integer expressions, result is an integer expression.</span>
<span class="sd">    If at least one element of x is a floating-point expression, result is a floating-point expression.</span>

<span class="sd">    Implementation of this method is proof to import all functions of this module at root level.</span>
<span class="sd">    It recalls the builtin sum() function if no model expression is found in the parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        arr: An array of integer or floating-point expressions.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer or float expression depending on the type of argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check calls to builtin sum()</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builtin_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="c1"># Check array of model expressions</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">_expand</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sum_of</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">if</span> <span class="n">_is_cpo_array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">else</span> <span class="n">builtin_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span></div>


<div class="viewcode-block" id="min_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.min_of">[docs]</a><span class="k">def</span> <span class="nf">min_of</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Computes the minimum of an array or a list of integer or floating-point expressions.</span>

<span class="sd">    The *min_of* function returns an expression which has the same value as the</span>
<span class="sd">    minimum of the supplied arguments.</span>
<span class="sd">    The return type corresponds to the type of arguments supplied.</span>

<span class="sd">    List of expressions can be given extensively, or as a single iterable of expressions.</span>

<span class="sd">    Args:</span>
<span class="sd">        arr: Array of integer or floating-point expressions, or first expression of the list</span>
<span class="sd">        *args: Other expressions if first argument is not already an iterable</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer or float expression according to the type of parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build array of arguments</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">]</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="c1"># Check if single argument that is not an array</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">is_array</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Determine array and element/result type</span>
    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_FloatExprArray</span><span class="p">),</span> <span class="s2">&quot;Argument should be an array of integer or float expressions&quot;</span>
    <span class="n">rtype</span> <span class="o">=</span> <span class="n">Type_IntExpr</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">Type_FloatExpr</span>

    <span class="c1"># Check single and pair of expressions</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_min</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_min</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="n">arr</span><span class="p">,))</span></div>


<div class="viewcode-block" id="min"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.min">[docs]</a><span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Computes the minimum of an array of integer or floating-point expressions.</span>

<span class="sd">    The *min* function returns an expression which has the same value as the</span>
<span class="sd">    minimum of the supplied arguments.</span>
<span class="sd">    The return type corresponds to the type of arguments supplied.</span>

<span class="sd">    List of expressions can be given extensively, or as a single iterable of expressions.</span>

<span class="sd">    Implementation of this method is proof to import all functions of this module at root level.</span>
<span class="sd">    It recalls the builtin min() function if no model expression is found in the parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        arr: Array of integer or floating-point expressions, or first expression of the list</span>
<span class="sd">        *args: Other expressions if first argument is not already an iterable</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer or float expression according to the type of parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check calls to builtin min()</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builtin_min</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">]</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">_expand</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">min_of</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">if</span> <span class="n">_is_cpo_array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">else</span> <span class="n">builtin_min</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span></div>


<div class="viewcode-block" id="max_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.max_of">[docs]</a><span class="k">def</span> <span class="nf">max_of</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Computes the maximum of an array or a list of integer or floating-point expressions.</span>

<span class="sd">    The *max_of* function returns an expression which has the same value as the</span>
<span class="sd">    maximum of the supplied arguments.</span>
<span class="sd">    The return type corresponds to the type of arguments supplied.</span>

<span class="sd">    List of expressions can be given extensively, or as a single iterable of expressions.</span>

<span class="sd">    Args:</span>
<span class="sd">        arr: Array of integer or floating-point expressions, or first expression of the list</span>
<span class="sd">        *args: Other expressions if first argument is not already an iterable</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer or float expression according to the type of parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build array of arguments</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">]</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="c1"># Check if single argument that is not an array</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">is_array</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="c1"># Determine array and element/result type</span>
    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_FloatExprArray</span><span class="p">),</span> <span class="s2">&quot;Argument should be an array of integer or float expressions&quot;</span>
    <span class="n">rtype</span> <span class="o">=</span> <span class="n">Type_IntExpr</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">Type_FloatExpr</span>

    <span class="c1"># Check single and pair of expressions</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_max</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_max</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="n">arr</span><span class="p">,))</span></div>


<div class="viewcode-block" id="max"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.max">[docs]</a><span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Computes the maximum of an array of integer or floating-point expressions.</span>

<span class="sd">    The *max* function returns an expression which has the same value as the</span>
<span class="sd">    maximum of the supplied arguments.</span>
<span class="sd">    The return type corresponds to the type of arguments supplied.</span>

<span class="sd">    List of expressions can be given extensively, or as a single iterable of expressions.</span>

<span class="sd">    Implementation of this method is proof to import all functions of this module at root level.</span>
<span class="sd">    It recalls the builtin max() function if no model expression is found in the parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        arr: Array of integer or floating-point expressions, or first expression of the list</span>
<span class="sd">        *args: Other expressions if first argument is not already an iterable</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer or float expression according to the type of parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check calls to builtin max()</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builtin_max</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">]</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">_expand</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">max_of</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">if</span> <span class="n">_is_cpo_array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">else</span> <span class="n">builtin_max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span></div>


<span class="c1">#==============================================================================</span>
<span class="c1">#  Logical expressions</span>
<span class="c1">#==============================================================================</span>


<div class="viewcode-block" id="all_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.all_of">[docs]</a><span class="k">def</span> <span class="nf">all_of</span><span class="p">(</span><span class="n">lexpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the logical AND of an array of boolean expressions.</span>

<span class="sd">    Args:</span>
<span class="sd">        lexpr:  Array (iterable) of boolean expressions</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing the logical AND of all expressions in lexpr.</span>
<span class="sd">        If the array is empty array of expressions, result is CP constant True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build and of expressions as list of logical and</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">lexpr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">true</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">is_array</span><span class="p">(</span><span class="n">lexpr</span><span class="p">),</span> <span class="s2">&quot;Argument should be an array of boolean expressions&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lexpr</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_BoolExpr</span><span class="p">),</span> <span class="s2">&quot;Each array element should be a boolean expression&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">v</span> <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">res</span> <span class="o">&amp;</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="all"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.all">[docs]</a><span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">lexpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the logical AND of an array of expressions.</span>

<span class="sd">    Implementation of this method is proof to import all functions of this module at root level.</span>
<span class="sd">    It recalls the builtin all() function if no model expression is found in the parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        lexpr:  Array (iterable) of expressions</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing the logical AND of all expressions in lexpr.</span>
<span class="sd">        Or the result of the builtin function all() if no model expression is in the list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build and of expressions as list of logical and</span>
    <span class="n">lexpr</span> <span class="o">=</span> <span class="n">_expand</span><span class="p">(</span><span class="n">lexpr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_of</span><span class="p">(</span><span class="n">lexpr</span><span class="p">)</span> <span class="k">if</span> <span class="n">_is_cpo_array</span><span class="p">(</span><span class="n">lexpr</span><span class="p">)</span> <span class="k">else</span> <span class="n">builtin_all</span><span class="p">(</span><span class="n">lexpr</span><span class="p">)</span></div>


<div class="viewcode-block" id="any_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.any_of">[docs]</a><span class="k">def</span> <span class="nf">any_of</span><span class="p">(</span><span class="n">lexpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the logical OR of an array of boolean expressions.</span>

<span class="sd">    Args:</span>
<span class="sd">        lexpr:  Array (iterable) of boolean expressions</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing the logical OR of all expressions in lexpr.</span>
<span class="sd">        If the array is empty array of expressions, result is CP constant False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build and of expressions as list of logical and</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">lexpr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">false</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">is_array</span><span class="p">(</span><span class="n">lexpr</span><span class="p">),</span> <span class="s2">&quot;Argument should be an array of boolean expressions&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lexpr</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_BoolExpr</span><span class="p">),</span> <span class="s2">&quot;Each array element should be a boolean expression&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">v</span> <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">res</span> <span class="o">|</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="any"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.any">[docs]</a><span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">lexpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the logical OR of an array of expressions.</span>

<span class="sd">    Implementation of this method is proof to import all functions of this module at root level.</span>
<span class="sd">    It recalls the builtin any() function if no model expression is found in the parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        lexpr:  Array (iterable) of expressions</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing the logical OR of all expressions in lexpr.</span>
<span class="sd">        Or the result of the builtin function any() if no model expression is in the list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build and of expressions as list of logical and</span>
    <span class="n">lexpr</span> <span class="o">=</span> <span class="n">_expand</span><span class="p">(</span><span class="n">lexpr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">any_of</span><span class="p">(</span><span class="n">lexpr</span><span class="p">)</span> <span class="k">if</span> <span class="n">_is_cpo_array</span><span class="p">(</span><span class="n">lexpr</span><span class="p">)</span> <span class="k">else</span> <span class="n">builtin_any</span><span class="p">(</span><span class="n">lexpr</span><span class="p">)</span></div>


<div class="viewcode-block" id="logical_and"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.logical_and">[docs]</a><span class="k">def</span> <span class="nf">logical_and</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the logical AND of two boolean expressions,</span>
<span class="sd">    or of an array of expressions.</span>

<span class="sd">    The python operator &#39;&amp;&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *logical_and(e1, e2)* is equivalent to write *(e1 &amp; e2)*.</span>

<span class="sd">    Note that python keyword &#39;and&#39; can not be overloaded. Operator &#39;&amp;&#39; is an operator that is usually</span>
<span class="sd">    used for binary operations, with a priority that is different that the logical &#39;and&#39;.</span>
<span class="sd">    We recommend to always fully parenthesise expressions that use such binary operators in place of logical operators.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  First boolean expression, or array of expressions</span>
<span class="sd">        e2:  (Optional) Second boolean expression.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing (e1 and e2), or logical and of all expressions in array e1.</span>
<span class="sd">        If e1 is an empty array of expressions, result is CP constant True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">e2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_logical_and</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="s2">&quot;e1&quot;</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">),</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="s2">&quot;e2&quot;</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">)))</span>
    <span class="c1"># Build and of expressions as list of logical and</span>
    <span class="k">return</span> <span class="n">all_of</span><span class="p">(</span><span class="n">_expand</span><span class="p">(</span><span class="n">e1</span><span class="p">))</span></div>


<div class="viewcode-block" id="logical_or"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.logical_or">[docs]</a><span class="k">def</span> <span class="nf">logical_or</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the logical OR of two boolean expressions,</span>
<span class="sd">    or of an array of expressions.</span>

<span class="sd">    The python operator &#39;|&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *logical_or(e1, e2)* is equivalent to write *(e1 | e2)*.</span>

<span class="sd">    Note that python keyword &#39;or&#39; can not be overloaded. Operator &#39;|&#39; is an operator that is usually</span>
<span class="sd">    used for binary operations, with a priority that is different that the logical &#39;or&#39;.</span>
<span class="sd">    We recommend to always fully parenthesise expressions that use such binary operators in place of logical operators.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  First boolean expression, or array of expressions</span>
<span class="sd">        e2:  (Optional) Second boolean expression.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing (e1 or e2), or logical or of all expressions in array e1.</span>
<span class="sd">        If e1 is an empty array of expressions, result is CP constant False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">e2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_logical_or</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="s2">&quot;e1&quot;</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">),</span>
                                                                <span class="n">_convert_arg</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="s2">&quot;e2&quot;</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">)))</span>
    <span class="c1"># Build and of expressions as list of logical or</span>
    <span class="k">return</span> <span class="n">any_of</span><span class="p">(</span><span class="n">_expand</span><span class="p">(</span><span class="n">e1</span><span class="p">))</span></div>


<div class="viewcode-block" id="logical_not"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.logical_not">[docs]</a><span class="k">def</span> <span class="nf">logical_not</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the logical NOT of a boolean expression.</span>

<span class="sd">    The python operator &#39;~&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *logical_not(e* is equivalent to write *(~e)*.</span>

<span class="sd">    Note that python keyword &#39;not&#39; can not be overloaded. Operator &#39;~&#39; is an operator that is usually</span>
<span class="sd">    used for binary operations, with a priority that is different that the logical &#39;not&#39;.</span>
<span class="sd">    We recommend to always fully parenthesise expressions that use such binary operators in place of logical operators.</span>

<span class="sd">    Args:</span>
<span class="sd">        e:  Boolean expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing not(e).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_logical_not</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">),))</span></div>


<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the equality between two expressions.</span>

<span class="sd">    The python operator &#39;==&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *equal(e1, e2)* is equivalent to write *(e1 == e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  Integer or float expression</span>
<span class="sd">        e2:  Integer or float expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing (e1 == e2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span></div>


<div class="viewcode-block" id="diff"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.diff">[docs]</a><span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing the inequality of two expressions.</span>

<span class="sd">    The python operator &#39;!=&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *diff(e1, e2)* is equivalent to write *(e1 != e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  Integer or float expression</span>
<span class="sd">        e2:  Integer or float expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing (e1 != e2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__ne__</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span></div>


<div class="viewcode-block" id="greater"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.greater">[docs]</a><span class="k">def</span> <span class="nf">greater</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing that an expression is greater than another.</span>

<span class="sd">    The python operator &#39;&gt;&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *greater(e1, e2)* is equivalent to write *(e1 &gt; e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  Integer or float expression</span>
<span class="sd">        e2:  Integer or float expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing (e1 &gt; e2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__gt__</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span></div>


<div class="viewcode-block" id="greater_or_equal"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.greater_or_equal">[docs]</a><span class="k">def</span> <span class="nf">greater_or_equal</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing that an expression is greater or equal to another.</span>

<span class="sd">    The python operator &#39;&gt;=&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *greater_or_equal(e1, e2)* is equivalent to write *(e1 &gt;= e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  Integer, float or cumul expression</span>
<span class="sd">        e2:  Integer, float or cumul expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing (e1 &gt;= e2)</span>
<span class="sd">        A constraint expression if at least one argument is a cumul expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__ge__</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span></div>


<div class="viewcode-block" id="less"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.less">[docs]</a><span class="k">def</span> <span class="nf">less</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression representing that an expression is less than another.</span>

<span class="sd">    The python operator &#39;&lt;&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *less(e1, e2)* is equivalent to write *(e1 &lt; e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  Integer or float expression</span>
<span class="sd">        e2:  Integer or float expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing (e1 &lt; e2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span></div>


<div class="viewcode-block" id="less_or_equal"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.less_or_equal">[docs]</a><span class="k">def</span> <span class="nf">less_or_equal</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *lessOrEqual*.</span>

<span class="sd">    The python operator &#39;&lt;=&#39; is overloaded to implement a call to this modeling method.</span>
<span class="sd">    Writing *less(e1, e2)* is equivalent to write *(e1 &lt;= e2)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  Integer, float or cumul expression</span>
<span class="sd">        e2:  Integer, float or cumul expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression representing (e1 &lt;= e2).</span>
<span class="sd">        A constraint expression if at least one argument is a cumul expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span><span class="o">.</span><span class="fm">__le__</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span></div>


<div class="viewcode-block" id="true"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.true">[docs]</a><span class="k">def</span> <span class="nf">true</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Returns a true boolean expression.</span>

<span class="sd">    The function *true()* does not have any particular purpose except for being a filler.</span>

<span class="sd">    CP Optimizer usually eliminates *true()* from expressions using partial evaluation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A boolean true expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_true</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="false"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.false">[docs]</a><span class="k">def</span> <span class="nf">false</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Returns a false boolean expression.</span>

<span class="sd">    The function *false()* does not have any particular purpose except for being a filler.</span>

<span class="sd">    CP Optimizer usually eliminates *false()* from expressions using partial evaluation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_false</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">())</span></div>


<span class="c1">#==============================================================================</span>
<span class="c1">#  Miscellaneous modeling functions</span>
<span class="c1">#==============================================================================</span>


<div class="viewcode-block" id="all_diff"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.all_diff">[docs]</a><span class="k">def</span> <span class="nf">all_diff</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns a constraint stating that multiple expressions must be all different.</span>

<span class="sd">    Args:</span>
<span class="sd">        arr: Array (list, tuple or iterable) of expressions, or first element of the list</span>
<span class="sd">        *args: Other expressions if first argument is a single expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        New constraint expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">]</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_all_diff</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s2">&quot;arr&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),))</span></div>


<div class="viewcode-block" id="abstraction"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.abstraction">[docs]</a><span class="k">def</span> <span class="nf">abstraction</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">abstractValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns a constraint that abstracts the values of one array as values in another array.</span>

<span class="sd">    For constraint programming: returns a constraint that abstracts the values of expressions contained in one</span>
<span class="sd">    array to expressions contained in another array.</span>

<span class="sd">    This function returns a constraint that abstracts the values of the elements of one array of expressions</span>
<span class="sd">    (called *x*) in a model into the abstract value of another array of expressions (called *y*).</span>
<span class="sd">    In other words, for each element *x[i]*, there is an expression *y[i]* corresponding to the abstraction</span>
<span class="sd">    of *x[i]* with respect to an array of numeric *values*.</span>
<span class="sd">    That is:</span>

<span class="sd">     * *x[i] = v* with *v* in *values* if and only if *y[i] = v*</span>
<span class="sd">     * *x[i] = v* with *v* not in *values* if and only if *y[i] = abstractValue*</span>

<span class="sd">    This constraint maintains a many-to-one mapping that makes it possible to define constraints that impinge</span>
<span class="sd">    only on a particular set of values from the domains of expressions.</span>
<span class="sd">    The abstract value (specified by *abstractValue*) must not be in the domain of *x[i]*.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: An array of abstracted integer expressions.</span>
<span class="sd">        x: An array of reference integer expressions.</span>
<span class="sd">        values: An array of integer values to be abstracted.</span>
<span class="sd">        abstractValue: An escape value (integer constant)</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_abstraction</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">Type_IntArray</span><span class="p">),</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="n">abstractValue</span><span class="p">,</span> <span class="s2">&quot;abstractValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">),</span> <span class="p">))</span></div>


<div class="viewcode-block" id="bool_abstraction"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.bool_abstraction">[docs]</a><span class="k">def</span> <span class="nf">bool_abstraction</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a constraint that abstracts the values of one array as boolean values in another array.</span>

<span class="sd">    This function creates and returns a constraint that abstracts an array of integer expressions in a model.</span>
<span class="sd">    It differs from :meth:`abstraction` in that elements each *y[i]* is Boolean.</span>

<span class="sd">    Like :meth:`abstraction`, for each element *x[i]* there is an expression *y[i]* corresponding to the</span>
<span class="sd">    abstraction of *x[i]* with respect to the *values* array.</span>
<span class="sd">    That is:</span>

<span class="sd">     * *x[i] = v* with *v* in *values* if and only if *y[i] = true()*</span>
<span class="sd">     * *x[i] = v* with *v* not in *values* if and only if *y[i] = false()*</span>

<span class="sd">    This constraint maintains a many-to-one mapping that makes it possible to define constraints that impinge</span>
<span class="sd">    only on a particular set of values from the domains of constrained variables.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: An array of abstracted integer expressions.</span>
<span class="sd">        x: An array of reference integer expressions.</span>
<span class="sd">        values: An array of integer values to abstract.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_bool_abstraction</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                                    <span class="n">_convert_arg</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                                    <span class="n">_convert_arg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">Type_IntArray</span><span class="p">)</span>
                                                                    <span class="p">))</span></div>


<div class="viewcode-block" id="count"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.count">[docs]</a><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the number of occurrences of a given expression in a given array of integer expressions.</span>

<span class="sd">    This expression counts how many of the expressions in *exprs* take the value *v*.</span>

<span class="sd">    For convenience reasons, parameters can be expressed in the reverse order.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs: An array of integer expressions.</span>
<span class="sd">        v:     The value (integer) for which occurrences must be counted.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression representing the number of occurrences of *v* in *exprs*</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exprs</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_Int</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">exprs</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">),</span> <span class="s2">&quot;Argument &#39;exprs&#39; should be an array of integer expressions&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">exprs</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_Int</span><span class="p">),</span> <span class="s2">&quot;Arguments should be an integer and array of integer expressions&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_count</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span></div>


<div class="viewcode-block" id="count_different"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.count_different">[docs]</a><span class="k">def</span> <span class="nf">count_different</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression that counts the number of different values in an array of integer expressions.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs: An array of integer expressions.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression representing the number of values that are different in *exprs*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_count_different</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="s2">&quot;exprs&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span> <span class="p">))</span></div>


<div class="viewcode-block" id="scal_prod"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.scal_prod">[docs]</a><span class="k">def</span> <span class="nf">scal_prod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the scalar product of two vectors.</span>

<span class="sd">    The function *scal_prod* returns an integer or floating-point expression that represents the scalar product</span>
<span class="sd">    of two vectors *x* and *y*.</span>
<span class="sd">    Depending on the type of *x* and *y* the result is either integer or floating-point expression.</span>

<span class="sd">    The versions with one array of constants, integer or float, can be slightly faster.</span>

<span class="sd">    Each argument can be:</span>

<span class="sd">     * an array of integer constants,</span>
<span class="sd">     * an array of float constants,</span>
<span class="sd">     * an array of integer expressions</span>
<span class="sd">     * an array of float expressions.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: First input array to be multiplied.</span>
<span class="sd">        y: Second input array to be multiplied.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_scal_prod</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_FloatExprArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_FloatExprArray</span><span class="p">),</span> <span class="s2">&quot;Arguments should be arrays of integer or float expressions&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_scal_prod</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span></div>


<div class="viewcode-block" id="pack"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.pack">[docs]</a><span class="k">def</span> <span class="nf">pack</span><span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">used</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Maintains the load on a set of containers given objects sizes and assignments.</span>

<span class="sd">    The *pack* constraint is used to represent sub-problems where the requirement is to assign objects to</span>
<span class="sd">    containers such that the capacities or minimum fill levels of the containers are respected.</span>

<span class="sd">    Let&#39;s assume we have *n* objects and *m* containers.</span>
<span class="sd">    The sizes of the array arguments of *pack* must correspond to these constants,</span>
<span class="sd">    that is *load* must be of size *m*, whereas *where* and *size* must be of size *n*.</span>
<span class="sd">    Given assignments to the *where* expressions, the *pack* constraint will calculate the values of</span>
<span class="sd">    the *load* and *used* expressions.</span>

<span class="sd">    All counting is done from 0, and so the interpretation of 5 being assigned to *where[3]* is that object 3</span>
<span class="sd">    (the 4th object) is placed into container 5 (the 6th container).</span>
<span class="sd">    This will be reflected by the inclusion of the size of object 3 (*size[3]*) being included in the calculation</span>
<span class="sd">    of the value of *load[5]*.</span>

<span class="sd">    Naturally, all the arguments (with the exception of *size*) can be constrained by additional constraints.</span>
<span class="sd">    The most common form is to limit the capacity of a container.</span>
<span class="sd">    For example, to limit container 2 to a capacity of 15, one would write *load[2] &lt;= 15*.</span>
<span class="sd">    Minimum fill level requirements can also be specified this way: for example *load[2] &gt;= 12*.</span>
<span class="sd">    Other more esoteric constraints are possible, for example to say that only an even number of containers</span>
<span class="sd">    can be used: *(used % 2) == 0*.</span>
<span class="sd">    If *used* is omitted from the signature, then it will not be possible to specifically</span>
<span class="sd">    constrain the number of containers used.</span>

<span class="sd">    Args:</span>
<span class="sd">        load: An array of integer expressions, each element representing the load (total size of the objects inside)</span>
<span class="sd">              of the corresponding container.</span>
<span class="sd">        where: An array of integer expressions, each element representing in which container the</span>
<span class="sd">               corresponding object is placed.</span>
<span class="sd">        size: An array of integers, each element representing the size of the corresponding object.</span>
<span class="sd">        used: (Optional) An integer expression indicating the number of used containers.</span>
<span class="sd">              That is, the number of containers with at least one object inside.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">load</span>  <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="s2">&quot;load&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">)</span>
    <span class="n">where</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="s2">&quot;where&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">)</span>
    <span class="n">size</span>  <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">Type_IntArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">used</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_pack</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_pack</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">used</span><span class="p">,</span> <span class="s2">&quot;used&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="sequence"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.sequence">[docs]</a><span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">cards</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the number of occurrences of the values taken by the different subsets of consecutive *k* variables.</span>

<span class="sd">    This constraint ensures:</span>

<span class="sd">     * that *cards[i]* will be equal to the number of occurrences of the value *values[i]* in the array *vars*,</span>
<span class="sd">     * and that each sequence of *width* consecutive variables (like *vars[j+1]*, *vars[j+2]*, ..., *vars[j+width]*)</span>
<span class="sd">       takes at least *min* and at most *max* values of the array *values*.</span>

<span class="sd">    Args:</span>
<span class="sd">        min:    The minimum number of allowable values (integer)</span>
<span class="sd">        max:    The maximum number of allowable values (integer)</span>
<span class="sd">        width:  The size of the sequences of consecutive variables (integer)</span>
<span class="sd">        vars:   The array of variables (array of integer expresssions)</span>
<span class="sd">        values: The array of values (array of integers)</span>
<span class="sd">        cards:  The array of cardinality variables (array of integer expressions)</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_sequence</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="s2">&quot;vars&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">Type_IntArray</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="s2">&quot;cards&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                            <span class="p">))</span></div>


<div class="viewcode-block" id="constant"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.constant">[docs]</a><span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression from a numeric constant.</span>

<span class="sd">    This method is generally useless in Python as constants are automatically converted in model expressions.</span>
<span class="sd">    However, it can be useful if the expression has to be named.</span>

<span class="sd">    Args:</span>
<span class="sd">        v:  integer or float constant</span>
<span class="sd">    Returns:</span>
<span class="sd">        A integer expression or float expression depending on the type of *v*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_Float</span><span class="p">),</span> <span class="s2">&quot;Argument should be a integer or float constant&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_constant</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">v</span><span class="p">,))</span></div>


<div class="viewcode-block" id="element"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.element">[docs]</a><span class="k">def</span> <span class="nf">element</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function returns an element of a given array indexed by an integer expression.</span>

<span class="sd">    This function returns an expression for use in a constraint or other expression.</span>
<span class="sd">    The semantics of this expression are: when *index* takes the value *i*,</span>
<span class="sd">    then the value of the expression is equal to *array[i]*.</span>

<span class="sd">    For convenience reasons, parameters can be expressed in any order.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integers, integer expression) =&gt; integer expression</span>
<span class="sd">     * (array of integer expressions, integer expression) =&gt; integer expression</span>
<span class="sd">     * (array of floats, integer expression) =&gt; float expression</span>
<span class="sd">     * (integer expression, array of integers) =&gt; integer expression</span>
<span class="sd">     * (integer expression, array of integer expressions) =&gt; integer expression</span>
<span class="sd">     * (integer expression, array of floats) =&gt; float expression</span>

<span class="sd">    Args:</span>
<span class="sd">        array:  An array in which an element will be selected using subscript.</span>
<span class="sd">        index:  An integer expression used to retrieve array element.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A float or integer expression depending on the type of the array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="c1"># Case where &#39;index&#39; is the index</span>
    <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExpr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">):</span>  <span class="c1"># Type_IntArray is included</span>
            <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_element</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">array</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_FloatArray</span><span class="p">),</span> <span class="s2">&quot;Array should be an array of integer, float, or integer expressions&quot;</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_element</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
    <span class="c1"># Case where &#39;array&#39; is in fact the index</span>
    <span class="k">assert</span> <span class="n">array</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExpr</span><span class="p">),</span> <span class="s2">&quot;At least one argument should be an integer expression representing index&quot;</span>
    <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">):</span>  <span class="c1"># Type_IntArray is included</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_element</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">index</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_FloatArray</span><span class="p">),</span> <span class="s2">&quot;Array should be an array of integer, float, or integer expressions&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_element</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span></div>


<div class="viewcode-block" id="member"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.member">[docs]</a><span class="k">def</span> <span class="nf">member</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Checks if an integer expression is member of an array of expressions.</span>

<span class="sd">    DEPRECATED: use :meth:`allowed_assignments`: instead.</span>

<span class="sd">    Args:</span>
<span class="sd">        element:  Integer expression whose value is to check in the array.</span>
<span class="sd">        array:    Array of integer values</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression denoting the presence of the value in the array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Modeling function &#39;member&#39; is deprecated. Use allowed_assignments instead&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_member</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">&quot;element&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">),</span>
                                                        <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="n">Type_IntArray</span><span class="p">),</span>
                                                        <span class="p">))</span></div>


<div class="viewcode-block" id="in_range"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.in_range">[docs]</a><span class="k">def</span> <span class="nf">in_range</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Restricts the bounds of an integer or floating-point expression.</span>

<span class="sd">    This boolean expression (which is interpreted as a constraint outside of an expression)</span>
<span class="sd">    determines whether the value of expression *x* is inside the range *[lb, ub]*.</span>
<span class="sd">    The returned expression will be true if and only if *x* is no less than *lb* and no greater than *ub*.</span>

<span class="sd">    *range(y, a, b)* is also a more efficient form of writing *a &lt;= y &amp;&amp; y &lt;= b*.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: The integer or floating-point expression.</span>
<span class="sd">        lb: The lower bound.</span>
<span class="sd">        ub: The upper bound.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_range</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">),</span>
                                                       <span class="n">_convert_arg</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="s2">&quot;lb&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">),</span>
                                                       <span class="n">_convert_arg</span><span class="p">(</span><span class="n">ub</span><span class="p">,</span> <span class="s2">&quot;ub&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span></div>


<div class="viewcode-block" id="range"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.range">[docs]</a><span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Restricts the bounds of an integer or floating-point expression.</span>

<span class="sd">    This boolean expression (which is interpreted as a constraint outside of an expression)</span>
<span class="sd">    determines whether the value of expression *x* is inside the range *[lb, ub]*.</span>
<span class="sd">    The returned expression will be true if and only if *x* is no less than *lb* and no greater than *ub*.</span>

<span class="sd">    *range(y, a, b)* is also a more efficient form of writing *a &lt;= y &amp;&amp; y &lt;= b*.</span>

<span class="sd">    Implementation of this method is proof to import all functions of this module at root level.</span>
<span class="sd">    It recalls the builtin range() function if no model expression is found in the parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        x:  The integer or floating-point expression.</span>
<span class="sd">        lb: The lower bound.</span>
<span class="sd">        ub: The upper bound.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builtin_range</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ub</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builtin_range</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lb</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_int</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_int</span><span class="p">(</span><span class="n">ub</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">builtin_range</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">in_range</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span></div>


<div class="viewcode-block" id="all_min_distance"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.all_min_distance">[docs]</a><span class="k">def</span> <span class="nf">all_min_distance</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constraint on the minimum absolute distance between a pair of integer expressions in an array.</span>

<span class="sd">    This constraint makes sure that the absolute distance between any pair</span>
<span class="sd">    of integer expressions in *exprs* will be greater than or equal to the</span>
<span class="sd">    given integer *distance*. In short, for any *i*, *j* distinct indices of *exprs* , it</span>
<span class="sd">    enforces *abs(exprs[i] - exprs[j]) &gt;= distance*.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs:    Array of integer expressions.</span>
<span class="sd">        distance: Integer value used to constrain the distance between two elements of exprs.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A new boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_all_min_distance</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="s2">&quot;exprs&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                                  <span class="n">_convert_arg</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span></div>


<div class="viewcode-block" id="if_then"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.if_then">[docs]</a><span class="k">def</span> <span class="nf">if_then</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates and returns the new constraint e1 =&gt; e2.</span>

<span class="sd">    Args:</span>
<span class="sd">        e1:  First boolean expression</span>
<span class="sd">        e2:  Second boolean expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression stating that e1 =&gt; e2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_if_then</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="s2">&quot;e1&quot;</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">),</span>
                                                         <span class="n">_convert_arg</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="s2">&quot;e2&quot;</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="conditional"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.conditional">[docs]</a><span class="k">def</span> <span class="nf">conditional</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">et</span><span class="p">,</span> <span class="n">ef</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates and returns an expression that depends on a condition.</span>

<span class="sd">    This expression is equivalent of writing (c ? et : ef) in C++ or Java.</span>

<span class="sd">    Args:</span>
<span class="sd">        c:   Boolean expression</span>
<span class="sd">        et:  Integer expression to return if condition *c* is true.</span>
<span class="sd">        ef:  Integer expression to return if condition *c* is false.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Integer expression *et* or *ef* depending on the value of *c*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">element</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">ef</span><span class="p">,</span> <span class="s2">&quot;ef&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">),</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">et</span><span class="p">,</span> <span class="s2">&quot;et&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)])</span></div>


<div class="viewcode-block" id="inverse"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.inverse">[docs]</a><span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">invf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains elements of one array to be inverses of another.</span>

<span class="sd">    This function creates an inverse constraint such that if the length of</span>
<span class="sd">    the arrays *f* and *invf* is *n*, then this function returns a</span>
<span class="sd">    constraint that ensures that:</span>

<span class="sd">     * for all *i* in the interval *[0, n-1]*, *invf[f[i]]* == i*</span>
<span class="sd">     * for all *j* in the interval *[0, n-1]*, *f[invf[j]]* == j*</span>

<span class="sd">    Args:</span>
<span class="sd">        f:    An integer expression array.</span>
<span class="sd">        invf: An integer expression array.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_inverse</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                           <span class="n">_convert_arg</span><span class="p">(</span><span class="n">invf</span><span class="p">,</span> <span class="s2">&quot;invf&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">)))</span></div>


<div class="viewcode-block" id="distribute"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.distribute">[docs]</a><span class="k">def</span> <span class="nf">distribute</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculates and/or constrains the distribution of values taken by an array</span>
<span class="sd">    of integer expressions.</span>

<span class="sd">    The *distribute* constraint is used to count the number of occurrences of  several values in</span>
<span class="sd">    an array of constrained expressions.</span>
<span class="sd">    You can also use *distribute* to force a set of constrained expressions to assume</span>
<span class="sd">    values in such a way that only a limited number of the constrained</span>
<span class="sd">    expressions can assume each value.</span>

<span class="sd">    More precisely, for any index *i* of *counts*, *counts[i]* is equal to the number of</span>
<span class="sd">    expressions in *exprs* who have value of *values[i]*.</span>
<span class="sd">    When using the signature which has *values* missing, then the values counted are assumed to be</span>
<span class="sd">    a set spanning from 0 up to the size of the *counts* array, less one.</span>

<span class="sd">    Args:</span>
<span class="sd">        counts: An array of integer expressions representing, for each element of values, its cardinality in exprs.</span>
<span class="sd">        exprs:  An array of integer expressions for which value occurrences must be counted.</span>
<span class="sd">        values: (Optional) An integer array containing values to count.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_distribute</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                                  <span class="n">_convert_arg</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="s2">&quot;exprs&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_distribute</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="s2">&quot;counts&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                              <span class="n">_convert_arg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">Type_IntArray</span><span class="p">),</span>
                                                              <span class="n">_convert_arg</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="s2">&quot;exprs&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">)))</span></div>
<div class="viewcode-block" id="allowed_assignments"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.allowed_assignments">[docs]</a><span class="k">def</span> <span class="nf">allowed_assignments</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Explicitly defines possible assignments on one or more integer expressions.</span>

<span class="sd">    This boolean expression (which is interpreted as a constraint outside of an expression)</span>
<span class="sd">    determines whether the assignment to a single expression or to an array of expressions</span>
<span class="sd">    is contained within a value set or a tuple set respectively.</span>

<span class="sd">    The boolean expression will be true if and only if (depending on the signature):</span>

<span class="sd">     * the single value of the integer expression *exprs* is present in the array *values*.</span>
<span class="sd">     * the values of the integer expressions *exprs* are present in the tuple set *tuples*.</span>

<span class="sd">    The order of the constrained variables in the array *exprs* is important because the same order</span>
<span class="sd">    is respected in the tuple set *tuples*.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs:  A single integer expression, or an array of integer expressions</span>
<span class="sd">        values: An array of integer expressions, or a set of tuples,</span>
<span class="sd">                that specifies the combinations of allowed values of the expressions exprs.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exprs</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exprs</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExpr</span><span class="p">):</span>
        <span class="c1"># Expr is a single integer</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_allowed_assignments</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">Type_IntArray</span><span class="p">)))</span>

    <span class="c1"># &#39;expr&#39; is an array of expressions, and &#39;values&#39; a tupleset</span>
    <span class="k">assert</span> <span class="n">exprs</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">),</span> <span class="s2">&quot;Argument &#39;exprs&#39; should be an array of integer or an array of integer expressions&quot;</span>
    <span class="n">tset</span> <span class="o">=</span> <span class="n">build_cpo_tupleset</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">tvals</span> <span class="o">=</span> <span class="n">tset</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="n">tvals</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">exprs</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;Arity of tupleset should match the number of expressions&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_allowed_assignments</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">tset</span><span class="p">))</span></div>


<div class="viewcode-block" id="forbidden_assignments"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.forbidden_assignments">[docs]</a><span class="k">def</span> <span class="nf">forbidden_assignments</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Explicitly defines forbidden assignments for one or more integer expressions.</span>

<span class="sd">    This boolean expression (which is interpreted as a constraint outside of an expression)</span>
<span class="sd">    determines whether the assignment to a single expression or to an array of expressions</span>
<span class="sd">    is not contained within a value set or a tuple set respectively.</span>

<span class="sd">    The boolean expression will be true if and only if (depending on the signature):</span>

<span class="sd">     * the single value of the integer expression *exprs* is not present in the array *values*.</span>
<span class="sd">     * the values of the array of integer expressions *exprs* are not present in the tuple set *values*.</span>

<span class="sd">    The order of the constrained variables in the array *exprs* is important because the same order</span>
<span class="sd">    is respected in the tuple set *tuples*.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs:  A single integer expression, or an array of integer expressions</span>
<span class="sd">        values: An array of integer expressions, or a set of tuples,</span>
<span class="sd">                that specifies the combinations of forbidden values of the expressions exprs.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exprs</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exprs</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExpr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_forbidden_assignments</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">Type_IntArray</span><span class="p">)))</span>

    <span class="c1"># &#39;expr&#39; is an array of expressions, and &#39;values&#39; a tupleset</span>
    <span class="k">assert</span> <span class="n">exprs</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntExprArray</span><span class="p">),</span> <span class="s2">&quot;Argument &#39;exprs&#39; should be an array of integer or an array of integer expressions&quot;</span>
    <span class="n">tset</span> <span class="o">=</span> <span class="n">build_cpo_tupleset</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">tvals</span> <span class="o">=</span> <span class="n">tset</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="n">tvals</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">exprs</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;Arity of tupleset should match the number of expressions&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_forbidden_assignments</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">tset</span><span class="p">))</span></div>


<div class="viewcode-block" id="lexicographic"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.lexicographic">[docs]</a><span class="k">def</span> <span class="nf">lexicographic</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns a constraint which maintains two arrays to be lexicographically ordered.</span>

<span class="sd">    The *lexicographic* function returns a constraint which maintains two arrays to be</span>
<span class="sd">    lexicographically ordered.</span>

<span class="sd">    More specifically, *lexicographic(x, y)* maintains that *x* is less than or equal to *y*</span>
<span class="sd">    in the lexicographical sense of the term.</span>
<span class="sd">    This means that either both arrays are equal or that there exists *i &lt; size(x)* such that</span>
<span class="sd">    for all *j &lt; i*, *x[j] = y[j]* and *x[i] &lt; y[i]*.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array of integer expressions.</span>
<span class="sd">        y: An array of integer expressions.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_lexicographic</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">)))</span></div>


<div class="viewcode-block" id="standard_deviation"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.standard_deviation">[docs]</a><span class="k">def</span> <span class="nf">standard_deviation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">meanLB</span><span class="o">=</span><span class="n">NEGATIVE_INFINITY</span><span class="p">,</span> <span class="n">meanUB</span><span class="o">=</span><span class="n">POSITIVE_INFINITY</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a constrained numeric expression equal</span>
<span class="sd">    to the standard deviation of the values of the variables in an array.</span>

<span class="sd">    This function creates a new constrained numeric expression which is equal to the</span>
<span class="sd">    standard deviation of the values of the variables in the array *x*.</span>

<span class="sd">    The mean of the values of the variables in the array x is constrained to be in the</span>
<span class="sd">    interval [meanLB, meanUB].</span>

<span class="sd">    Args:</span>
<span class="sd">        x:      An array of integer expressions.</span>
<span class="sd">        meanLB (Optional): A float value for lower bound on the mean of the array, -infinity if not given.</span>
<span class="sd">        meanUB (Optional): A float value upper bound on the mean of the array, infinity if not given.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check optional bounds</span>
    <span class="c1"># if (meanLB is NEGATIVE_INFINITY) and (meanUB is POSITIVE_INFINITY) and (_get_generation_version() &gt; &quot;12.8&quot;):</span>
    <span class="c1">#     return CpoFunctionCall(Oper_standard_deviation, Type_FloatExpr, (_convert_arg(x, &quot;x&quot;, Type_IntExprArray),))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_standard_deviation</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                                     <span class="n">_convert_arg</span><span class="p">(</span><span class="n">meanLB</span><span class="p">,</span> <span class="s2">&quot;meanLB&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">),</span>
                                                                     <span class="n">_convert_arg</span><span class="p">(</span><span class="n">meanUB</span><span class="p">,</span> <span class="s2">&quot;meanUB&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">),))</span></div>


<div class="viewcode-block" id="strong"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.strong">[docs]</a><span class="k">def</span> <span class="nf">strong</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A model annotation to encourage CP Optimizer to produce stronger (higher inference) constraints.</span>

<span class="sd">    The *strong* constraint strengthens the model on the expressions *x*.</span>
<span class="sd">    This is done by creating an *allowed_assignments* constraint in place of the *strong* constraint</span>
<span class="sd">    during presolve.</span>
<span class="sd">    Only the assignments to the expressions which do not result in an immediate inconsistency are</span>
<span class="sd">    added to the tuple set of the *allowed_assignments* constraint.</span>

<span class="sd">    Constraints that can be identified as redundant (when taken together with this new constraint)</span>
<span class="sd">    are removed from the model during presolve.</span>
<span class="sd">    This is the case for constraints that are only over the variables of the array given as argument.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array of integer expressions over which propagation is to be strengthened.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_strong</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),))</span></div>


<div class="viewcode-block" id="slope_piecewise_linear"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.slope_piecewise_linear">[docs]</a><span class="k">def</span> <span class="nf">slope_piecewise_linear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">slopes</span><span class="p">,</span> <span class="n">refX</span><span class="p">,</span> <span class="n">refY</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates piecewise-linear function given by set of breaking points and slopes.</span>

<span class="sd">    This function evaluates piecewise-linear function at a point *x*.</span>
<span class="sd">    The function consists of several segments separated by *points*, within each segment the function is linear.</span>
<span class="sd">    The function is defined by slopes of all segments (*slopes*) and by breaking points (*points*) on x-axis.</span>
<span class="sd">    Furthermore it is necessary to specify reference value *refX* and corresponding function value *refY*.</span>

<span class="sd">    The function is continuous unless some value in *points* is specified twice.</span>
<span class="sd">    Specifying the same value in *points* allows to model discontinuous function,</span>
<span class="sd">    in this case the corresponding value in *slopes* is not interpreted as a slope but as the height of the jump (delta)</span>
<span class="sd">    at that point.</span>

<span class="sd">    Assuming that the array *points* has size *n*, the function consists of the following linear segments:</span>

<span class="sd">     * the segment 0 is defined on interval (-infinity, *points*[0]) and has a *slope*[0].</span>
<span class="sd">     * the segment i, i in 1, 2, .., n-1, is defined on the interval [*points*[i-1], *points*[i]) with a slope *slope*[i].</span>
<span class="sd">     * the segment n is defined on the interval [*points*[n-1], infinity) with a slope *slope*[n].</span>

<span class="sd">    Args:</span>
<span class="sd">        x:      x-value for which the function should be evaluated.</span>
<span class="sd">        points: sorted array of n-1 x-values (breaking points) that separate n function segments.</span>
<span class="sd">        slopes: array of n slopes, one for each segments.</span>
<span class="sd">        refX:   reference x-value.</span>
<span class="sd">        refY:   value of the function at refX(reference y-value).</span>
<span class="sd">    Returns:</span>
<span class="sd">        Value of the function at point x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_slope_piecewise_linear</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span>
                           <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>      <span class="s2">&quot;x&quot;</span><span class="p">,</span>      <span class="n">Type_FloatExpr</span><span class="p">),</span>
                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="n">Type_FloatArray</span><span class="p">),</span>
                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">slopes</span><span class="p">,</span> <span class="s2">&quot;slopes&quot;</span><span class="p">,</span> <span class="n">Type_FloatArray</span><span class="p">),</span>
                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">refX</span><span class="p">,</span>   <span class="s2">&quot;refX&quot;</span><span class="p">,</span>   <span class="n">Type_FloatExpr</span><span class="p">),</span>
                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">refY</span><span class="p">,</span>   <span class="s2">&quot;refY&quot;</span><span class="p">,</span>   <span class="n">Type_FloatExpr</span><span class="p">),</span>
                            <span class="p">))</span></div>


<div class="viewcode-block" id="coordinate_piecewise_linear"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.coordinate_piecewise_linear">[docs]</a><span class="k">def</span> <span class="nf">coordinate_piecewise_linear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">firstSlope</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">lastSlope</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates piecewise-linear function given by set of breaking points and values.</span>

<span class="sd">    This function evaluates piecewise-linear function at point *x*.</span>
<span class="sd">    The function consists of several segments separated by *points*, within each segment the function is linear.</span>
<span class="sd">    The function is defined by slope of the first segment (*firstSlope*), an array of breaking points (*points*)</span>
<span class="sd">    on x-axis, an array of corresponding values on y-axis (*values*) and the slope of the last segment.</span>
<span class="sd">    In each segment the function is linear.</span>
<span class="sd">    The function may be discontinuous, in this case it is necessary to specify the point of discontinuity</span>
<span class="sd">    twice in *points*.</span>

<span class="sd">    Assuming that the common length of arrays *points* and *values* is *n*, the function consists of the</span>
<span class="sd">    following linear segments:</span>

<span class="sd">     * the segment 0 is defined on interval (-infinity, *points*[0]) and is a linear function with slope *firstSlope*</span>
<span class="sd">       ending at (*points*[0], *values*[0]).</span>
<span class="sd">     * the segment i, i in 1, 2, .., n-1, is defined on the interval [*points*[i-1], *points*[i]) and is a</span>
<span class="sd">       linear function from (*points*[-1], *values*[i-1]) to (*points*[i], *values*[i]).</span>
<span class="sd">     * the segment n is defined on the interval [*points*[n-1], infinity) and is a linear function</span>
<span class="sd">       from (*points*[n-1], *values*[n-1]) with slope *lastSlope*.</span>

<span class="sd">    Args:</span>
<span class="sd">        x :         x-value for which the function should be evaluated.</span>
<span class="sd">        firstSlope: slope of the first function segment (ending at (points[0], values[0])).</span>
<span class="sd">        points:     sorted array of x-values that separate function segments (breaking points).</span>
<span class="sd">        values:     y-values corresponding to the breaking points (the array must have the same length as points).</span>
<span class="sd">        lastSlope:  slope of the last segment beginning at (points[n-1], values[n-1])</span>
<span class="sd">                    where n is length of points and  values.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Value of the function at point x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_coordinate_piecewise_linear</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span>
                           <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>          <span class="s2">&quot;x&quot;</span><span class="p">,</span>          <span class="n">Type_FloatExpr</span><span class="p">),</span>
                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">firstSlope</span><span class="p">,</span> <span class="s2">&quot;firstSlope&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">),</span>
                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">points</span><span class="p">,</span>     <span class="s2">&quot;points&quot;</span><span class="p">,</span>     <span class="n">Type_FloatArray</span><span class="p">),</span>
                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>     <span class="s2">&quot;values&quot;</span><span class="p">,</span>     <span class="n">Type_FloatArray</span><span class="p">),</span>
                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">lastSlope</span><span class="p">,</span>  <span class="s2">&quot;lastSlope&quot;</span><span class="p">,</span>  <span class="n">Type_Float</span><span class="p">),</span>
                            <span class="p">))</span></div>


<span class="c1">#==============================================================================</span>
<span class="c1">#  Objective functions</span>
<span class="c1">#==============================================================================</span>

<div class="viewcode-block" id="maximize"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.maximize">[docs]</a><span class="k">def</span> <span class="nf">maximize</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function asks CP Optimizer to seek to maximize the value of an expressions.</span>

<span class="sd">    The function *maximize* specifies to CP Optimizer a floating-point expression</span>
<span class="sd">    whose value is sought to be maximized.</span>
<span class="sd">    When this function is used and the problem is feasible, CP Optimizer will generate</span>
<span class="sd">    one or more feasible solutions to the problem, with subsequent solutions having</span>
<span class="sd">    a larger value of *expr* than preceding ones.</span>
<span class="sd">    The search terminates when either the optimality of the last solution is proved,</span>
<span class="sd">    a search limit is exhausted, or the search is aborted.</span>

<span class="sd">    Args:</span>
<span class="sd">        expr: The float expression to be maximized.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An objective expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_maximize</span><span class="p">,</span> <span class="n">Type_Objective</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s2">&quot;exprs&quot;</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">),</span> <span class="p">))</span></div>


<div class="viewcode-block" id="maximize_static_lex"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.maximize_static_lex">[docs]</a><span class="k">def</span> <span class="nf">maximize_static_lex</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A function to specify an optimization problem.  It asks CP Optimizer to</span>
<span class="sd">    seek to lexicographically maximize the values of a number of expressions.</span>

<span class="sd">    The function *maximize_static_lex* specifies to CP Optimizer a number of</span>
<span class="sd">    floating-point expressions whose values are sought to be maximized in a</span>
<span class="sd">    lexicographic fashion.  When this function is used and</span>
<span class="sd">    the problem is feasible, CP Optimizer will generate one or more</span>
<span class="sd">    feasible solutions to the problem, with subsequent solutions having</span>
<span class="sd">    a lexicographically larger value of *exprs* than preceding ones.</span>
<span class="sd">    This means that a new solution replaces the preceding one as incumbent if</span>
<span class="sd">    the value of criterion *exprs[i]* is greater than in the preceding solution,</span>
<span class="sd">    so long as the values of criteria *exprs[0..i-1]* are not less than in the</span>
<span class="sd">    preceding solution.  In particular, this means that the newer solution is</span>
<span class="sd">    preferable even if there are arbitrary reductions in the values of criteria</span>
<span class="sd">    after position *i* in *exprs*, as compared with the preceding solution.</span>
<span class="sd">    The search terminates when either the optimality of the last solution</span>
<span class="sd">    is proved, a search limit is exhausted, or the search is aborted.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs: An array of floating-point expressions whose values are to be lexicographically maximized.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression of type objective</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_maximize_static_lex</span><span class="p">,</span> <span class="n">Type_Objective</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="s2">&quot;exprs&quot;</span><span class="p">,</span> <span class="n">Type_FloatExprArray</span><span class="p">),</span> <span class="p">))</span></div>



<div class="viewcode-block" id="minimize"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.minimize">[docs]</a><span class="k">def</span> <span class="nf">minimize</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function asks CP Optimizer to seek to minimize the value of an expressions.</span>

<span class="sd">    The function *minimize* specifies to CP Optimizer a floating-point expression</span>
<span class="sd">    whose value is sought to be minimized.</span>
<span class="sd">    When this function is used and the problem is feasible, CP Optimizer will generate</span>
<span class="sd">    one or more feasible solutions to the problem, with subsequent solutions having</span>
<span class="sd">    a smaller value of *expr* than preceding ones.</span>
<span class="sd">    The search terminates when either the optimality of the last solution is proved,</span>
<span class="sd">    a search limit is exhausted, or the search is aborted.</span>

<span class="sd">    Args:</span>
<span class="sd">        expr: The float expression to be minimized.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An objective expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_minimize</span><span class="p">,</span> <span class="n">Type_Objective</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s2">&quot;exprs&quot;</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">),</span> <span class="p">))</span></div>


<div class="viewcode-block" id="minimize_static_lex"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.minimize_static_lex">[docs]</a><span class="k">def</span> <span class="nf">minimize_static_lex</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A function to specify an optimization problem.  It asks CP Optimizer to</span>
<span class="sd">    seek to lexicographically minimize the values of a number of expressions.</span>

<span class="sd">    The function *minimize_static_lex* specifies to CP Optimizer a number of</span>
<span class="sd">    floating-point expressions whose values are sought to be minimized in a</span>
<span class="sd">    lexicographic fashion.  When this function is used and</span>
<span class="sd">    the problem is feasible, CP Optimizer will generate</span>
<span class="sd">    one or more feasible solutions to the problem, with subsequent solutions having</span>
<span class="sd">    a lexicographically smaller value of *exprs* than preceding ones.</span>
<span class="sd">    This means that a new solution replaces the preceding one as incumbent if</span>
<span class="sd">    the value of criterion *exprs[i]* is less than in the preceding solution,</span>
<span class="sd">    so long as the values of criteria *exprs[0..i-1]* are not greater than in the</span>
<span class="sd">    preceding solution.  In particular, this means that the newer solution is</span>
<span class="sd">    preferable even if there are arbitrary increases in the values of criteria</span>
<span class="sd">    after position *i* in *exprs*, as compared with the preceding solution.</span>
<span class="sd">    The search terminates when either the optimality of the last solution</span>
<span class="sd">    is proved, a search limit is exhausted, or the search is aborted.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs: An array of floating-point expressions whose values are to be lexicographically minimized.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An objective expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_minimize_static_lex</span><span class="p">,</span> <span class="n">Type_Objective</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="s2">&quot;exprs&quot;</span><span class="p">,</span> <span class="n">Type_FloatExprArray</span><span class="p">),</span> <span class="p">))</span></div>


<span class="c1">#==============================================================================</span>
<span class="c1">#  Interval variables expressions</span>
<span class="c1">#==============================================================================</span>

<div class="viewcode-block" id="start_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_of">[docs]</a><span class="k">def</span> <span class="nf">start_of</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the start of a specified interval variable.</span>

<span class="sd">    This function returns an integer expression that is equal to start of the interval</span>
<span class="sd">    variable *interval* if it is present. If it is absent, then the value of the</span>
<span class="sd">    expression is *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        absentValue (Optional): Value to return if the interval variable interval becomes absent.</span>
<span class="sd">                      Zero if not given.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_of</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_of</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span></div>


<div class="viewcode-block" id="end_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_of">[docs]</a><span class="k">def</span> <span class="nf">end_of</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the end of specified interval variable.</span>

<span class="sd">    This function returns an integer expression that is equal to end of the interval</span>
<span class="sd">    variable *interval* if it is present. If it is absent then the value of the</span>
<span class="sd">    expression is *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        absentValue (Optional): Value to return if the interval variable interval becomes absent.</span>
<span class="sd">                      Zero if not given.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_of</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_of</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span></div>


<div class="viewcode-block" id="length_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.length_of">[docs]</a><span class="k">def</span> <span class="nf">length_of</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the length of specified interval variable.</span>

<span class="sd">    This function returns an integer expression that is equal to the length (*end -</span>
<span class="sd">    start*) of the interval variable *interval* if it is present. If it is absent, then</span>
<span class="sd">    the value of the expression is *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        absentValue (Optional): Value to return if the interval variable interval becomes absent.</span>
<span class="sd">                     Zero if not given.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_length_of</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_length_of</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span></div>


<div class="viewcode-block" id="size_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.size_of">[docs]</a><span class="k">def</span> <span class="nf">size_of</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the size of a specified interval variable.</span>

<span class="sd">    This function returns an integer expression that is equal to size of the interval</span>
<span class="sd">    variable *interval* if it is present. If it is absent then the value of the</span>
<span class="sd">    expression is *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        absentValue (Optional): Value to return if the interval variable interval becomes absent.</span>
<span class="sd">                     Zero if not given.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_size_of</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,))</span>

    <span class="n">absentValue</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_size_of</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">))</span></div>


<div class="viewcode-block" id="presence_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.presence_of">[docs]</a><span class="k">def</span> <span class="nf">presence_of</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the presence status of an interval variable.</span>

<span class="sd">    This function returns a boolean expression that represents the presence status of an interval variable.</span>
<span class="sd">    If *interval* is present then the value of the expression is 1; if *interval* is absent then the value is 0.</span>

<span class="sd">    Use *presence_of* to express logical relationships between interval variables.</span>
<span class="sd">    Note that the most effective are binary relations such as *presence_of(x)=&gt;presence_of(y)* because CP Optimizer</span>
<span class="sd">    is able to take them into account during propagation of other constraints such as *end_before_start* or *no_overlap*.</span>

<span class="sd">    The function *presence_of* can be also used to compute cost associated with</span>
<span class="sd">    execution/non-execution of an interval.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_presence_of</span><span class="p">,</span> <span class="n">Type_BoolExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),))</span></div>


<div class="viewcode-block" id="start_at_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_at_start">[docs]</a><span class="k">def</span> <span class="nf">start_at_start</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the delay between the starts of two interval variables.</span>

<span class="sd">    The function *start_at_start* constrains interval variables *a* and *b* in the following way.</span>
<span class="sd">    If both intervals *a* and *b* are present, then interval *b* must start exactly at *start_of(a) + delay*.</span>
<span class="sd">    If *a* or *b* is absent then the constraint is automatically satisfied.</span>

<span class="sd">    The default value for *delay* is zero. Note that *delay* can be negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: First interval variables.</span>
<span class="sd">        b: Second interval variables.</span>
<span class="sd">        delay: Exact delay between starts of *a* and *b*. If not specified then zero is used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_at_start</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_at_start</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="start_at_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_at_end">[docs]</a><span class="k">def</span> <span class="nf">start_at_end</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the delay between the start of one interval variable and end of another one.</span>

<span class="sd">    The function *start_at_end* constrains interval variables *a* and *b* in the following way.</span>
<span class="sd">    If both intervals *a* and *b* are present then interval *b* must end exactly at *start_of(a) + delay*.</span>
<span class="sd">    If *a* or *b* is absent then the constraint is automatically satisfied.</span>

<span class="sd">    The default value for *delay* is zero. Note that *delay* can be negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: First interval variables.</span>
<span class="sd">        b: Second interval variables.</span>
<span class="sd">        delay: Exact delay between start of *a* and end of *b*. If not specified then zero is used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_at_end</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_at_end</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="start_before_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_before_start">[docs]</a><span class="k">def</span> <span class="nf">start_before_start</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the minimum delay between starts of two interval variables.</span>

<span class="sd">    The function *start_before_start* constrains interval variables *a* and *b* in the following way.</span>
<span class="sd">    If both interval variables *a* and *b* are present, then *b* cannot start before *start_of(a) + delay*.</span>
<span class="sd">    If *a* or *b* is absent then the constraint is automatically satisfied.</span>

<span class="sd">    The default value for *delay* is zero.</span>
<span class="sd">    It is possible to specify even negative *delay*, in this case *b* can actually start before the start</span>
<span class="sd">    of *a* but still not sooner than *start_of(a) + delay*.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Interval variable which starts before.</span>
<span class="sd">        b: Interval variable which starts after.</span>
<span class="sd">        delay: The minimal delay between start of a and start of b. If not specified then zero is used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_before_start</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_before_start</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="start_before_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_before_end">[docs]</a><span class="k">def</span> <span class="nf">start_before_end</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains minimum delay between the start of one interval variable and end of another one.</span>

<span class="sd">    The function *start_before_end* constrains interval variables *a* and *b* in the following way.</span>
<span class="sd">    If both interval variables *a* and *b* are present, then *b* cannot end before *start_of(a) + delay*.</span>
<span class="sd">    If *a* or *b* is absent then the constraint is automatically satisfied.</span>

<span class="sd">    The default value for *delay* is zero.</span>
<span class="sd">    It is possible to specify a negative *delay*; in this case *b* can actually end before the start</span>
<span class="sd">    of *a* but still not sooner than *start_of(a) + delay*.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Interval variable which starts before.</span>
<span class="sd">        b: Interval variable which ends after.</span>
<span class="sd">        delay: The minimal delay between start of *a* and end of *b*. If not specified then zero is used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_before_end</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_before_end</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="end_at_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_at_start">[docs]</a><span class="k">def</span> <span class="nf">end_at_start</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the delay between the end of one interval variable and start of another one.</span>

<span class="sd">    The function *end_at_start* constrains interval variables *a* and *b* in the following way.</span>
<span class="sd">    If both intervals *a* and *b* are present, then interval *b* must start exactly at *end_of(a) + delay*.</span>
<span class="sd">    If *a* or *b* is absent then the constraint is automatically satisfied.</span>

<span class="sd">    The default value for *delay* is zero. Note that *delay* can be negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Interval variables.</span>
<span class="sd">        b: Interval variables.</span>
<span class="sd">        delay: Exact delay between end of *a* and start of *b*. If not specified then zero is used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_at_start</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_at_start</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="end_at_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_at_end">[docs]</a><span class="k">def</span> <span class="nf">end_at_end</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the delay between the ends of two interval variables.</span>

<span class="sd">    The function *end_at_end* constrains interval variables *a* and *b* in the following way.</span>
<span class="sd">    If both intervals *a* and *b* are present then interval *b* must end exactly at *end_of(a) + delay*.</span>
<span class="sd">    If *a* or *b* is absent then the constraint is automatically satisfied.</span>

<span class="sd">    The default value for *delay* is zero. Note that *delay* can be negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Interval variable.</span>
<span class="sd">        b: Interval variable.</span>
<span class="sd">        delay: Exact delay between ends of *a* and *b*. If not specified then zero is used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_at_end</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_at_end</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="end_before_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_before_start">[docs]</a><span class="k">def</span> <span class="nf">end_before_start</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains minimum delay between the end of one interval variable and start of another one.</span>

<span class="sd">    The function *end_before_start* constrains interval variables *a* and *b* in the following way.</span>
<span class="sd">    If both interval variables *a* and *b* are present, then *b* cannot start before *end_of(a) + delay*.</span>
<span class="sd">    If *a* or *b* is absent then the constraint is automatically satisfied.</span>

<span class="sd">    The default value for *delay* is zero.</span>
<span class="sd">    It is possible to specify even negative *delay*, in this case *b* can actually start before the end</span>
<span class="sd">    of *a* but still not sooner than *end_of(a) + delay*.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Interval variable which ends before.</span>
<span class="sd">        b: Interval variable which starts after.</span>
<span class="sd">        delay: The minimal delay between end of a and start of b. If not specified then zero is used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_before_start</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_before_start</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="end_before_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_before_end">[docs]</a><span class="k">def</span> <span class="nf">end_before_end</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the minimum delay between the ends of two interval variables.</span>

<span class="sd">    The function *end_before_end* constrains interval variables *a* and *b* in the following way.</span>
<span class="sd">    If both interval variables *a* and *b* are present, then *b* cannot end before *end_of(a) + delay*.</span>
<span class="sd">    If *a* or *b* is absent then the constraint is automatically satisfied.</span>

<span class="sd">    The default value for *delay* is zero.</span>
<span class="sd">    It is possible to specify a negative *delay*; in this case *b* can actually end before the end</span>
<span class="sd">    of *a* but still not sooner than *end_of(a) + delay*.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Interval variable which ends before.</span>
<span class="sd">        b: Interval variable which ends after.</span>
<span class="sd">        delay: The minimal delay between end of a and end of b. If not specified then zero is used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_before_end</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_before_end</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s2">&quot;delay&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="forbid_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.forbid_start">[docs]</a><span class="k">def</span> <span class="nf">forbid_start</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Forbids an interval variable to start during specified regions.</span>

<span class="sd">    This constraint restricts possible start times of interval variable using a step function.</span>
<span class="sd">    The interval variable can start only at points where the function value is not zero.</span>
<span class="sd">    When the interval variable is absent then this constraint is automatically satisfied,</span>
<span class="sd">    since such interval variable does not have any start at all.</span>

<span class="sd">    In declaration of an interval variable it is only possible to specify a range of possible start times.</span>
<span class="sd">    This function allows more precise specification of when the interval variable can start.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable being restricted.</span>
<span class="sd">        function: If the function has value 0 at point *t* then the interval variable interval cannot start at *t*.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_forbid_start</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                                <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_StepFunction</span><span class="p">)))</span></div>

<div class="viewcode-block" id="forbid_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.forbid_end">[docs]</a><span class="k">def</span> <span class="nf">forbid_end</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Forbids an interval variable to end during specified regions.</span>

<span class="sd">    In the declaration of an interval variable it is only possible to specify a range of possible end times.</span>
<span class="sd">    This function allows the user to specify more precisely when the interval variable can end.</span>
<span class="sd">    In particular, the interval variable can end only at point *t* such that the function has non-zero value at</span>
<span class="sd">    *t-1*.</span>
<span class="sd">    When the interval variable is absent then this constraint is automatically satisfied,</span>
<span class="sd">    since such interval variable does not&#39;t have any start at all.</span>

<span class="sd">    Note the difference between *t* (end time of the interval variable) and *t-1*</span>
<span class="sd">    (the point when the function value is checked). It simplifies the sharing of the same function</span>
<span class="sd">    in constraints *forbid_start* and *forbid_end*.</span>
<span class="sd">    It also allows one to use the same function as *intensity* parameter of interval variable.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable being restricted.</span>
<span class="sd">        function: If the function has value 0 at point *t*-1 then the interval variable interval cannot end at *t*.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_forbid_end</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                              <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_StepFunction</span><span class="p">)))</span></div>


<div class="viewcode-block" id="forbid_extent"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.forbid_extent">[docs]</a><span class="k">def</span> <span class="nf">forbid_extent</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Forbids an interval variable to overlap with specified regions.</span>

<span class="sd">    This function allows specification of forbidden regions that the interval variable *interval* cannot overlap with.</span>
<span class="sd">    In particular, if interval variable *interval* is present and if *function* has value 0 during</span>
<span class="sd">    interval *[a,b)* (i.e. *[a,b)* is a forbidden region) then either *end &lt;= a* (*interval* ends before the</span>
<span class="sd">    forbidden region) or *b &lt;= start* (*interval* starts after the forbidden region).</span>

<span class="sd">    If the interval variable *interval* is absent then the constraint is automatically satisfied</span>
<span class="sd">    (the interval does not exist therefore it cannot overlap with any region).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable being restricted.</span>
<span class="sd">        function: Forbidden regions corresponds to step of the function that have value 0.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_forbid_extent</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_StepFunction</span><span class="p">)))</span></div>


<div class="viewcode-block" id="overlap_length"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.overlap_length">[docs]</a><span class="k">def</span> <span class="nf">overlap_length</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">interval2</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the length of the overlap of two interval variables.</span>

<span class="sd">    This function returns an integer expression that represents the length of the overlap</span>
<span class="sd">    of interval variable *interval* and the interval variable *interval2* whenever the interval</span>
<span class="sd">    variables *interval* and *interval2* are present.</span>
<span class="sd">    When one of the interval variables *interval* or *interval2* is absent, the function returns</span>
<span class="sd">    the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Optionally, *interval2* can be a constant interval [*start*, *end*) expressed as a tuple of two</span>
<span class="sd">    integers.</span>
<span class="sd">    When the interval variable *interval* is absent, the function returns the constant integer value</span>
<span class="sd">    *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable</span>
<span class="sd">        interval2: Another interval variable, or fixed interval expressed as a tuple of 2 integers.</span>
<span class="sd">        absentValue (Optional): Value to return if some interval variable is absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>

    <span class="c1"># Interval2 is fixed</span>
    <span class="k">if</span> <span class="n">is_array</span><span class="p">(</span><span class="n">interval2</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">interval2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_int</span><span class="p">(</span><span class="n">interval2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">is_int</span><span class="p">(</span><span class="n">interval2</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> \
            <span class="s2">&quot;To express a fixed interval, &#39;interval2&#39; should be a tuple of two integers&quot;</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;interval2[0]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">)</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;interval2[1]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_overlap_length</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_overlap_length</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span>
                                                                   <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span>

    <span class="c1"># Interval2 is an interval variable</span>
    <span class="n">interval2</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval2</span><span class="p">,</span> <span class="s2">&quot;interval2&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_overlap_length</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">interval2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_overlap_length</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">interval2</span><span class="p">,</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span></div>


<div class="viewcode-block" id="start_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_eval">[docs]</a><span class="k">def</span> <span class="nf">start_eval</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates a segmented function at the start of an interval variable.</span>

<span class="sd">    Evaluates *function* at the start of interval variable *interval*.</span>
<span class="sd">    If *interval* is absent, it does not have any defined start and *absentValue* is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        function: Function to evaluate.</span>
<span class="sd">        absentValue (Optional): Value to return if interval variable interval is absent.</span>
<span class="sd">                     If not given, absent value is zero.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_SegmentedFunction</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_eval</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_start_eval</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span></div>


<div class="viewcode-block" id="end_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_eval">[docs]</a><span class="k">def</span> <span class="nf">end_eval</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates a segmented function at the end of an interval variable.</span>

<span class="sd">    Evaluates *function* at the start of interval variable *interval*.</span>
<span class="sd">    If *interval* is absent, it does not have any defined end and *absentValue* is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        function: Function to evaluate.</span>
<span class="sd">        absentValue (Optional): Value to return if interval variable interval is absent.</span>
<span class="sd">                     If not given, absent value is zero.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_SegmentedFunction</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_eval</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_end_eval</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span></div>


<div class="viewcode-block" id="size_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.size_eval">[docs]</a><span class="k">def</span> <span class="nf">size_eval</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates a segmented function on the size of an interval variable.</span>

<span class="sd">    Evaluate *function* for the x value equal to the size of interval variable *interval*.</span>
<span class="sd">    If *interval* is absent then it does not have any defined size and *absentValue* is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        function: Function to evaluate.</span>
<span class="sd">        absentValue (Optional): Value to return if interval variable interval is absent.</span>
<span class="sd">                     If not given, absent value is zero.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_SegmentedFunction</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_size_eval</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_size_eval</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span></div>


<div class="viewcode-block" id="length_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.length_eval">[docs]</a><span class="k">def</span> <span class="nf">length_eval</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates segmented function on the length of an interval variable.</span>

<span class="sd">    Evaluate *function* for the x value equal to the length of interval variable *interval*.</span>
<span class="sd">    If *interval* is absent then it does not have any defined length and *absentValue* is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        function: Function to evaluate.</span>
<span class="sd">        absentValue (Optional): Value to return if interval variable interval is absent.</span>
<span class="sd">                     If not given, absent value is zero.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_SegmentedFunction</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_length_eval</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_length_eval</span><span class="p">,</span> <span class="n">Type_FloatExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span></div>


<div class="viewcode-block" id="span"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.span">[docs]</a><span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a span constraint between interval variables.</span>

<span class="sd">    This function creates a span constraint between an interval variable *interval*</span>
<span class="sd">    and a set of interval variables in *array*. This constraint states that</span>
<span class="sd">    *interval* when it is present spans over all present intervals from the</span>
<span class="sd">    *array*. That is: *interval* starts together with the first present</span>
<span class="sd">    interval from *array* and ends together with the last one. Interval *interval*</span>
<span class="sd">    is absent if and only if all intervals in *array* are absent.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Spanning interval variable.</span>
<span class="sd">        array: Array of spanned interval variables.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_span</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                        <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVarArray</span><span class="p">)))</span></div>


<div class="viewcode-block" id="alternative"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.alternative">[docs]</a><span class="k">def</span> <span class="nf">alternative</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">cardinality</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an alternative constraint between interval variables.</span>

<span class="sd">    This function creates an alternative constraint between interval variable</span>
<span class="sd">    *interval* and the set of interval variables in *array*.</span>
<span class="sd">    If no *cardinality* expression is specified, if *interval* is present, then one and only</span>
<span class="sd">    one of the intervals in *array* will be selected by the alternative constraint</span>
<span class="sd">    to be present, and the start and end values of *interval* will be the same as the</span>
<span class="sd">    ones of the selected interval.</span>
<span class="sd">    If a *cardinality* expression is specified, *cardinality* intervals in *array* will be selected by the</span>
<span class="sd">    alternative constraint to be present and the selected intervals will have the</span>
<span class="sd">    same start and end value as interval variable *interval*.</span>
<span class="sd">    Interval variable *interval* is absent if and only if all interval variables in *array* are absent.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval:    Interval variable.</span>
<span class="sd">        array:       Array of interval variables.</span>
<span class="sd">        cardinality (Optional): Cardinality of the alternative constraint.</span>
<span class="sd">                     By default, when this optional argument is not specified, a unit cardinality is assumed (cardinality=1).</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cardinality</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
       <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_alternative</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                                  <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVarArray</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_alternative</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVarArray</span><span class="p">),</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="n">cardinality</span><span class="p">,</span> <span class="s2">&quot;cardinality&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>


<div class="viewcode-block" id="synchronize"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.synchronize">[docs]</a><span class="k">def</span> <span class="nf">synchronize</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a synchronization constraint between interval variables.</span>

<span class="sd">    This function creates a synchronization constraint between an interval variable *interval*</span>
<span class="sd">    and a set of interval variables in *array*.</span>
<span class="sd">    This constraint makes all present intervals in *array* start and end together with *interval*,</span>
<span class="sd">    if it is present.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        array:    Array of interval variables synchronized with interval.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_synchronize</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVarArray</span><span class="p">)))</span></div>


<div class="viewcode-block" id="isomorphism"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.isomorphism">[docs]</a><span class="k">def</span> <span class="nf">isomorphism</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an isomorphism constraint between two sets of interval variables.</span>

<span class="sd">    This function creates an isomorphism constraint between the set of interval variables</span>
<span class="sd">    in the array *array1* and the set of interval variables in the array *array2*.</span>
<span class="sd">    If an integer expression array *map* is used, it is used to reflect the mapping of the intervals</span>
<span class="sd">    of *array1* on the intervals of *array2*, that is, interval variable *array2[i]*, if present,</span>
<span class="sd">    is mapped on interval variable *array1[map[i]]**.</span>
<span class="sd">    If *array2[i]* is absent, index *map[i]* takes value *absentValue*.</span>

<span class="sd">    Args:</span>
<span class="sd">        array1: The first array of interval variables.</span>
<span class="sd">        array2: The second array of interval variables.</span>
<span class="sd">        map:    (Optional) Array of integer expressions mapping intervals of array2 on array1.</span>
<span class="sd">        absentValue (Optional): Integer value of map[i] when array2[i] is absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of interval variables, array of interval variables, array of integer expressions [=None], integer constant [=None]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array1</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="s2">&quot;array1&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVarArray</span><span class="p">)</span>
    <span class="n">array2</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array2</span><span class="p">,</span> <span class="s2">&quot;array2&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVarArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_isomorphism</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_isomorphism</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_isomorphism</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">,</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="n">Type_IntExprArray</span><span class="p">),</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span></div>


<span class="c1">#==============================================================================</span>
<span class="c1">#  Sequence variables expressions</span>
<span class="c1">#==============================================================================</span>


<div class="viewcode-block" id="first"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.first">[docs]</a><span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains an interval variable to be the first in a sequence.</span>

<span class="sd">    This function returns a constraint that states that whenever interval variable *interval* is present,</span>
<span class="sd">    it must be ordered first in the sequence variable *sequence*.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_first</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="s2">&quot;sequence&quot;</span><span class="p">,</span> <span class="n">Type_SequenceVar</span><span class="p">),</span>
                                                         <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)))</span></div>


<div class="viewcode-block" id="last"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.last">[docs]</a><span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains an interval variable to be the last in a sequence.</span>

<span class="sd">    This function returns a constraint that states that whenever interval variable *interval* is present,</span>
<span class="sd">    it must be ordered last in the sequence variable *sequence*.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_last</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="s2">&quot;sequence&quot;</span><span class="p">,</span> <span class="n">Type_SequenceVar</span><span class="p">),</span>
                                                        <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)))</span></div>


<div class="viewcode-block" id="before"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.before">[docs]</a><span class="k">def</span> <span class="nf">before</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval1</span><span class="p">,</span> <span class="n">interval2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains an interval variable to be before another interval variable in a sequence.</span>

<span class="sd">    This function returns a constraint that states that whenever both interval variables</span>
<span class="sd">    *interval1* and *interval2* are present,</span>
<span class="sd">    *interval1* must be ordered before *interval2* in the sequence variable *sequence*.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence:  Sequence variable.</span>
<span class="sd">        interval1: First interval variables.</span>
<span class="sd">        interval2: Second interval variables.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_before</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="s2">&quot;sequence&quot;</span><span class="p">,</span> <span class="n">Type_SequenceVar</span><span class="p">),</span>
                                                          <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval1</span><span class="p">,</span> <span class="s2">&quot;interval1&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                          <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval2</span><span class="p">,</span> <span class="s2">&quot;interval2&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)))</span></div>


<div class="viewcode-block" id="previous"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.previous">[docs]</a><span class="k">def</span> <span class="nf">previous</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval1</span><span class="p">,</span> <span class="n">interval2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains an interval variable to be previous to another interval variable in a sequence.</span>

<span class="sd">    This function returns a constraint that states that whenever both interval variables *interval1* and *interval2*</span>
<span class="sd">    are present, *interval1* must be the interval variable that is previous to *interval2* in the</span>
<span class="sd">    sequence variable *sequence*.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval1: Interval variable.</span>
<span class="sd">        interval2: Interval variable.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_previous</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="s2">&quot;sequence&quot;</span><span class="p">,</span> <span class="n">Type_SequenceVar</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval1</span><span class="p">,</span> <span class="s2">&quot;interval1&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval2</span><span class="p">,</span> <span class="s2">&quot;interval2&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)))</span></div>


<span class="k">def</span> <span class="nf">_sequence_operation</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">islast</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the start of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the start of the interval variable</span>
<span class="sd">    that is next to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        oper:        Operation descriptor</span>
<span class="sd">        sequence:    Sequence variable.</span>
<span class="sd">        interval:    Interval variable.</span>
<span class="sd">        value:       Value to return if interval variable interval is the last or first one in sequence.</span>
<span class="sd">        islast:      Indicates if value concerns interval variable last or first in the sequence</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="s2">&quot;sequence&quot;</span><span class="p">,</span> <span class="n">Type_SequenceVar</span><span class="p">)</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval1&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="n">vname</span> <span class="o">=</span> <span class="s2">&quot;lastValue&quot;</span> <span class="k">if</span> <span class="n">islast</span> <span class="k">else</span> <span class="s2">&quot;firstValue&quot;</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">vname</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">oper</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span>
                                                <span class="n">_convert_arg</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">vname</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">),</span>
                                                <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span>


<div class="viewcode-block" id="start_of_next"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_of_next">[docs]</a><span class="k">def</span> <span class="nf">start_of_next</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">lastValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the start of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the start of the interval variable</span>
<span class="sd">    that is next to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        lastValue: (Optional) Value to return if interval variable interval is the last one in sequence.</span>
<span class="sd">        absentValue (Optional): Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_sequence_operation</span><span class="p">(</span><span class="n">Oper_start_of_next</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">lastValue</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">)</span></div>


<div class="viewcode-block" id="start_of_prev"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_of_prev">[docs]</a><span class="k">def</span> <span class="nf">start_of_prev</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">firstValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the start of the interval variable that is previous.</span>

<span class="sd">    This function returns an integer expression that represents the start of the interval variable</span>
<span class="sd">    that is previous to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the first interval of *sequence*, it returns the constant integer value *firstValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        firstValue: (Optional) Value to return if interval variable interval is the first one in sequence.</span>
<span class="sd">        absentValue (Optional): Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_sequence_operation</span><span class="p">(</span><span class="n">Oper_start_of_prev</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">firstValue</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">)</span></div>


<div class="viewcode-block" id="end_of_next"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_of_next">[docs]</a><span class="k">def</span> <span class="nf">end_of_next</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">lastValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the end of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the end of the interval variable</span>
<span class="sd">    that is next to *interval* in *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        lastValue: Value to return if interval variable interval is the last one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_sequence_operation</span><span class="p">(</span><span class="n">Oper_end_of_next</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">lastValue</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">)</span></div>


<div class="viewcode-block" id="end_of_prev"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_of_prev">[docs]</a><span class="k">def</span> <span class="nf">end_of_prev</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">firstValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the end of the interval variable that is previous.</span>

<span class="sd">    This function returns an integer expression that represents the end of the interval variable</span>
<span class="sd">    that is previous to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the first interval of *sequence*, it returns the constant integer value *firstValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        firstValue: Value to return if interval variable interval is the first one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_sequence_operation</span><span class="p">(</span><span class="n">Oper_end_of_prev</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">firstValue</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">)</span></div>


<div class="viewcode-block" id="length_of_next"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.length_of_next">[docs]</a><span class="k">def</span> <span class="nf">length_of_next</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">lastValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the length of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the length of the interval variable</span>
<span class="sd">    that is next to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        lastValue: Value to return if interval variable interval is the last one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_sequence_operation</span><span class="p">(</span><span class="n">Oper_length_of_next</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">lastValue</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">)</span></div>


<div class="viewcode-block" id="length_of_prev"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.length_of_prev">[docs]</a><span class="k">def</span> <span class="nf">length_of_prev</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">firstValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the length of the interval variable that is previous.</span>

<span class="sd">    This function returns an integer expression that represents the length of the interval variable</span>
<span class="sd">    that is previous to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the first interval of *sequence*, it returns the constant integer value *firstValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        firstValue: Value to return if interval variable interval is the first one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_sequence_operation</span><span class="p">(</span><span class="n">Oper_length_of_prev</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">firstValue</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">)</span></div>


<div class="viewcode-block" id="size_of_next"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.size_of_next">[docs]</a><span class="k">def</span> <span class="nf">size_of_next</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">lastValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the size of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the size of the interval variable</span>
<span class="sd">    that is next to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        lastValue: Value to return if interval variable interval is the last one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_sequence_operation</span><span class="p">(</span><span class="n">Oper_size_of_next</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">lastValue</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">)</span></div>


<div class="viewcode-block" id="size_of_prev"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.size_of_prev">[docs]</a><span class="k">def</span> <span class="nf">size_of_prev</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">firstValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the size of the interval variable that is previous.</span>

<span class="sd">    This function returns an integer expression that represents the size of the interval variable</span>
<span class="sd">    that is previous to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the first interval of *sequence*, it returns the constant integer value *firstValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        firstValue: Value to return if interval variable interval is the first one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_sequence_operation</span><span class="p">(</span><span class="n">Oper_size_of_prev</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">firstValue</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">)</span></div>


<div class="viewcode-block" id="type_of_next"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.type_of_next">[docs]</a><span class="k">def</span> <span class="nf">type_of_next</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">lastValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the type of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the type of the interval variable</span>
<span class="sd">    that is next to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        lastValue: Value to return if interval variable interval is the last one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_sequence_operation</span><span class="p">(</span><span class="n">Oper_type_of_next</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">lastValue</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">)</span></div>


<div class="viewcode-block" id="type_of_prev"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.type_of_prev">[docs]</a><span class="k">def</span> <span class="nf">type_of_prev</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">firstValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the type of the interval variable that is previous.</span>

<span class="sd">    This function returns an integer expression that represents the type of the interval variable</span>
<span class="sd">    that is previous to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the first interval of *sequence*, it returns the constant integer value *firstValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        firstValue: Value to return if interval variable interval is the first one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_sequence_operation</span><span class="p">(</span><span class="n">Oper_type_of_prev</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">firstValue</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">absentValue</span><span class="p">)</span></div>


<div class="viewcode-block" id="no_overlap"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.no_overlap">[docs]</a><span class="k">def</span> <span class="nf">no_overlap</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">distance_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_direct</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains a set of interval variables not to overlap each others.</span>

<span class="sd">    This function returns a constraint over a set of interval variables {*a1*, ..., *an*} that states that</span>
<span class="sd">    all the present intervals in the set are pairwise non-overlapping.</span>
<span class="sd">    It means that whenever both interval variables *ai* and *aj*, i!=j are present, *ai* is constrained to end</span>
<span class="sd">    before the start of *aj* or *aj* is constrained to end before the start of *ai*.</span>

<span class="sd">    If the no-overlap constraint has been built on an interval sequence variable *sequence*, it means that</span>
<span class="sd">    the no-overlap constraint works on the set of interval variables {*a1*, ..., *an*} of the sequence and that</span>
<span class="sd">    the order of interval variables of the sequence will describe the order of the non-overlapping intervals.</span>
<span class="sd">    That is, if *ai* and *aj*, i!=j are both present and if *ai* appears before *aj* in the sequence value,</span>
<span class="sd">    then *ai* is constrained to end before the start of *aj*.</span>
<span class="sd">    If a transition matrix *distance_matrix* is specified and if *tpi* and *tpj* respectively denote the types of</span>
<span class="sd">    interval variables *ai* and *aj* in the *sequence*, it means that a minimal distance</span>
<span class="sd">    *distance_matrix[tpi,tpj]* is to be maintained between the end of *ai* and the start of *aj*.</span>
<span class="sd">    If boolean flag *is_direct* is True, the transition distance holds between an interval and its immediate successor</span>
<span class="sd">    in the sequence.</span>
<span class="sd">    If *is_direct* is False (default), the transition distance holds between an interval and all its successors</span>
<span class="sd">     in the sequence.</span>

<span class="sd">    If the first argument is an array of interval variables, the two others are ignored.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: A sequence variable, or an array of interval variables.</span>
<span class="sd">        distance_matrix (Optional): An optional transition matrix defining the transition distance between consecutive</span>
<span class="sd">                         interval variables.</span>
<span class="sd">                         Transition matrix is given as an iterable of iterables of positive integers,</span>
<span class="sd">                         or as the result of a call to the method :meth:`~docplex.cp.expression.transition_matrix`.</span>
<span class="sd">        is_direct (Optional): A boolean flag stating whether the distance specified in the transition matrix</span>
<span class="sd">                 *distance_matrix* holds between direct successors (is_direct=True)</span>
<span class="sd">                 or also between indirect successors (is_direct=False, default).</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if sequence is an array of interval variables</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sequence</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntervalVarArray</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">distance_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_direct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;As first argument is an array of interval variables, other arguments should be absent&quot;</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_no_overlap</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">sequence</span><span class="p">,))</span>

    <span class="c1"># Sequence is a sequence variable</span>
    <span class="k">assert</span> <span class="n">sequence</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_SequenceVar</span><span class="p">),</span> <span class="s2">&quot;First argument should be a sequence variable or an array of interval variables&quot;</span>
    <span class="k">if</span> <span class="n">distance_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">is_direct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;is_direct should not be given if no distance matrix is given&quot;</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_no_overlap</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">sequence</span><span class="p">,))</span>
    
    <span class="n">distance_matrix</span> <span class="o">=</span> <span class="n">build_cpo_transition_matrix</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_direct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_no_overlap</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">distance_matrix</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_no_overlap</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">distance_matrix</span><span class="p">,</span> <span class="n">_convert_arg_bool_int</span><span class="p">(</span><span class="n">is_direct</span><span class="p">,</span> <span class="s2">&quot;is_direct&quot;</span><span class="p">)))</span></div>
    


<div class="viewcode-block" id="same_sequence"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.same_sequence">[docs]</a><span class="k">def</span> <span class="nf">same_sequence</span><span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">,</span> <span class="n">array1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">array2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function creates a same-sequence constraint between two sequence variables.</span>

<span class="sd">    The constraint states that the two sequences *seq1* and *seq2* are identical modulo a mapping between</span>
<span class="sd">    intervals *array1[i]* and *array2[i]*.</span>

<span class="sd">    Sequence variables *seq1* and *seq2* should be of the same size *n*.</span>
<span class="sd">    If no array of interval variables is specified, the mapping between interval variables of the</span>
<span class="sd">    two sequences is given by the order of the interval variables in the arrays *array1* and *array2* used</span>
<span class="sd">    in the definition of the sequences.</span>

<span class="sd">    If interval variable arrays *array1* and *array2* are used, these arrays define the mapping</span>
<span class="sd">    between interval variables of the two sequences.</span>

<span class="sd">    Args:</span>
<span class="sd">        seq1: First constrained sequence variables.</span>
<span class="sd">        seq2: Second constrained sequence variables.</span>
<span class="sd">        array1 (Optional): First array of interval variables defining the mapping between the two sequence variables.</span>
<span class="sd">        array2 (Optional): Second array of interval variables defining the mapping between the two sequence variables.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seq1</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="s2">&quot;seq1&quot;</span><span class="p">,</span> <span class="n">Type_SequenceVar</span><span class="p">)</span>
    <span class="n">seq2</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">seq2</span><span class="p">,</span> <span class="s2">&quot;seq2&quot;</span><span class="p">,</span> <span class="n">Type_SequenceVar</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq2</span><span class="p">),</span> <span class="s2">&quot;&#39;seq1&#39; and &#39;seq2&#39; should have the same length&quot;</span>
    <span class="k">if</span> <span class="n">array1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">array2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Mapping arrays &#39;array1&#39; and &#39;array2&#39; should be both given or ignored&quot;</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_same_sequence</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_same_sequence</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">,</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="s2">&quot;array1&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVarArray</span><span class="p">),</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array2</span><span class="p">,</span> <span class="s2">&quot;array2&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVarArray</span><span class="p">)))</span></div>


<div class="viewcode-block" id="same_common_subsequence"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.same_common_subsequence">[docs]</a><span class="k">def</span> <span class="nf">same_common_subsequence</span><span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">,</span> <span class="n">array1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">array2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function creates a same-common-subsequence constraint between two sequence variables.</span>

<span class="sd">    If no interval variable array is specified as argument, the sequence variables *seq1* and *seq2*</span>
<span class="sd">    should be of the same size and the mapping between interval variables of the two sequences is</span>
<span class="sd">    given by the order of the interval variables in the arrays *array1* and *array2* used</span>
<span class="sd">    in the definition of the sequences.</span>

<span class="sd">    If interval variable arrays *array1* and *array2* are used, these arrays define the mapping</span>
<span class="sd">    between interval variables of the two sequences.</span>

<span class="sd">    The constraint states that the sub-sequences defined by *seq1* and *seq2* by only considering</span>
<span class="sd">    the pairs of present intervals (*array1[i]*, *array2[i]*) are identical modulo the mapping between</span>
<span class="sd">    intervals *array1[i]* and *array2[i]*.</span>

<span class="sd">    Args:</span>
<span class="sd">        seq1:   First constrained sequence variables.</span>
<span class="sd">        seq2:   Second constrained sequence variables.</span>
<span class="sd">        array1 (Optional): First array of interval variables defining the mapping between the two sequence variables.</span>
<span class="sd">        array2 (Optional): Second array of interval variables defining the mapping between the two sequence variables.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seq1</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="s2">&quot;seq1&quot;</span><span class="p">,</span> <span class="n">Type_SequenceVar</span><span class="p">)</span>
    <span class="n">seq2</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">seq2</span><span class="p">,</span> <span class="s2">&quot;seq2&quot;</span><span class="p">,</span> <span class="n">Type_SequenceVar</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq2</span><span class="p">),</span> <span class="s2">&quot;&#39;seq1&#39; and &#39;seq2&#39; should have the same length&quot;</span>
    <span class="k">if</span> <span class="n">array1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">array2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Mapping arrays &#39;array1&#39; and &#39;array2&#39; should be both given or ignored&quot;</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_same_common_subsequence</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_same_common_subsequence</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">,</span>
                                                                           <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="s2">&quot;array1&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVarArray</span><span class="p">),</span>
                                                                           <span class="n">_convert_arg</span><span class="p">(</span><span class="n">array2</span><span class="p">,</span> <span class="s2">&quot;array2&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVarArray</span><span class="p">)))</span></div>


<span class="c1">#==============================================================================</span>
<span class="c1">#  Cumulative expressions</span>
<span class="c1">#==============================================================================</span>

<div class="viewcode-block" id="pulse"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.pulse">[docs]</a><span class="k">def</span> <span class="nf">pulse</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">_x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an elementary cumul function of constant value between the start and the end of an interval.</span>

<span class="sd">    This function returns an elementary cumul function expression that is equal to a value *height*</span>
<span class="sd">    everywhere between the start and the end of an interval variable *interval* or a fixed interval</span>
<span class="sd">    [*start*, *end*).</span>

<span class="sd">    The function is equal to 0 outside of the interval.</span>

<span class="sd">    When interval variable `interval` is absent, the function is the constant zero function.</span>

<span class="sd">    When a range [`heightMin`, `heightMax`) is specified it means that the height value of the pulse</span>
<span class="sd">    is part of the decisions of the problem and will be fixed by the engine within this specified range.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable contributing to the cumul function,</span>
<span class="sd">                  or fixed interval expressed as a tuple of 2 integers.</span>
<span class="sd">        height:   Non-negative integer representing the height of the contribution,</span>
<span class="sd">                  or tuple of 2 non-negative integers representing the range of possible values</span>
<span class="sd">                  for the height of the contribution.</span>
<span class="sd">                  This last case is available only if interval is an interval variable.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A cumul atom expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Case of 3 arguments (backward compatibility with previous implementation)</span>
    <span class="k">if</span> <span class="n">_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Deprecated calling form, consult documentation for details&quot;</span>
        <span class="k">if</span> <span class="n">is_int</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_pulse</span><span class="p">,</span> <span class="n">Type_CumulAtom</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">,</span> <span class="n">msg</span><span class="p">),</span>
                                                                <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">,</span> <span class="n">msg</span><span class="p">),</span>
                                                                <span class="n">_convert_arg</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="s2">&quot;_x&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">,</span> <span class="n">msg</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_pulse</span><span class="p">,</span> <span class="n">Type_CumulAtom</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">,</span> <span class="n">msg</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">,</span> <span class="n">msg</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="s2">&quot;_x&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">,</span> <span class="n">msg</span><span class="p">)))</span>

    <span class="c1"># Case of fixed interval</span>
    <span class="k">if</span> <span class="n">_is_int_couple</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_pulse</span><span class="p">,</span> <span class="n">Type_CumulAtom</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;interval[0]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;interval[1]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">)))</span>

    <span class="c1"># Case of interval variable</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">,</span>
                            <span class="s2">&quot;Argument &#39;interval&#39; should be an interval variable or a fixed interval expressed as a tuple of integers&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_is_int_couple</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_pulse</span><span class="p">,</span> <span class="n">Type_CumulAtom</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;height[0]&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">),</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;height[1]&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">)))</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">,</span> <span class="s2">&quot;Argument &#39;height&#39; should be an integer or a range expressed as a tuple of integers&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_pulse</span><span class="p">,</span> <span class="n">Type_CumulAtom</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span></div>


<div class="viewcode-block" id="step_at"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.step_at">[docs]</a><span class="k">def</span> <span class="nf">step_at</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an elementary cumul function of constant value after a given point.</span>

<span class="sd">    This function returns an elementary cumul function expression that is equal to 0 before</span>
<span class="sd">    point *t* and equal to *h* after point *t*.</span>

<span class="sd">    Args:</span>
<span class="sd">        t: Integer.</span>
<span class="sd">        h: Non-negative integer representing the height of the contribution after point t.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer time, positive integer) =&gt; cumul atom</span>

<span class="sd">    Returns:</span>
<span class="sd">        A cumul atom expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_step_at</span><span class="p">,</span> <span class="n">Type_CumulAtom</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">),</span>
                                                          <span class="n">_convert_arg</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">)))</span></div>


<div class="viewcode-block" id="step_at_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.step_at_start">[docs]</a><span class="k">def</span> <span class="nf">step_at_start</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an elementary cumul function of constant value after the start of an interval.</span>

<span class="sd">    This function returns an elementary cumul function expression that,</span>
<span class="sd">    whenever interval variable *interval* is present, is equal to 0 before the start of *interval*</span>
<span class="sd">    and equal to *height* after the start of *interval*.</span>

<span class="sd">    If *height* is a range specified as a tuple of integers, it means that the height value of the function</span>
<span class="sd">    is part of the decisions of the problem and will be fixed by the engine within this specified range.</span>

<span class="sd">    When interval variable *interval* is absent, the function is the constant zero function.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable contributing to the cumul function.</span>
<span class="sd">        height:   Non-negative integer representing the height of the contribution,</span>
<span class="sd">                  or tuple of 2 non-negative integers representing the range of possible values</span>
<span class="sd">                  for the height of the contribution.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A cumul atom expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_is_int_couple</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_step_at_start</span><span class="p">,</span> <span class="n">Type_CumulAtom</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span>
                                                                    <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;height[0]&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">),</span>
                                                                    <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;height[1]&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">)))</span>

    <span class="n">height</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">,</span> <span class="s2">&quot;Argument &#39;height&#39; should be an integer or a range expressed as a tuple of integers&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_step_at_start</span><span class="p">,</span> <span class="n">Type_CumulAtom</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span><span class="n">height</span><span class="p">))</span></div>


<div class="viewcode-block" id="step_at_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.step_at_end">[docs]</a><span class="k">def</span> <span class="nf">step_at_end</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an elementary cumul function of constant value after the end of an interval.</span>

<span class="sd">    This function returns an elementary cumul function expression that,</span>
<span class="sd">    whenever interval variable *interval* is present, is equal to 0 before the start of *interval*</span>
<span class="sd">    and equal to *height* after the end of *interval*.</span>

<span class="sd">    If *height* is a range specified as a tuple of integers, it means that the height value of the function</span>
<span class="sd">    is part of the decisions of the problem and will be fixed by the engine within this specified range.</span>

<span class="sd">    When interval variable *interval* is absent, the function is the constant zero function.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable contributing to the cumul function.</span>
<span class="sd">        height:   Non-negative integer representing the height of the contribution,</span>
<span class="sd">                  or tuple of 2 non-negative integers representing the range of possible values</span>
<span class="sd">                  for the height of the contribution.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A cumul atom expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_is_int_couple</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_step_at_end</span><span class="p">,</span> <span class="n">Type_CumulAtom</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span>
                                                                  <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;height[0]&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">),</span>
                                                                  <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;height[1]&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">)))</span>

    <span class="n">height</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">,</span> <span class="s2">&quot;Argument &#39;height&#39; should be an integer or a range expressed as a tuple of integers&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_step_at_end</span><span class="p">,</span> <span class="n">Type_CumulAtom</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span><span class="n">height</span><span class="p">))</span></div>


<div class="viewcode-block" id="height_at_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.height_at_start">[docs]</a><span class="k">def</span> <span class="nf">height_at_start</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the contribution of an interval variable to a cumul function at its start point.</span>

<span class="sd">    Whenever interval variable *interval* is present, this function returns an integer expression</span>
<span class="sd">    that represents the total contribution of the start of interval variable *interval* to the cumul *function*.</span>

<span class="sd">    When interval variable *interval* is absent, this function returns a constant integer expression equal</span>
<span class="sd">    to *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval:    Interval variable.</span>
<span class="sd">        function:    Cumul function expression.</span>
<span class="sd">        absentValue (Optional): Value to return if the interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_height_at_start</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                                    <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_CumulExpr</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_height_at_start</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                                <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_CumulExpr</span><span class="p">),</span>
                                                                <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span></div>


<div class="viewcode-block" id="height_at_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.height_at_end">[docs]</a><span class="k">def</span> <span class="nf">height_at_end</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">absentValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the contribution of an interval variable to a cumul function at its end point.</span>

<span class="sd">    Whenever interval variable *interval* is present, this function returns an integer expression</span>
<span class="sd">    that represents the total contribution of the end of interval variable *interval* to the cumul *function*.</span>

<span class="sd">    When interval variable *interval* is absent, this function returns a constant integer expression equal</span>
<span class="sd">    to *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval:    Interval variable.</span>
<span class="sd">        function:    Cumul function expression.</span>
<span class="sd">        absentValue (Optional): Value to return if the interval variable interval becomes absent.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">absentValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_height_at_end</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                                  <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_CumulExpr</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_height_at_end</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">),</span>
                                                              <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_CumulExpr</span><span class="p">),</span>
                                                              <span class="n">_convert_arg</span><span class="p">(</span><span class="n">absentValue</span><span class="p">,</span> <span class="s2">&quot;absentValue&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">)))</span></div>


<div class="viewcode-block" id="always_in"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.always_in">[docs]</a><span class="k">def</span> <span class="nf">always_in</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">_x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; These constraints restrict the possible values of a *cumulExpr* or *stateFunction*</span>
<span class="sd">    to a particular range during a variable or fixed interval.</span>

<span class="sd">    These functions return a constraints that restricts the possible values of *function* to a particular range</span>
<span class="sd">    [*min*, *max*] during an interval variable *interval* or a fixed interval [*start*, *end*).</span>

<span class="sd">    In the case of an interval variable *interval*, this constraint is active only when the interval variable</span>
<span class="sd">    is present.</span>
<span class="sd">    If the interval is absent, the constraint is always satisfied, regardless of the value of *function*.</span>

<span class="sd">    When the constraint is posted on a state function, the range constraint holds only on the segments</span>
<span class="sd">    where the state function is defined.</span>

<span class="sd">    Args:</span>
<span class="sd">        function: Constrained cumul expression or state function.</span>
<span class="sd">        interval: Interval variable contributing to the cumul function,</span>
<span class="sd">                  or fixed interval expressed as a tuple of 2 integers.</span>
<span class="sd">        min: Minimum of the allowed range for values of function during the interval, in [0..intervalmax).</span>
<span class="sd">        max: Maximum of the allowed range for values of function during the interval, in [0..intervalmax).</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">function</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_CumulExpr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">function</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_StateFunction</span><span class="p">),</span> \
        <span class="s2">&quot;Argument &#39;function&#39; should be a cumul expression or a state function&quot;</span>

    <span class="c1"># Case of 5 arguments (backward compatibility with previous implementation)</span>
    <span class="k">if</span> <span class="n">_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Deprecated calling form, consult documentation for details&quot;</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_in</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">,</span> <span class="n">msg</span><span class="p">),</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">,</span> <span class="n">msg</span><span class="p">),</span>  <span class="c1"># Min is end</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">,</span> <span class="n">msg</span><span class="p">),</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="s2">&quot;_x&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">,</span> <span class="n">msg</span><span class="p">)))</span>

    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">min</span> <span class="o">&lt;=</span> <span class="n">INTERVAL_MAX</span><span class="p">,</span> <span class="s2">&quot;Argument &#39;min&#39; should be in 0..</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">INTERVAL_MAX</span><span class="p">)</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">max</span> <span class="o">&lt;=</span> <span class="n">INTERVAL_MAX</span><span class="p">,</span> <span class="s2">&quot;Argument &#39;max&#39; should be in 0..</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">INTERVAL_MAX</span><span class="p">)</span>
    <span class="nb">min</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">)</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_is_int_couple</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_in</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;interval[0]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">),</span>
                                                                 <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;interval[1]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">),</span>
                                                                 <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">))</span>

    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">,</span>
                            <span class="s2">&quot;Argument &#39;interval&#39; should be an interval variable or a fixed interval expressed as a tuple of integers&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_in</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">))</span></div>


<div class="viewcode-block" id="cumul_range"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.cumul_range">[docs]</a><span class="k">def</span> <span class="nf">cumul_range</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Limits the range of a cumul function expression.</span>

<span class="sd">    This function returns a constraint that restricts the possible values of cumul *function*</span>
<span class="sd">    to belong to a range [*min*, *max*].</span>

<span class="sd">    Args:</span>
<span class="sd">        function: Cumul function expression.</span>
<span class="sd">        min: Minimum of the range of allowed values for the cumul function.</span>
<span class="sd">        max: Maximum of the range of allowed values for the cumul function.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_cumul_range</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_CumulExpr</span><span class="p">),</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">),</span>
                                                               <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">Type_IntExpr</span><span class="p">)))</span></div>



<span class="c1">#==============================================================================</span>
<span class="c1">#  State functions</span>
<span class="c1">#==============================================================================</span>

<div class="viewcode-block" id="always_no_state"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.always_no_state">[docs]</a><span class="k">def</span> <span class="nf">always_no_state</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This constraint ensures that a state function is undefined on an interval.</span>

<span class="sd">    This function returns a constraint that ensures that *function* is undefined everywhere on</span>
<span class="sd">    an interval (interval variable *interval* when it is present or fixed interval [*start*, *end*)).</span>
<span class="sd">    This constraint will ensure, in particular, that no interval variable that requires the function</span>
<span class="sd">    to be defined (see *always_equal*, *always_constant*) can overlap with interval variable *interval*</span>
<span class="sd">    or fixed interval [*start*, *end*)).</span>

<span class="sd">    Args:</span>
<span class="sd">        function: Constrained state function.</span>
<span class="sd">        interval: Interval variable contributing to the cumul function,</span>
<span class="sd">                  or fixed interval expressed as a tuple of 2 integers.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_StateFunction</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_is_int_couple</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_no_state</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span>
                                                                       <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;interval[0]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">),</span>
                                                                       <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;interval[1]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">)))</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">,</span>
                            <span class="s2">&quot;Argument &#39;interval&#39; should be an interval variable or a fixed interval expressed as a tuple of integers&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_no_state</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">interval</span><span class="p">))</span></div>


<div class="viewcode-block" id="always_constant"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.always_constant">[docs]</a><span class="k">def</span> <span class="nf">always_constant</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">isStartAligned</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isEndAligned</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This constraint ensures a constant state for a state function on an interval.</span>

<span class="sd">    This function returns a constraint that ensures that *function* is defined everywhere on an</span>
<span class="sd">    interval variable *interval* when it is present or a fixed interval [*start*, *end*))</span>
<span class="sd">    and remains constant over this interval.</span>

<span class="sd">    Generally speaking, the optional boolean values *isStartAligned* and *isEndAligned* allow</span>
<span class="sd">    synchronization of start and end with the intervals of the state function:</span>

<span class="sd">     * When *isStartAligned* is true, it means that start must be the start of an interval of the state function.</span>
<span class="sd">     * When *isEndAligned* is true, it means that end must be the end of an interval of the state function.</span>

<span class="sd">    Args:</span>
<span class="sd">        function: Constrained state function.</span>
<span class="sd">        interval: Interval variable contributing to the cumul function,</span>
<span class="sd">                  or fixed interval expressed as a tuple of 2 integers.</span>
<span class="sd">        isStartAligned (Optional): Boolean flag that states whether the interval is start aligned (default: no alignment).</span>
<span class="sd">        isEndAligned (Optional): Boolean flag that states whether the interval is end aligned (default: no alignment).</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isStartAligned</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">isEndAligned</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isStartAligned</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">isEndAligned</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isEndAligned</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_StateFunction</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_is_int_couple</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;interval[0]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;interval[1]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isStartAligned</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_constant</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_constant</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
                                                                       <span class="n">_convert_arg_bool_int</span><span class="p">(</span><span class="n">isStartAligned</span><span class="p">,</span> <span class="s2">&quot;isStartAligned&quot;</span><span class="p">),</span>
                                                                       <span class="n">_convert_arg_bool_int</span><span class="p">(</span><span class="n">isEndAligned</span><span class="p">,</span> <span class="s2">&quot;isEndAligned&quot;</span><span class="p">)))</span>

    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">,</span>
                            <span class="s2">&quot;Argument &#39;interval&#39; should be an interval variable or a fixed interval expressed as a tuple of integers&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isStartAligned</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_constant</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">interval</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_constant</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span>
                                                                   <span class="n">_convert_arg_bool_int</span><span class="p">(</span><span class="n">isStartAligned</span><span class="p">,</span> <span class="s2">&quot;isStartAligned&quot;</span><span class="p">),</span>
                                                                   <span class="n">_convert_arg_bool_int</span><span class="p">(</span><span class="n">isEndAligned</span><span class="p">,</span> <span class="s2">&quot;isEndAligned&quot;</span><span class="p">)))</span></div>


<div class="viewcode-block" id="always_equal"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.always_equal">[docs]</a><span class="k">def</span> <span class="nf">always_equal</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">isStartAligned</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isEndAligned</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This constraint fixes a given state for a state function during a variable or fixed interval.</span>

<span class="sd">    This function returns a constraint that ensures that *function* is defined everywhere on an</span>
<span class="sd">    interval *interval* when it is present or a fixed interval [*start*, *end*)), and remains equal</span>
<span class="sd">    to value *val* over this interval.</span>

<span class="sd">    Generally speaking, the optional boolean values *isStartAligned* and *isEndAligned* allow</span>
<span class="sd">    synchronization of start and end with the intervals of the state function:</span>

<span class="sd">     * When *isStartAligned* is true, it means that start must be the start of an interval of the state function.</span>
<span class="sd">     * When *isEndAligned* is true, it means that end must be the end of an interval of the state function.</span>

<span class="sd">    Args:</span>
<span class="sd">        function: Constrained state function.</span>
<span class="sd">        interval: Interval variable contributing to the cumul function,</span>
<span class="sd">                  or fixed interval expressed as a tuple of 2 integers.</span>
<span class="sd">        value: Value of the function during the interval.</span>
<span class="sd">        isStartAligned (Optional): Boolean flag that states whether the interval is start aligned (default: no alignment).</span>
<span class="sd">        isEndAligned (Optional): Boolean flag that states whether the interval is end aligned (default: no alignment).</span>
<span class="sd">    Returns:</span>
<span class="sd">        Constraint expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isStartAligned</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">isEndAligned</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isStartAligned</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">isEndAligned</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isEndAligned</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">Type_StateFunction</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">Type_PositiveInt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_is_int_couple</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;interval[0]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;interval[1]&quot;</span><span class="p">,</span> <span class="n">Type_TimeInt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isStartAligned</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_equal</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_equal</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
                                                                    <span class="n">_convert_arg_bool_int</span><span class="p">(</span><span class="n">isStartAligned</span><span class="p">,</span> <span class="s2">&quot;isStartAligned&quot;</span><span class="p">),</span>
                                                                    <span class="n">_convert_arg_bool_int</span><span class="p">(</span><span class="n">isEndAligned</span><span class="p">,</span> <span class="s2">&quot;isEndAligned&quot;</span><span class="p">)))</span>

    <span class="n">interval</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="s2">&quot;interval&quot;</span><span class="p">,</span> <span class="n">Type_IntervalVar</span><span class="p">,</span>
                            <span class="s2">&quot;Argument &#39;interval&#39; should be an interval variable or a fixed interval expressed as a tuple of integers&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isStartAligned</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_equal</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_always_equal</span><span class="p">,</span> <span class="n">Type_Constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
                                                                <span class="n">_convert_arg_bool_int</span><span class="p">(</span><span class="n">isStartAligned</span><span class="p">,</span> <span class="s2">&quot;isStartAligned&quot;</span><span class="p">),</span>
                                                                <span class="n">_convert_arg_bool_int</span><span class="p">(</span><span class="n">isEndAligned</span><span class="p">,</span> <span class="s2">&quot;isEndAligned&quot;</span><span class="p">)))</span></div>


<span class="c1">#==============================================================================</span>
<span class="c1">#  Search phases</span>
<span class="c1">#==============================================================================</span>

<span class="c1">#--- Variable evaluators ------------------------------------------------------</span>

<div class="viewcode-block" id="domain_size"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.domain_size">[docs]</a><span class="k">def</span> <span class="nf">domain_size</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Variable evaluator that represents the number of elements in the current domain</span>
<span class="sd">    of the variable chosen by the search.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_domain_size</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="domain_max"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.domain_max">[docs]</a><span class="k">def</span> <span class="nf">domain_max</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Variable evaluator that represents the maximum value in the current domain</span>
<span class="sd">    of the variable chosen by the search.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_domain_max</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="domain_min"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.domain_min">[docs]</a><span class="k">def</span> <span class="nf">domain_min</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Variable evaluator that represents the minimum value in the current domain</span>
<span class="sd">    of the variable chosen by the search.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_domain_min</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="var_impact"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.var_impact">[docs]</a><span class="k">def</span> <span class="nf">var_impact</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Variable evaluator that represents the average reduction of the search</span>
<span class="sd">    space observed so far for this variable.</span>

<span class="sd">    The greater the evaluation, the more space reduction this variable achieves.</span>
<span class="sd">    In general, it is a good strategy to start with variable having the greatest impact in order to</span>
<span class="sd">    reduce the search space size.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_var_impact</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="var_index"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.var_index">[docs]</a><span class="k">def</span> <span class="nf">var_index</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">defaultIndex</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Variable evaluator that represents the index of the variable in an array of variables.</span>

<span class="sd">    The evaluation of vars[i] is i.</span>
<span class="sd">    If the variable does not appear in the array, defaultIndex is the evaluation returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        vars:  Array of integer variables.</span>
<span class="sd">        defaultIndex (Optional): Default index that is returned if the variable does not appear in the array.</span>
<span class="sd">                      If not given, -1 is used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">vars</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="s2">&quot;vars&quot;</span><span class="p">,</span> <span class="n">Type_IntVarArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">defaultIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_var_index</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_var_index</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">defaultIndex</span><span class="p">,</span> <span class="s2">&quot;defaultIndex&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span></div>


<div class="viewcode-block" id="var_local_impact"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.var_local_impact">[docs]</a><span class="k">def</span> <span class="nf">var_local_impact</span><span class="p">(</span><span class="n">effort</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Variable evaluator that represents the impact of the variable computed at</span>
<span class="sd">    the current node of the search tree.</span>

<span class="sd">    This computation is made by probing on values from the domain of the variables.</span>
<span class="sd">    The parameter *effort* indicates how much effort should be spent to compute this impact.</span>
<span class="sd">    When effort is equal to -1, every value of the domain is probed, otherwise the number of probes effort</span>
<span class="sd">    will increase as the effort value increases.</span>

<span class="sd">    Args:</span>
<span class="sd">        effort (Optional): Integer representing how much effort should be spent to compute this impact.</span>
<span class="sd">                By default, -1 is used.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">effort</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_var_local_impact</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">())</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_var_local_impact</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">effort</span><span class="p">,</span> <span class="s2">&quot;effort&quot;</span><span class="p">,</span> <span class="n">Type_Int</span><span class="p">),))</span></div>


<div class="viewcode-block" id="var_success_rate"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.var_success_rate">[docs]</a><span class="k">def</span> <span class="nf">var_success_rate</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Variable evaluator that represents the success rate of the variable.</span>

<span class="sd">    Assuming the evaluated variable has been instantiated n times so far and this has resulted in f failures,</span>
<span class="sd">    the success rate is (n-f)/n.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_var_success_rate</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="impact_of_last_branch"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.impact_of_last_branch">[docs]</a><span class="k">def</span> <span class="nf">impact_of_last_branch</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Variable evaluator that represents the domain reduction that the</span>
<span class="sd">    last instantiation made by search has achieved on the evaluated variable.</span>

<span class="sd">    Values returned range from 0 to 1.0.</span>
<span class="sd">    If the value is close to zero then there wasn&#39;t much domain reduction on the evaluated variable</span>
<span class="sd">    during the last instantiation.</span>
<span class="sd">    If the value is close to one, the domain was reduced considerably.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_impact_of_last_branch</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="explicit_var_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.explicit_var_eval">[docs]</a><span class="k">def</span> <span class="nf">explicit_var_eval</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">defaultEval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Variable evaluator that gives an explicit value to variables.</span>

<span class="sd">    The evaluations of variables in the array *vars* are explicitly defined in the array of values *vals*,</span>
<span class="sd">    that is the evaluation of *vars[i]* is *vals[i]*.</span>
<span class="sd">    The arrays *vars* and *vals* must have the same size.</span>

<span class="sd">    The evaluation of a variable that does not appear in the array is given by *defautEval*.</span>

<span class="sd">    Args:</span>
<span class="sd">        vars: Array of integer variables</span>
<span class="sd">        vals: Array of values</span>
<span class="sd">        defaultEval (Optional): Default value of a variable that is not in the array</span>
<span class="sd">                     If not given, default eval value is zero.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">vars</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="s2">&quot;vars&quot;</span><span class="p">,</span> <span class="n">Type_IntVarArray</span><span class="p">)</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="s2">&quot;vals&quot;</span><span class="p">,</span> <span class="n">Type_FloatArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">defaultEval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_explicit_var_eval</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">vals</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_explicit_var_eval</span><span class="p">,</span> <span class="n">Type_IntVarEval</span><span class="p">,</span> <span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span>
                                                                     <span class="n">_convert_arg</span><span class="p">(</span><span class="n">defaultEval</span><span class="p">,</span> <span class="s2">&quot;defaultEval&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span></div>

<span class="c1">#--- Value evaluators ---------------------------------------------------------</span>

<div class="viewcode-block" id="value"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.value">[docs]</a><span class="k">def</span> <span class="nf">value</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Value evaluator that returns as evaluation the value itself.</span>

<span class="sd">    This is useful to define instantiation strategies that choose the smallest or the largest</span>
<span class="sd">    value in a domain.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_value</span><span class="p">,</span> <span class="n">Type_IntValueEval</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="value_impact"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.value_impact">[docs]</a><span class="k">def</span> <span class="nf">value_impact</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Value evaluator that represents the average reduction of the search space observed</span>
<span class="sd">    so far when instantiating the selected variable to the evaluated value.</span>

<span class="sd">    The greater the evaluation, the more space reduction this instantiation achieves.</span>
<span class="sd">    In general it is a good strategy to prefer a value having the smallest impact.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_value_impact</span><span class="p">,</span> <span class="n">Type_IntValueEval</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="value_success_rate"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.value_success_rate">[docs]</a><span class="k">def</span> <span class="nf">value_success_rate</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Value evaluator that represents the success rate of instantiating the selected variable</span>
<span class="sd">    to the evaluated value.</span>

<span class="sd">    Assuming the selected variable has been instantiated to the evaluated value n times so far</span>
<span class="sd">    and this has resulted in f failures, the success rate is (n-f)/n.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_value_success_rate</span><span class="p">,</span> <span class="n">Type_IntValueEval</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="value_index"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.value_index">[docs]</a><span class="k">def</span> <span class="nf">value_index</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">defaultValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;  Value evaluator that represents the index of the value in an array of integer values.</span>

<span class="sd">    The evaluation of *vals[i]* is *i*.</span>
<span class="sd">    If the value does not appear in the array, *defautEval* is the evaluation returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        vals: Array of integer values</span>
<span class="sd">        defaultValue (Optional): Default value that is returned if value is not in the array.</span>
<span class="sd">                      By default, this value is -1.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="s2">&quot;vals&quot;</span><span class="p">,</span> <span class="n">Type_IntArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">defaultValue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_value_index</span><span class="p">,</span> <span class="n">Type_IntValueEval</span><span class="p">,</span> <span class="p">(</span><span class="n">vals</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_value_index</span><span class="p">,</span> <span class="n">Type_IntValueEval</span><span class="p">,</span> <span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">defaultValue</span><span class="p">,</span> <span class="s2">&quot;defaultValue&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span></div>


<div class="viewcode-block" id="explicit_value_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.explicit_value_eval">[docs]</a><span class="k">def</span> <span class="nf">explicit_value_eval</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">evals</span><span class="p">,</span> <span class="n">defaultEval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Value evaluator hat gives an explicit evaluation to values.</span>

<span class="sd">    The evaluations of elements of array *vals* are explicitly defined in the array *evals*,</span>
<span class="sd">    that is, the evaluation of *vals[i]* is *evals[i]*.</span>
<span class="sd">    The arrays *vals* and *evals* must have the same size.</span>

<span class="sd">    The evaluation of a value that does not appear in *vals* is given by *defautEval*.</span>

<span class="sd">    Args:</span>
<span class="sd">        vals: Array of values</span>
<span class="sd">        evals: Array of the evaluations of values</span>
<span class="sd">        defaultEval (Optional): Evaluation of a value that does not appears in *vals*.</span>
<span class="sd">                     By default, this value is zero.</span>
<span class="sd">    Returns:</span>
<span class="sd">        An evaluator of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="s2">&quot;vals&quot;</span><span class="p">,</span> <span class="n">Type_IntArray</span><span class="p">)</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">_convert_arg</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="s2">&quot;evals&quot;</span><span class="p">,</span> <span class="n">Type_FloatArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">defaultEval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_explicit_value_eval</span><span class="p">,</span> <span class="n">Type_IntValueEval</span><span class="p">,</span> <span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">evals</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_explicit_value_eval</span><span class="p">,</span> <span class="n">Type_IntValueEval</span><span class="p">,</span> <span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">evals</span><span class="p">,</span>
                                                                         <span class="n">_convert_arg</span><span class="p">(</span><span class="n">defaultEval</span><span class="p">,</span> <span class="s2">&quot;defaultEval&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span></div>


<span class="c1">#--- Variable selectors -------------------------------------------------------</span>

<div class="viewcode-block" id="select_smallest"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.select_smallest">[docs]</a><span class="k">def</span> <span class="nf">select_smallest</span><span class="p">(</span><span class="n">evaluator</span><span class="p">,</span> <span class="n">minNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Selector of integer variables or value having the smallest evaluation according to a given evaluator.</span>

<span class="sd">    This function returns a selector of value assignments to a variable that selects all values having the</span>
<span class="sd">    smallest evaluation according to the evaluator e.</span>

<span class="sd">    If *minNumber* is provided, this function returns a selector of integer variable or value assignments that selects</span>
<span class="sd">    at least *minNumber* values having the smallest evaluation according to the evaluator.</span>
<span class="sd">    The parameter *minNumber* must be at least 1.</span>
<span class="sd">    For example, suppose that eight domain values (1-8) have evaluations</span>
<span class="sd">    (1) 9, (2) 5, (3) 6, (4) 3, (5) 8, (6) 1, (7) 3, (8) 2.</span>
<span class="sd">    When ordered by increasing evaluation, this gives: (6) 1, (8) 2, (4) 3, (7) 3, (2) 5, (3) 6, (5) 8, (1) 9.</span>
<span class="sd">    If *minNumber* is 1, then value 6 would be selected, if it is 2, then values 6 and 8 would be selected,</span>
<span class="sd">    and if it is 3 then values 6, 8, 4 and 7 would be selected.</span>
<span class="sd">    Note that when minNumber is 3, both values 4 and 7 are selected as both are considered equivalent.</span>
<span class="sd">    In addition, it is possible to specify a non-integer value of *minNumber*.</span>
<span class="sd">    In this case, at least floor(*minNumber*) selections are made, with probability *minNumber* - floor(*minNumber*)</span>
<span class="sd">    of selecting an additional value.</span>
<span class="sd">    It is still possible that this selector can select less values than *minNumber* if there are less</span>
<span class="sd">    than *minNumber* values supplied to it for selection, in which case all supplied values are selected.</span>

<span class="sd">    If *tolerance* is provided (exclusively with *minNumber*), this function returns a selector of integer variable</span>
<span class="sd">    or value assignments that selects all domain values whose evaluations are in the range [*min*, *min* + *tolerance*],</span>
<span class="sd">    where *min* is is the minimum valuation by the evaluator over the domain values to be evaluated.</span>
<span class="sd">    The parameter *tolerance* must be non-negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        evaluator: Evaluator of integer variable or integer value</span>
<span class="sd">        minNumber (Optional): Minimum number of values that are selected,</span>
<span class="sd">                    with the smallest evaluation according to the evaluator e</span>
<span class="sd">        tolerance (Optional): Tolerance of the values to be selected</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression of type selector of integer value or selector of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evaluator</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">evaluator</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntValueEval</span><span class="p">):</span>
        <span class="n">rtype</span> <span class="o">=</span> <span class="n">Type_IntValueSelector</span>
    <span class="k">elif</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntVarEval</span><span class="p">):</span>
        <span class="n">rtype</span> <span class="o">=</span> <span class="n">Type_IntVarSelector</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Argument &#39;evaluator&#39; should be an evaluator of integer variable or an evaluator of integer value&quot;</span>

    <span class="k">if</span> <span class="n">minNumber</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_select_smallest</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="n">evaluator</span><span class="p">,))</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_select_smallest</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="n">evaluator</span><span class="p">,</span>
                                                             <span class="n">_convert_arg</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="s2">&quot;tolerance&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span>

    <span class="k">assert</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Arguments &#39;minNumber&#39; and &#39;tolerance&#39; can not be set together&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_select_smallest</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">minNumber</span><span class="p">,</span> <span class="s2">&quot;minNumber&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">),</span>
                                                         <span class="n">evaluator</span><span class="p">))</span></div>



<div class="viewcode-block" id="select_largest"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.select_largest">[docs]</a><span class="k">def</span> <span class="nf">select_largest</span><span class="p">(</span><span class="n">evaluator</span><span class="p">,</span> <span class="n">minNumber</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Selector of integer variables or value having the largest evaluation according to a given evaluator.</span>

<span class="sd">    This function returns a selector of value assignments to a variable that selects all values having the</span>
<span class="sd">    largest evaluation according to the evaluator e.</span>

<span class="sd">    If *minNumber* is provided, this function returns a selector of integer variable or value assignments that selects</span>
<span class="sd">    at least *minNumber* values having the largest evaluation according to the evaluator.</span>
<span class="sd">    The parameter *minNumber* must be at least 1.</span>
<span class="sd">    For example, suppose that eight domain values (1-8) have evaluations</span>
<span class="sd">    (1) 5, (2) 8, (3) 3, (4) 9, (5) 2, (6) 8, (7) 1, (8) 7.</span>
<span class="sd">    When ordered by decreasing evaluation, this gives: (4) 9, (2) 8, (6) 8, (8) 7, (1) 5, (3) 3, (5) 2, (7) 1.</span>
<span class="sd">    If *minNumber* is 1, then value 4 would be selected, if it is 2 or 3, then values 2 and 6 would be selected,</span>
<span class="sd">    and if it is 4 then values 4, 2, 6, and 8 would be selected.</span>
<span class="sd">    Note that when *minNumber* is 2, both 2 and 6 are selected as both are considered equivalent.</span>
<span class="sd">    In addition, it is possible to specify a non-integer value of *minNumber*.</span>
<span class="sd">    In this case, at least floor(*minNumber*) selections are made, with probability *minNumber* - floor(*minNumber*)</span>
<span class="sd">    of selecting an additional value.</span>
<span class="sd">    It is still possible that this selector can select less domain values than *minNumber* if there are</span>
<span class="sd">    less than *minNumber* values supplied to it for selection, in which case all supplied values are selected.</span>

<span class="sd">    If *tolerance* is provided (exclusively with *minNumber*), this function returns a selector of integer variable</span>
<span class="sd">    or value assignments that selects all domain values whose evaluations are in the range [*max* - *tolerance*, *max*],</span>
<span class="sd">    where *max* is is the maximum valuation by the evaluator over the domain values to be evaluated.</span>
<span class="sd">    The parameter *tolerance* must be non-negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        evaluator: Evaluator of integer variable or integer value</span>
<span class="sd">        minNumber (Optional): Minimum number of values that are selected,</span>
<span class="sd">                    with the smallest evaluation according to the evaluator e</span>
<span class="sd">        tolerance (Optional): Tolerance of the values to be selected</span>
<span class="sd">    Returns:</span>
<span class="sd">        An expression of type selector of integer value or selector of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">evaluator</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="n">evaluator</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntValueEval</span><span class="p">):</span>
        <span class="n">rtype</span> <span class="o">=</span> <span class="n">Type_IntValueSelector</span>
    <span class="k">elif</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntVarEval</span><span class="p">):</span>
        <span class="n">rtype</span> <span class="o">=</span> <span class="n">Type_IntVarSelector</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Argument &#39;evaluator&#39; should be an evaluator of integer variable or an evaluator of integer value&quot;</span>

    <span class="k">if</span> <span class="n">minNumber</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_select_largest</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="n">evaluator</span><span class="p">,))</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_select_largest</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="n">evaluator</span><span class="p">,</span>
                                                            <span class="n">_convert_arg</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="s2">&quot;tolerance&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">)))</span>

    <span class="k">assert</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Arguments &#39;minNumber&#39; and &#39;tolerance&#39; can not be set together&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_select_largest</span><span class="p">,</span> <span class="n">rtype</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">minNumber</span><span class="p">,</span> <span class="s2">&quot;minNumber&quot;</span><span class="p">,</span> <span class="n">Type_Float</span><span class="p">),</span>
                                                        <span class="n">evaluator</span><span class="p">))</span></div>


<div class="viewcode-block" id="select_random_var"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.select_random_var">[docs]</a><span class="k">def</span> <span class="nf">select_random_var</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Selector of integer variables that selects a variable randomly.</span>

<span class="sd">    This selector selects only one variable.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A selector of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_select_random_var</span><span class="p">,</span> <span class="n">Type_IntVarSelector</span><span class="p">,</span> <span class="p">())</span></div>


<div class="viewcode-block" id="select_random_value"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.select_random_value">[docs]</a><span class="k">def</span> <span class="nf">select_random_value</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Selector of integer variable value assignments that selects a domain value randomly.</span>

<span class="sd">    This selector selects only one value.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A selector of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_select_random_value</span><span class="p">,</span> <span class="n">Type_IntValueSelector</span><span class="p">,</span> <span class="p">())</span></div>


<span class="c1">#--- Search phase -------------------------------------------------------------</span>

<div class="viewcode-block" id="search_phase"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.search_phase">[docs]</a><span class="k">def</span> <span class="nf">search_phase</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">varchooser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">valuechooser</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a search phase.</span>

<span class="sd">    A search phase is composed of:</span>

<span class="sd">     * an array of variables to instantiate,</span>
<span class="sd">     * a variable chooser that defines how the next variable to instantiate is chosen</span>
<span class="sd">     * a value chooser that defines how values are chosen when instantiating variables.</span>

<span class="sd">    The embedded search strategy, determined by the value of the solver parameter *SearchType*,</span>
<span class="sd">    will use the search phases to instantiate the variables for which a search phase is specified.</span>

<span class="sd">    Several search phases can be given to the CP model using method :meth:`docplex.cp.model.CpoModel.set_search_phases`</span>
<span class="sd">    or :meth:`docplex.cp.model.CpoModel.add_search_phase`.</span>

<span class="sd">    The order of the search phases in the array is important. In the CP search strategy, the variables will be</span>
<span class="sd">    instantiated phase by phase starting by the first phase of the array.</span>
<span class="sd">    It is not necessary that the variables in the search phases cover all the variables of the problem.</span>
<span class="sd">    It can be assumed that a search phase containing all the problem variables is implicitly added to the</span>
<span class="sd">    end of the given array of search phases.</span>

<span class="sd">    A search phase can be created with an array of variables only.</span>
<span class="sd">    The embedded search will then choose an instantiation strategy automatically.</span>
<span class="sd">    For instance, assuming that x and y are arrays of integer variables, the following code:</span>
<span class="sd">    ::</span>

<span class="sd">        mdl.set_search_phases([search_phase(x), search_phase(y)])</span>

<span class="sd">    indicates to CP search that variables from the array x must be instantiated before those from the array y.</span>
<span class="sd">    The way to instantiate them will be chosen by CP search.</span>

<span class="sd">    Similarly, it is not necessary to specify an array of variables to a search phase.</span>
<span class="sd">    A search phase defined this way will be applied to every integer variable extracted from the model.</span>

<span class="sd">    Args:</span>
<span class="sd">        vars (Optional): Array of integer, interval or sequence variables.</span>
<span class="sd">        varchooser (Optional): Chooser of integer variable.</span>
<span class="sd">                    Used only if *vars* is undefined or contains an array of integer variables.</span>
<span class="sd">                    Must be defined if a *valuechooser* is defined.</span>
<span class="sd">        valuechooser (Optional): Chooser of integer value</span>
<span class="sd">                    Used only if *vars* is undefined or contains an array of integer variables.</span>
<span class="sd">                    Must be defined if a *varchooser* is defined.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A search phase expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">varchooser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">valuechooser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span> \
            <span class="s2">&quot;If no array of variable is given, then variable and value choosers must be given&quot;</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_search_phase</span><span class="p">,</span> <span class="n">Type_SearchPhase</span><span class="p">,</span> <span class="p">(</span><span class="n">_convert_arg</span><span class="p">(</span><span class="n">varchooser</span><span class="p">,</span> <span class="s2">&quot;varchooser&quot;</span><span class="p">,</span> <span class="n">Type_IntVarChooser</span><span class="p">),</span>
                                                                     <span class="n">_convert_arg</span><span class="p">(</span><span class="n">valuechooser</span><span class="p">,</span> <span class="s2">&quot;valuechooser&quot;</span><span class="p">,</span> <span class="n">Type_IntValueChooser</span><span class="p">)))</span>

    <span class="nb">vars</span> <span class="o">=</span> <span class="n">build_cpo_expr</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">vars</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntVarArray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">varchooser</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">valuechooser</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Variable and value chooser should be defined together&quot;</span>
            <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_search_phase</span><span class="p">,</span> <span class="n">Type_SearchPhase</span><span class="p">,</span> <span class="p">(</span><span class="nb">vars</span><span class="p">,))</span>
        <span class="k">assert</span> <span class="n">valuechooser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Variable and value chooser should be defined together&quot;</span>
        <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_search_phase</span><span class="p">,</span> <span class="n">Type_SearchPhase</span><span class="p">,</span> <span class="p">(</span><span class="nb">vars</span><span class="p">,</span>
                                                                     <span class="n">_convert_arg</span><span class="p">(</span><span class="n">varchooser</span><span class="p">,</span> <span class="s2">&quot;varchooser&quot;</span><span class="p">,</span> <span class="n">Type_IntVarChooser</span><span class="p">),</span>
                                                                     <span class="n">_convert_arg</span><span class="p">(</span><span class="n">valuechooser</span><span class="p">,</span> <span class="s2">&quot;valuechooser&quot;</span><span class="p">,</span> <span class="n">Type_IntValueChooser</span><span class="p">)))</span>

    <span class="k">assert</span> <span class="nb">vars</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_IntervalVarArray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">vars</span><span class="o">.</span><span class="n">is_kind_of</span><span class="p">(</span><span class="n">Type_SequenceVarArray</span><span class="p">),</span> \
        <span class="s2">&quot;Argument &#39;vars&#39; should be an array of integer, interval or sequence variables&quot;</span>
    <span class="k">return</span> <span class="n">CpoFunctionCall</span><span class="p">(</span><span class="n">Oper_search_phase</span><span class="p">,</span> <span class="n">Type_SearchPhase</span><span class="p">,</span> <span class="p">(</span><span class="nb">vars</span><span class="p">,))</span></div>


</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DOcplex.CP: Constraint Programming Modeling for Python V2.15 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, IBM.
    </div>
  </body>
</html>