<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    
    <title>docplex.cp.modeler &mdash; DOcplex.CP: Constraint Programming Modeling for Python V1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     'V1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="DOcplex.CP: Constraint Programming Modeling for Python V1.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DOcplex.CP: Constraint Programming Modeling for Python V1.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for docplex.cp.modeler</h1><div class="highlight"><pre>
<span></span><span class="c1"># --------------------------------------------------------------------------</span>
<span class="c1"># Source file provided under Apache License, Version 2.0, January 2004,</span>
<span class="c1"># http://www.apache.org/licenses/</span>
<span class="c1"># (c) Copyright IBM Corp. 2015, 2016</span>
<span class="c1"># --------------------------------------------------------------------------</span>
<span class="c1"># Generated automatically</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the set of functions that allows to construct all expressions</span>
<span class="sd">available in a DOcplex.CP model.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">docplex.cp.model</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">docplex.cp.expression</span> <span class="kn">import</span> <span class="n">_create_operation</span> <span class="k">as</span> <span class="n">create_op</span>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">__builtin__</span> <span class="kn">as</span> <span class="nn">builtin</span>  <span class="c1"># Python 2.7</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">builtins</span> <span class="kn">as</span> <span class="nn">builtin</span>     <span class="c1"># Python 3</span>


<span class="c1">###############################################################################</span>
<span class="c1">##  Private methods</span>
<span class="c1">###############################################################################</span>

<span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Expand an argument if it is an iterator</span>
<span class="sd">    Args:</span>
<span class="sd">        arg: Argument to check</span>
<span class="sd">    Returns:</span>
<span class="sd">        Argument, expanded as list if it is an iterator (recursively)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterator</span><span class="p">):</span>
       <span class="k">return</span> <span class="p">[</span><span class="n">_expand</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">arg</span>

<span class="k">def</span> <span class="nf">_no_cpo_args</span><span class="p">(</span><span class="n">largs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Check if a list of arguments does not contain any CPO expression</span>
<span class="sd">    Returns:</span>
<span class="sd">        True if list of arguments does not contain any CPO expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">largs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CpoExpr</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">CpoExpr</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>


<span class="c1">###############################################################################</span>
<span class="c1">##  Expression construction methods</span>
<span class="c1">###############################################################################</span>


<div class="viewcode-block" id="abs"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.abs">[docs]</a><span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Computes the absolute value of an expression.</span>

<span class="sd">    Function *abs* computes the absolute value of an integer or floating-point expression *x*.  The type of the function is</span>
<span class="sd">    the same as the type of its argument.  *abs(x)* is a more efficient way of writing *max(x, -x)*.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Integer or floating-point expression for which the absolute value is to be computed.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression) =&gt; integer expression</span>
<span class="sd">     * (float expression) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">_expand</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">_no_cpo_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">builtin</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_abs</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="abstraction"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.abstraction">[docs]</a><span class="k">def</span> <span class="nf">abstraction</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns a constraint that abstracts the values of one array as values in another array.</span>

<span class="sd">    For constraint programming: returns a constraint that abstracts the</span>
<span class="sd">    values of expressions contained in one array to expressions contained in</span>
<span class="sd">    another array.</span>
<span class="sd">    </span>
<span class="sd">    This function returns a constraint that abstracts the values of the</span>
<span class="sd">    elements of one array of expressions (called *x*) in a model into the</span>
<span class="sd">    abstract value of another array of expressions (called *y*). In other</span>
<span class="sd">    words, for each element *x[i]*, there is an expression *y[i]*</span>
<span class="sd">    corresponding to the abstraction of *x[i]* with respect to an array of</span>
<span class="sd">    numeric *values*. That is:</span>
<span class="sd">    </span>
<span class="sd">     * *x[i] = v* with *v* in *values* if and only if *y[i] = v*</span>
<span class="sd">     * *x[i] = v* with *v* not in *values* if and only if *y[i] = abstractValue*</span>
<span class="sd">    </span>
<span class="sd">    This constraint maintains a many-to-one mapping that makes it possible to</span>
<span class="sd">    define constraints that impinge only on a particular set of values from the</span>
<span class="sd">    domains of expressions. The abstract value (specified by</span>
<span class="sd">    *abstractValue*) must not be in the domain of *x[i]*.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: An array of abstracted integer expressions.</span>
<span class="sd">        x: An array of reference integer expressions.</span>
<span class="sd">        values: An array of integer values to be abstracted.</span>
<span class="sd">        abstractValue: An escape value.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, array of integer expressions, array of integers, integer constant) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_abstraction</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="all_diff"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.all_diff">[docs]</a><span class="k">def</span> <span class="nf">all_diff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Ensures a number of expressions contain no duplicate values.</span>

<span class="sd">    The *all_diff* function returns a constraint which ensures that no</span>
<span class="sd">    two expressions in the array *x* can have equivalent values.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array of integer expressions.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_all_diff</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="all_min_distance"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.all_min_distance">[docs]</a><span class="k">def</span> <span class="nf">all_min_distance</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constraint on the minimum absolute distance between a pair of integer expressions in an array.</span>

<span class="sd">    This constraint makes sure that the absolute distance between any pair</span>
<span class="sd">    of integer expressions in *exprs* will be greater than or equal to the</span>
<span class="sd">    given integer *distance*. In short, for any *i*, *j* distinct indices of *exprs* , it</span>
<span class="sd">    enforces *abs(exprs[i] - exprs[j]) &gt;= distance*.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs: Array of integer expressions.</span>
<span class="sd">        distance: Value used to constrain the distance between two elements of exprs.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, integer constant) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_all_min_distance</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="allowed_assignments"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.allowed_assignments">[docs]</a><span class="k">def</span> <span class="nf">allowed_assignments</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Explicitly defines possible assignments on one or more integer expressions.</span>

<span class="sd">    This Boolean expression (which is interpreted as a constraint outside of</span>
<span class="sd">    an expression) determines whether the assignment to a single expression *expr*</span>
<span class="sd">    or to an array of expressions *exprs* is contained within the value set</span>
<span class="sd">    *values* or the tuple set *tuples* respectively.  The Boolean expression</span>
<span class="sd">    will be true if and only if (depending on the signature):</span>
<span class="sd">     * the value of the expression *expr* is present in the array *values*.</span>
<span class="sd">     * the values of the expressions *exprs* are present in the tuple set *tuples*.</span>
<span class="sd">    </span>
<span class="sd">    The order of the constrained variables in the array *exprs* is</span>
<span class="sd">    important because the same order is respected in the tuple set *tuples*.</span>

<span class="sd">    Args:</span>
<span class="sd">        expr: An integer expression to be constrained.</span>
<span class="sd">        values: An integer array giving the possible values of expr.</span>
<span class="sd">        exprs: An array of integer expressions to be constrained.</span>
<span class="sd">        tuples: The set of tuples defining possible value assignments to exprs.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, array of integers) =&gt; boolean expression</span>
<span class="sd">     * (array of integer expressions, set of tuples) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_allowed_assignments</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="alternative"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.alternative">[docs]</a><span class="k">def</span> <span class="nf">alternative</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an alternative constraint between interval variables.</span>

<span class="sd">    This function creates an alternative constraint between interval variable</span>
<span class="sd">    *interval* and the set of interval variables in *array*. If no *cardinality*</span>
<span class="sd">    expression is specified, if *interval* is present, then one and only</span>
<span class="sd">    one of the intervals in *array* will be selected by the alternative constraint</span>
<span class="sd">    to be present and the start and end values of *interval* will be the same as the</span>
<span class="sd">    ones of the selected interval. If a *cardinality* expression is</span>
<span class="sd">    specified, *cardinality* intervals in *array* will be selected by the</span>
<span class="sd">    alternative constraint to be present and the selected intervals will have the</span>
<span class="sd">    same start and end value as interval variable *interval*. Interval variable *interval* is</span>
<span class="sd">    absent if and only if all interval variables in *array* are absent.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        array: Array of interval variables.</span>
<span class="sd">        cardinality: Cardinality of the alternative constraint. By default, when this optional argument is not specified, a unit cardinality is assumed (cardinality=1).</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, array of interval variables, integer expression [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_alternative</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="always_constant"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.always_constant">[docs]</a><span class="k">def</span> <span class="nf">always_constant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This constraint ensures a constant state for a state function on an interval.</span>

<span class="sd">    This function returns a constraint that ensures that *function* is defined everywhere on the interval (either interval</span>
<span class="sd">    variable *interval* when it is present or fixed interval [*start*,*end*)) and remains constant over this interval.</span>
<span class="sd">    </span>
<span class="sd">    Generally speaking, the optional Boolean values *isStartAligned* and *isEndAligned* allow synchronization of start and</span>
<span class="sd">    end with the intervals of the state function:</span>
<span class="sd">     * When *isStartAligned* is true, it means that start must be the start of an interval of the state function.</span>
<span class="sd">     * When *isEndAligned* is true, it means that end must be the end of an interval of the state function.</span>

<span class="sd">    Args:</span>
<span class="sd">        function: Constrained state function.</span>
<span class="sd">        interval: Interval variable during which function is constrained.</span>
<span class="sd">        start: Start of the fixed interval [start,end) during which function is constrained.</span>
<span class="sd">        end: End of the fixed interval [start,end) during which function is constrained.</span>
<span class="sd">        isStartAligned: Boolean flag that states whether the interval is start aligned (default: no alignment).</span>
<span class="sd">        isEndAligned: Boolean flag that states whether the interval is end aligned (default: no alignment).</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (state function, interval variable, boolean integer (0, 1) [=0], boolean integer (0, 1) [=0]) =&gt; constraint</span>
<span class="sd">     * (state function, integer time, integer time, boolean integer (0, 1) [=0], boolean integer (0, 1) [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_always_constant</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="always_equal"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.always_equal">[docs]</a><span class="k">def</span> <span class="nf">always_equal</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This constraint fixes a given state for a state function during a variable or fixed interval.</span>

<span class="sd">    This function returns a constraint that ensures that *function* is defined everywhere on the interval (either interval</span>
<span class="sd">    variable *interval* when it is present or fixed interval [*start*,*end*)) and remains equal to value *val* over this</span>
<span class="sd">    interval.</span>
<span class="sd">    </span>
<span class="sd">    Generally speaking, the optional Boolean values *isStartAligned* and *isEndAligned* allow synchronization of start and</span>
<span class="sd">    end with the intervals of the state function:</span>
<span class="sd">     * When *isStartAligned* is true, it means that start must be the start of an interval of the state function.</span>
<span class="sd">     * When *isEndAligned* is true, it means that end must be the end of an interval of the state function.</span>

<span class="sd">    Args:</span>
<span class="sd">        function: Constrained state function.</span>
<span class="sd">        interval: Interval variable during which function is constrained.</span>
<span class="sd">        start: Start of the fixed interval [start,end) during which function is constrained.</span>
<span class="sd">        end: End of the fixed interval [start,end) during which function is constrained.</span>
<span class="sd">        val: Value of function during the interval.</span>
<span class="sd">        isStartAligned: Boolean flag that states whether the interval is start aligned (default: no alignment).</span>
<span class="sd">        isEndAligned: Boolean flag that states whether the interval is end aligned (default: no alignment).</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (state function, interval variable, positive integer, boolean integer (0, 1) [=0], boolean integer (0, 1) [=0]) =&gt; constraint</span>
<span class="sd">     * (state function, integer time, integer time, positive integer, boolean integer (0, 1) [=0], boolean integer (0, 1) [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_always_equal</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="always_in"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.always_in">[docs]</a><span class="k">def</span> <span class="nf">always_in</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; These constraints restrict the possible values of a *cumulExpr* or</span>
<span class="sd">    *stateFunction* to a particular range during a variable or fixed interval.</span>

<span class="sd">    These functions return a constraints that restricts the possible values of *function* to a particular range</span>
<span class="sd">    [*min*,*max*] during an interval variable *interval* or a fixed interval [*start*,*end*). In the case of an interval</span>
<span class="sd">    variable *interval*, this constraint is active only when the interval variable is present, if the interval is absent the</span>
<span class="sd">    constraint is always satisfied, regardless of the value of *function*. When the constraint is posted on a state</span>
<span class="sd">    function, the range constraint holds only on the segments where the state function is defined.</span>

<span class="sd">    Args:</span>
<span class="sd">        function: Constrained cumul expression or state function.</span>
<span class="sd">        interval: Interval variable during which function is constrained.</span>
<span class="sd">        start: Start of the fixed interval [start,end) during which function is constrained.</span>
<span class="sd">        end: End of the fixed interval [start,end) during which function is constrained.</span>
<span class="sd">        min: Minimum of the allowed range for values of function during the interval.</span>
<span class="sd">        max: Maximum of the allowed range for values of function during the interval.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (cumul expression, interval variable, positive integer, positive integer) =&gt; constraint</span>
<span class="sd">     * (cumul expression, integer time, integer time, positive integer, positive integer) =&gt; constraint</span>
<span class="sd">     * (state function, interval variable, positive integer, positive integer) =&gt; constraint</span>
<span class="sd">     * (state function, integer time, integer time, positive integer, positive integer) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_always_in</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="always_no_state"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.always_no_state">[docs]</a><span class="k">def</span> <span class="nf">always_no_state</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This constraint ensures that a state function is undefined on an interval.</span>

<span class="sd">    This function returns a constraint that ensures that *function* is undefined everywhere on the interval (either interval</span>
<span class="sd">    variable *interval* when it is present or fixed interval [*start*,*end*)). This constraint will ensure, in particular,</span>
<span class="sd">    that no interval variable that requires the function to be defined (see *always_equal*, *always_constant*) can overlap</span>
<span class="sd">    with interval variable *interval* or fixed interval [*start*,*end*)).</span>

<span class="sd">    Args:</span>
<span class="sd">        function: Constrained state function.</span>
<span class="sd">        interval: Interval variable during which function is constrained.</span>
<span class="sd">        start: Start of the fixed interval [start,end) during which function is constrained.</span>
<span class="sd">        end: End of the fixed interval [start,end) during which function is constrained.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (state function, interval variable) =&gt; constraint</span>
<span class="sd">     * (state function, integer time, integer time) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_always_no_state</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="before"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.before">[docs]</a><span class="k">def</span> <span class="nf">before</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains an interval variable to be before another interval variable in a sequence.</span>

<span class="sd">    This function returns a constraint that states that whenever both interval variables *interval1* and *interval2* are</span>
<span class="sd">    present,</span>
<span class="sd">    *interval1* must be ordered before *interval2* in the sequence variable *sequence*.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval1: First interval variables.</span>
<span class="sd">        interval2: Second interval variables.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, interval variable) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_before</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="bool_abstraction"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.bool_abstraction">[docs]</a><span class="k">def</span> <span class="nf">bool_abstraction</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a constraint that abstracts the values of one array as Boolean values in another array.</span>

<span class="sd">    This function creates and returns a constraint that abstracts an array</span>
<span class="sd">    of integer expressions in a model. It differs from *abstraction* in</span>
<span class="sd">    that elements each *y[i]* is Boolean.</span>
<span class="sd">    </span>
<span class="sd">    Like *abstraction*, for each element *x[i]* there is an expression *y[i]*</span>
<span class="sd">    corresponding to the abstraction of *x[i]* with respect to the</span>
<span class="sd">    *values* array. That is,</span>
<span class="sd">     * *x[i] = v* with *v* in *values* if and only if *y[i] = true()*</span>
<span class="sd">     * *x[i] = v* with *v* not in *values* if and only if *y[i] = false()*</span>
<span class="sd">    </span>
<span class="sd">    This constraint maintains a many-to-one mapping that makes it possible</span>
<span class="sd">    to define constraints that impinge only on a particular set of values</span>
<span class="sd">    from the domains of constrained variables.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: An array of abstracted integer expressions.</span>
<span class="sd">        x: An array of reference integer expressions.</span>
<span class="sd">        values: An array of integer values to abstract.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, array of integer expressions, array of integers) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_bool_abstraction</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="constant"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.constant">[docs]</a><span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *constant*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer constant) =&gt; integer constant</span>
<span class="sd">     * (float constant) =&gt; float constant</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float constant or integer constant</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_constant</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordinate_piecewise_linear"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.coordinate_piecewise_linear">[docs]</a><span class="k">def</span> <span class="nf">coordinate_piecewise_linear</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *coordinatePiecewiseLinear*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float expression, float constant, array of floats, array of floats, float constant) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_coordinate_piecewise_linear</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="count"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.count">[docs]</a><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the number of occurrences of a given value found in a given integer expression array.</span>

<span class="sd">    This expression counts how many of the expressions in *exprs* take the value *v*.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs: An array of integer expressions.</span>
<span class="sd">        v: The value for which occurrences must be counted.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, integer constant) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_count</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="count_different"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.count_different">[docs]</a><span class="k">def</span> <span class="nf">count_different</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *countDifferent*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_count_different</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="cumul_range"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.cumul_range">[docs]</a><span class="k">def</span> <span class="nf">cumul_range</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Limits the range of a cumul function expression.</span>

<span class="sd">    This function returns a constraint that restricts the possible values of cumul *function* to belong to a range</span>
<span class="sd">    [*min*,*max*].</span>

<span class="sd">    Args:</span>
<span class="sd">        function: Cumul function expression.</span>
<span class="sd">        min: Minimum of the range of allowed values for the cumul function.</span>
<span class="sd">        max: Maximum of the range of allowed values for the cumul function.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (cumul expression, integer expression, integer expression) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_cumul_range</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="diff"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.diff">[docs]</a><span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *diff*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; boolean expression</span>
<span class="sd">     * (float expression, float expression) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_diff</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="distribute"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.distribute">[docs]</a><span class="k">def</span> <span class="nf">distribute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculates and/or constrains the distribution of values taken by an array</span>
<span class="sd">    of integer expressions.</span>

<span class="sd">    The *distribute* constraint is used to count the number of occurrences of</span>
<span class="sd">    several values in an array of constrained expressions. You can also</span>
<span class="sd">    use *distribute* to force a set of constrained expressions to assume</span>
<span class="sd">    values in such a way that only a limited number of the constrained</span>
<span class="sd">    expressions can assume each value.</span>
<span class="sd">    </span>
<span class="sd">    More precisely, for any index *i* of *counts*, *counts[i]* is equal to</span>
<span class="sd">    the number of expressions in *exprs* who have value of *values[i]*.</span>
<span class="sd">    When using the signature which has *values* missing, then the values</span>
<span class="sd">    counted are assumed to be a set spanning from 0 up to the size of the</span>
<span class="sd">    *counts* array, less one.</span>

<span class="sd">    Args:</span>
<span class="sd">        counts: An array of integer expressions representing, for each element of values, its cardinality in exprs.</span>
<span class="sd">        values: An integer array containing values to count.</span>
<span class="sd">        exprs: An array of integer expressions for which value occurrences must be counted.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, array of integers, array of integer expressions) =&gt; constraint</span>
<span class="sd">     * (array of integer expressions, array of integer expressions) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_distribute</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="domain_max"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.domain_max">[docs]</a><span class="k">def</span> <span class="nf">domain_max</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *domainMax*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; evaluator of integer variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_domain_max</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="domain_min"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.domain_min">[docs]</a><span class="k">def</span> <span class="nf">domain_min</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *domainMin*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; evaluator of integer variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_domain_min</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="domain_size"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.domain_size">[docs]</a><span class="k">def</span> <span class="nf">domain_size</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *domainSize*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; evaluator of integer variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_domain_size</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="element"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.element">[docs]</a><span class="k">def</span> <span class="nf">element</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function returns an element of a given array indexed by an</span>
<span class="sd">    integer expression for use in a constraint or another expression.</span>

<span class="sd">    This function returns an expression for use in a constraint or other</span>
<span class="sd">    expression. The semantics of this expression are: when *subscript*</span>
<span class="sd">    takes the value *i*, then the value of the expression is equal to</span>
<span class="sd">    *array[i]*.</span>

<span class="sd">    Args:</span>
<span class="sd">        subscript: An integer expression used to subscript the array.</span>
<span class="sd">        array: An array in which an element will be selected using subscript.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, array of integers) =&gt; integer expression</span>
<span class="sd">     * (integer expression, array of integer expressions) =&gt; integer expression</span>
<span class="sd">     * (integer expression, array of floats) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_element</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="end_at_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_at_end">[docs]</a><span class="k">def</span> <span class="nf">end_at_end</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the delay between the ends of two interval variables.</span>

<span class="sd">    The function *end_at_end* constrains interval variables *a* and *b* in the</span>
<span class="sd">    following way. If both intervals *a* and *b* are present then interval *b* must</span>
<span class="sd">    end exactly at *end_of(a)+delay*. If *a* or *b* is absent then the</span>
<span class="sd">    constraint is automatically satisfied.</span>
<span class="sd">    </span>
<span class="sd">    The default value for *delay* is zero. Note that *delay* can be negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: Interval variables.</span>
<span class="sd">        b: Interval variables.</span>
<span class="sd">        delay: Exact delay between ends of a and b. If not specified then zero is used.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, interval variable, integer expression [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_end_at_end</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="end_at_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_at_start">[docs]</a><span class="k">def</span> <span class="nf">end_at_start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the delay between the end of one interval variable and start of another one.</span>

<span class="sd">    The function *end_at_start* constrains interval variables *predecessor* and</span>
<span class="sd">    *successor* in the following way. If both intervals *predecessor* and</span>
<span class="sd">    *successor* are present then interval *successor* must start exactly at</span>
<span class="sd">    *end_of(predecessor)+delay*. If *predecessor* or *successor* is absent then the</span>
<span class="sd">    constraint is automatically satisfied.</span>
<span class="sd">    </span>
<span class="sd">    The default value for *delay* is zero. Note that *delay* can be negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        predecessor: Interval variables.</span>
<span class="sd">        successor: Interval variables.</span>
<span class="sd">        delay: Exact delay between end of predecessor and start of successor. If not specified then zero is used.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, interval variable, integer expression [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_end_at_start</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="end_before_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_before_end">[docs]</a><span class="k">def</span> <span class="nf">end_before_end</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the minimum delay between the ends of two interval variables.</span>

<span class="sd">    The function *end_before_end* constrains interval variables *predecessor* and</span>
<span class="sd">    *successor* in the following way. If both interval variables *predecessor* and</span>
<span class="sd">    *successor* are present then *successor* cannot end before</span>
<span class="sd">    *end_of(predecessor)+minDelay*. If *predecessor* or *successor* is absent then</span>
<span class="sd">    the constraint is automatically satisfied.</span>
<span class="sd">    </span>
<span class="sd">    The default value for *minDelay* is zero. It is possible to specify a</span>
<span class="sd">    negative *minDelay*; in this case *successor* can actually end before the end</span>
<span class="sd">    of *predecessor* but still not sooner than *end_of(predecessor)+minDelay*.</span>

<span class="sd">    Args:</span>
<span class="sd">        predecessor: Interval variable which ends before.</span>
<span class="sd">        successor: Interval variable which ends after.</span>
<span class="sd">        minDelay: The minimal delay between end of predecessor and end of successor. If not specified then zero is used.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, interval variable, integer expression [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_end_before_end</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="end_before_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_before_start">[docs]</a><span class="k">def</span> <span class="nf">end_before_start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains minimum delay between the end of one interval variable and start of another one.</span>

<span class="sd">    the function *end_before_start* constrains interval variables *predecessor* and</span>
<span class="sd">    *successor* in the following way. If both interval variables *predecessor* and</span>
<span class="sd">    *successor* are present then *successor* cannot start before</span>
<span class="sd">    *end_of(predecessor)+minDelay*. If *predecessor* or *successor* is absent then</span>
<span class="sd">    the constraint is automatically satisfied.</span>
<span class="sd">    </span>
<span class="sd">    The default value for *minDelay* is zero. It is possible to specify even</span>
<span class="sd">    negative *minDelay*, in this case *successor* can actually start before the end</span>
<span class="sd">    of *predecessor* but still not sooner than *end_of(predecessor)+minDelay*.</span>

<span class="sd">    Args:</span>
<span class="sd">        predecessor: Interval variable which ends before.</span>
<span class="sd">        successor: Interval variable which starts after.</span>
<span class="sd">        minDelay: The minimal delay between end of predecessor and start of successor. If not specified then zero is used.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, interval variable, integer expression [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_end_before_start</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="end_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_eval">[docs]</a><span class="k">def</span> <span class="nf">end_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates *segmentedFunction* at the end of an interval variable.</span>

<span class="sd">    Evaluate *function* at the end of interval variable *interval*. However if *interval*</span>
<span class="sd">    is absent then it does not have any defined end and *absentValue* is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        function: Function to evaluate.</span>
<span class="sd">        absentValue: Value to return if interval variable interval is absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, segmented function, float constant [=0]) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_end_eval</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="end_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_of">[docs]</a><span class="k">def</span> <span class="nf">end_of</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the end of specified interval variable.</span>

<span class="sd">    This function returns an integer expression that is equal to end of the interval</span>
<span class="sd">    variable *interval* if it is present. If it is absent then the value of the</span>
<span class="sd">    expression is *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        absentValue: Value to return if the interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_end_of</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="end_of_next"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_of_next">[docs]</a><span class="k">def</span> <span class="nf">end_of_next</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the end of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the end of the interval variable</span>
<span class="sd">    that is next to *interval* in *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        lastValue: Value to return if interval variable interval is the last one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, integer constant [=0], integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_end_of_next</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="end_of_prev"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.end_of_prev">[docs]</a><span class="k">def</span> <span class="nf">end_of_prev</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the end of the interval variable that is previous.</span>

<span class="sd">    This function returns an integer expression that represents the end of the interval variable</span>
<span class="sd">    that is previous to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the first interval of *sequence*, it returns the constant integer value *firstValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        firstValue: Value to return if interval variable interval is the first one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, integer constant [=0], integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_end_of_prev</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *equal*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; boolean expression</span>
<span class="sd">     * (float expression, float expression) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_equal</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="equal_or_escape"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.equal_or_escape">[docs]</a><span class="k">def</span> <span class="nf">equal_or_escape</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *equalOrEscape*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression, integer constant) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_equal_or_escape</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="exotic_object"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.exotic_object">[docs]</a><span class="k">def</span> <span class="nf">exotic_object</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *exoticObject*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_exotic_object</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="explicit_value_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.explicit_value_eval">[docs]</a><span class="k">def</span> <span class="nf">explicit_value_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *explicitValueEval*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integers, array of floats, float constant [=0]) =&gt; evaluator of integer value</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_explicit_value_eval</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="explicit_var_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.explicit_var_eval">[docs]</a><span class="k">def</span> <span class="nf">explicit_var_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *explicitVarEval*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, array of floats, float constant [=0]) =&gt; evaluator of integer variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_explicit_var_eval</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="exponent"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.exponent">[docs]</a><span class="k">def</span> <span class="nf">exponent</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the exponent of its argument</span>

<span class="sd">    The *exponent* function returns the exponentiation of its argument.</span>

<span class="sd">    Args:</span>
<span class="sd">        floatExpr: A floating point expression.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float expression) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_exponent</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="false"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.false">[docs]</a><span class="k">def</span> <span class="nf">false</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns a false Boolean expression.</span>

<span class="sd">    This function returns a false Boolean expression (*boolExpr*). CP Optimizer</span>
<span class="sd">    usually eliminates *false()* from expressions using partial evaluation.</span>
<span class="sd">    </span>
<span class="sd">    The function *false()* does not have any particular purpose except for being a</span>
<span class="sd">    filler.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_false</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="first"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.first">[docs]</a><span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains an interval variable to be the first in a sequence.</span>

<span class="sd">    This function returns a constraint that states that whenever interval variable *interval* is present,</span>
<span class="sd">    it must be ordered first in the sequence variable *sequence*.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_first</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="float_div"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.float_div">[docs]</a><span class="k">def</span> <span class="nf">float_div</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *floatDiv*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float expression, float expression) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_float_div</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="float_var"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.float_var">[docs]</a><span class="k">def</span> <span class="nf">float_var</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *floatVar*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float constant, float constant) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_float_var</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="forbid_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.forbid_end">[docs]</a><span class="k">def</span> <span class="nf">forbid_end</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Forbids an interval variable to end during specified regions.</span>

<span class="sd">    In the declaration of interval_variable it is only possible to specify</span>
<span class="sd">    a range of possible end times. This function allows the user to specify more</span>
<span class="sd">    precisely when the interval variable can end. In particular, the interval</span>
<span class="sd">    variable can end only at point *t* such that the function has non-zero value at</span>
<span class="sd">    *t-1*. When the interval variable is absent then this constraint is</span>
<span class="sd">    automatically satisfied (since such interval variable does not&#39;t have any start at</span>
<span class="sd">    all).</span>
<span class="sd">    </span>
<span class="sd">    Note the difference between *t* (end time of the interval variable) and *t-1*</span>
<span class="sd">    (the point when the function value is checked). It simplifies the sharing of the</span>
<span class="sd">    same function in constraints *forbid_start* and *forbid_end*. It also allows one to</span>
<span class="sd">    use the same function as *intensity* parameter of</span>
<span class="sd">    interval_variable.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable being restricted.</span>
<span class="sd">        function: If the function has value 0 at point t-1 then the interval variable interval cannot end at t.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, step function) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_forbid_end</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="forbid_extent"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.forbid_extent">[docs]</a><span class="k">def</span> <span class="nf">forbid_extent</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Forbids an interval variable to overlap with specified regions.</span>

<span class="sd">    This function allows specification of forbidden regions that the interval variable</span>
<span class="sd">    *interval* cannot overlap with. In particular, if interval variable *interval* is present and</span>
<span class="sd">    if *function* has value 0 during interval *[a,b)* (i.e. *[a,b)* is a</span>
<span class="sd">    forbidden region) then either *end &lt;= a* (*interval* ends before the</span>
<span class="sd">    forbidden region) or *b &lt;= start* (*interval* starts after the forbidden</span>
<span class="sd">    region).</span>
<span class="sd">    </span>
<span class="sd">    If the interval variable *interval* is absent then the constraint is automatically</span>
<span class="sd">    satisfied (the interval does not exist therefore it cannot overlap with any</span>
<span class="sd">    region).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable being restricted.</span>
<span class="sd">        function: Forbidden regions corresponds to step of the function that have value 0.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, step function) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_forbid_extent</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="forbid_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.forbid_start">[docs]</a><span class="k">def</span> <span class="nf">forbid_start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Forbids an interval variable to start during specified regions.</span>

<span class="sd">    This constraint restricts possible start times of interval variable using a</span>
<span class="sd">    step function. The interval variable can start only at points where the</span>
<span class="sd">    function value is not zero. When the interval variable is absent then this</span>
<span class="sd">    constraint is automatically satisfied (since such interval variable does not</span>
<span class="sd">    have any start at all).</span>
<span class="sd">    </span>
<span class="sd">    In declaration of interval_variable it is only possible to specify</span>
<span class="sd">    a range of possible start times. This function allows more</span>
<span class="sd">    precise specification of when the interval variable can start.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable being restricted.</span>
<span class="sd">        function: If the function has value 0 at point t then the interval variable interval cannot start at t.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, step function) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_forbid_start</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="forbidden_assignments"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.forbidden_assignments">[docs]</a><span class="k">def</span> <span class="nf">forbidden_assignments</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Explicitly defines forbidden assignments for one or more integer expressions.</span>

<span class="sd">    This function can be used to define simple constraints based</span>
<span class="sd">    on explicitly giving the forbidden assignments for a single expression or</span>
<span class="sd">    a small group of expressions.  The function returns a Boolean expression</span>
<span class="sd">    that represents the truth value of the statement: the values of the</span>
<span class="sd">    variables *exprs* is a combination not present in *tuples*.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    This Boolean expression (which is interpreted as a constraint outside of</span>
<span class="sd">    an expression) determines whether the assignment to a single expression *expr*</span>
<span class="sd">    or to an array of expressions *exprs* is not contained within the value set</span>
<span class="sd">    *values* or the tuple set *tuples* respectively.  The Boolean expression</span>
<span class="sd">    will be true if and only if (depending on the signature):</span>
<span class="sd">     * the value of the expression *expr* is not present in the array *values*.</span>
<span class="sd">     * the values of the expressions *exprs* are not present in the tuple set *tuples*.</span>
<span class="sd">    </span>
<span class="sd">    The order of the constrained variables in the array *exprs* is</span>
<span class="sd">    important because the same order is respected in the tuple set *tuples*.</span>

<span class="sd">    Args:</span>
<span class="sd">        expr: An integer expression.</span>
<span class="sd">        values: An integer array defining forbidden values of expr.</span>
<span class="sd">        exprs: An array of integer expressions.</span>
<span class="sd">        tuples: Specifies the combinations of forbidden values of the expressions exprs.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, array of integers) =&gt; boolean expression</span>
<span class="sd">     * (array of integer expressions, set of tuples) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_forbidden_assignments</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="greater"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.greater">[docs]</a><span class="k">def</span> <span class="nf">greater</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *greater*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; boolean expression</span>
<span class="sd">     * (float expression, float expression) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_greater</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="greater_or_equal"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.greater_or_equal">[docs]</a><span class="k">def</span> <span class="nf">greater_or_equal</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *greaterOrEqual*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; boolean expression</span>
<span class="sd">     * (float expression, float expression) =&gt; boolean expression</span>
<span class="sd">     * (positive integer, cumul expression) =&gt; constraint</span>
<span class="sd">     * (cumul expression, positive integer) =&gt; constraint</span>
<span class="sd">     * (cumul expression, integer expression) =&gt; constraint</span>
<span class="sd">     * (integer expression, cumul expression) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression or constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_greater_or_equal</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="height_at_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.height_at_end">[docs]</a><span class="k">def</span> <span class="nf">height_at_end</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the contribution of an interval variable to a cumul function at its end point.</span>

<span class="sd">    Whenever interval variable *interval* is present, this function returns an integer expression that represents the total</span>
<span class="sd">    contribution of the end of interval variable *interval* to the cumul *function*. When interval variable *interval* is</span>
<span class="sd">    absent, this function returns a constant integer expression equal to *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        function: Cumul function expression.</span>
<span class="sd">        absentValue: Value to return if the interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, cumul expression, integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_height_at_end</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="height_at_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.height_at_start">[docs]</a><span class="k">def</span> <span class="nf">height_at_start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the contribution of an interval variable to a cumul function at its start point.</span>

<span class="sd">    Whenever interval variable *interval* is present, this function returns an integer expression that represents the total</span>
<span class="sd">    contribution of the start of interval variable *interval* to the cumul *function*. When interval variable *interval* is</span>
<span class="sd">    absent, this function returns a constant integer expression equal to *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        function: Cumul function expression.</span>
<span class="sd">        absentValue: Value to return if the interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, cumul expression, integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_height_at_start</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="if_then"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.if_then">[docs]</a><span class="k">def</span> <span class="nf">if_then</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *ifThen*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (boolean expression, boolean expression) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_if_then</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="impact_of_last_branch"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.impact_of_last_branch">[docs]</a><span class="k">def</span> <span class="nf">impact_of_last_branch</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *impactOfLastBranch*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; evaluator of integer variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_impact_of_last_branch</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="int_div"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.int_div">[docs]</a><span class="k">def</span> <span class="nf">int_div</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *intDiv*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_int_div</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="inverse"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.inverse">[docs]</a><span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains elements of one array to be inverses of another.</span>

<span class="sd">    This function creates an inverse constraint such that if the length of</span>
<span class="sd">    the arrays *f* and *invf* is *n*, then this function returns a</span>
<span class="sd">    constraint that ensures that:</span>
<span class="sd">     * for all *i* in the interval *[0, n-1]*, *invf[f[i* == i*</span>
<span class="sd">     * for all *j* in the interval *[0, n-1]*, *f[invf[j* == j*</span>

<span class="sd">    Args:</span>
<span class="sd">        f: An integer expression array.</span>
<span class="sd">        invf: An integer expression array.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, array of integer expressions) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_inverse</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="isomorphism"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.isomorphism">[docs]</a><span class="k">def</span> <span class="nf">isomorphism</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an isomorphism constraint between two sets of interval variables.</span>

<span class="sd">    This function creates an isomorphism constraint between the set of interval variables in the array *array1* and the set</span>
<span class="sd">    of interval variables in the array *array2*. If an integer expression array *map* is used, it is used to reflect the</span>
<span class="sd">    mapping of the intervals of *array1* on the intervals of *array2*, that is, interval variable *array2[i]*, if present,</span>
<span class="sd">    is mapped on interval variable *array1[map[i**. If *array2[i]* is absent, index *map[i]* takes value *absentValue*.</span>

<span class="sd">    Args:</span>
<span class="sd">        array1: The first isomorphic sets of interval variables.</span>
<span class="sd">        array1: The second isomorphic sets of interval variables.</span>
<span class="sd">        map: Array of integer expressions mapping intervals of array2 on array1.</span>
<span class="sd">        absentValue: Value of map[i] when array2[i] is absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of interval variables, array of interval variables, array of integer expressions [=0], integer constant [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_isomorphism</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="last"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.last">[docs]</a><span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains an interval variable to be the last in a sequence.</span>

<span class="sd">    This function returns a constraint that states that whenever interval variable *interval* is present,</span>
<span class="sd">    it must be ordered last in the sequence variable *sequence*.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_last</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="length_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.length_eval">[docs]</a><span class="k">def</span> <span class="nf">length_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates *segmentedFunction* using the length of an interval variable.</span>

<span class="sd">    Evaluate *function* for the x value equal to the length of interval variable *interval*. If *interval* is absent then it</span>
<span class="sd">    does not have any defined length and *absentValue* is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        function: Function to evaluate.</span>
<span class="sd">        absentValue: Value to return if interval variable interval is absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, segmented function, float constant [=0]) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_length_eval</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="length_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.length_of">[docs]</a><span class="k">def</span> <span class="nf">length_of</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the length of specified interval variable.</span>

<span class="sd">    This function returns an integer expression that is equal to the length (*end -</span>
<span class="sd">    start*) of the interval variable *interval* if it is present. If it is absent, then</span>
<span class="sd">    the value of the expression is *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        absentValue: Value to return if the interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_length_of</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="length_of_next"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.length_of_next">[docs]</a><span class="k">def</span> <span class="nf">length_of_next</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the length of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the length of the interval variable</span>
<span class="sd">    that is next to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        lastValue: Value to return if interval variable interval is the last one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, integer constant [=0], integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_length_of_next</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="length_of_prev"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.length_of_prev">[docs]</a><span class="k">def</span> <span class="nf">length_of_prev</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the length of the interval variable that is previous.</span>

<span class="sd">    This function returns an integer expression that represents the length of the interval variable</span>
<span class="sd">    that is previous to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the first interval of *sequence*, it returns the constant integer value *firstValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        firstValue: Value to return if interval variable interval is the first one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, integer constant [=0], integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_length_of_prev</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="less"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.less">[docs]</a><span class="k">def</span> <span class="nf">less</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *less*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; boolean expression</span>
<span class="sd">     * (float expression, float expression) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_less</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="less_or_equal"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.less_or_equal">[docs]</a><span class="k">def</span> <span class="nf">less_or_equal</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *lessOrEqual*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; boolean expression</span>
<span class="sd">     * (float expression, float expression) =&gt; boolean expression</span>
<span class="sd">     * (cumul expression, positive integer) =&gt; constraint</span>
<span class="sd">     * (positive integer, cumul expression) =&gt; constraint</span>
<span class="sd">     * (cumul expression, integer expression) =&gt; constraint</span>
<span class="sd">     * (integer expression, cumul expression) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression or constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_less_or_equal</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="lexicographic"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.lexicographic">[docs]</a><span class="k">def</span> <span class="nf">lexicographic</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns a constraint which maintains two arrays to be lexicographically ordered.</span>

<span class="sd">    The *lexicographic* function returns a constraint which</span>
<span class="sd">    maintains two arrays to be lexicographically ordered.</span>
<span class="sd">    </span>
<span class="sd">    More specifically, *lexicographic(x, y)* maintains that *x* is less</span>
<span class="sd">    than or equal to *y* in the lexicographical sense of the term. This</span>
<span class="sd">    means that either both arrays are equal or that there exists *i &lt;</span>
<span class="sd">    size(x)* such that for all *j &lt; i*, *x[j] = y[j]* and *x[i] &lt; y[i]*.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array of integer expressions.</span>
<span class="sd">        y: An array of integer expressions.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, array of integer expressions) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_lexicographic</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="log"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.log">[docs]</a><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the logarithm of the input.</span>

<span class="sd">    The function *log* computes the logarithm of *x*.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: A floating-point expression.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float expression) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_log</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="logical_and"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.logical_and">[docs]</a><span class="k">def</span> <span class="nf">logical_and</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *and*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (boolean expression, boolean expression) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_logical_and</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="logical_not"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.logical_not">[docs]</a><span class="k">def</span> <span class="nf">logical_not</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *not*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (boolean expression) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_logical_not</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="logical_or"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.logical_or">[docs]</a><span class="k">def</span> <span class="nf">logical_or</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *or*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (boolean expression, boolean expression) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_logical_or</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="max"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.max">[docs]</a><span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Computes the maximum of a pair or array of integer or floating-point expressions.</span>

<span class="sd">    The *max* function returns an expression which has the same value as the</span>
<span class="sd">    maximum of the supplied arguments.  The return type corresponds to the</span>
<span class="sd">    type of arguments supplied.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: An array of integer or floating-point expressions from which the maximum is to be computed.</span>
<span class="sd">        x: First integer or floating-point expressions from which the maximum is to be computed.</span>
<span class="sd">        y: Second integer or floating-point expressions from which the maximum is to be computed.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; integer expression</span>
<span class="sd">     * (array of integer expressions) =&gt; integer expression</span>
<span class="sd">     * (float expression, float expression) =&gt; float expression</span>
<span class="sd">     * (array of float expressions) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">_expand</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">_no_cpo_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">builtin</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_max</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="maximize"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.maximize">[docs]</a><span class="k">def</span> <span class="nf">maximize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A function to specify an optimization problem.  It asks CP Optimizer to</span>
<span class="sd">    seek to maximize the value of an expression.</span>

<span class="sd">    The function *maximize* specifies to CP Optimizer a floating-point expression</span>
<span class="sd">    whose value is sought to be maximized.  When this function is used and</span>
<span class="sd">    the problem is feasible, CP Optimizer will generate</span>
<span class="sd">    one or more feasible solutions to the problem, with subsequent solutions having</span>
<span class="sd">    a larger value of *expr* than preceding ones.  The search terminates when</span>
<span class="sd">    either the optimality of the last solution is proved, a search limit is</span>
<span class="sd">    exhausted, or the search is aborted.</span>

<span class="sd">    Args:</span>
<span class="sd">        expr: The expression whose value is to be maximized.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float expression) =&gt; objective</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type objective</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_maximize</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="maximize_static_lex"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.maximize_static_lex">[docs]</a><span class="k">def</span> <span class="nf">maximize_static_lex</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A function to specify an optimization problem.  It asks CP Optimizer to</span>
<span class="sd">    seek to lexicographically maximize the values of a number of expressions.</span>

<span class="sd">    The function *maximize_static_lex* specifies to CP Optimizer a number of</span>
<span class="sd">    floating-point expressions whose values are sought to be maximized in a</span>
<span class="sd">    lexicographic fashion.  When this function is used and</span>
<span class="sd">    the problem is feasible, CP Optimizer will generate one or more</span>
<span class="sd">    feasible solutions to the problem, with subsequent solutions having</span>
<span class="sd">    a lexicographically larger value of *exprs* than preceding ones.</span>
<span class="sd">    This means that a new solution replaces the preceding one as incumbent if</span>
<span class="sd">    the value of criterion *exprs[i]* is greater than in the preceding solution,</span>
<span class="sd">    so long as the values of criteria *exprs[0..i-1]* are not less than in the</span>
<span class="sd">    preceding solution.  In particular, this means that the newer solution is</span>
<span class="sd">    preferable even if there are arbitrary reductions in the values of criteria</span>
<span class="sd">    after position *i* in *exprs*, as compared with the preceding solution.</span>
<span class="sd">    The search terminates when either the optimality of the last solution</span>
<span class="sd">    is proved, a search limit is exhausted, or the search is aborted.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs: An array of floating-point expressions whose values are to be lexicographically maximized.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of float expressions) =&gt; objective</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type objective</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_maximize_static_lex</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="min"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.min">[docs]</a><span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Computes the minimum of a pair or array of integer or floating-point expressions.</span>

<span class="sd">    The *min* function returns an expression which has the same value as the</span>
<span class="sd">    minimum of the supplied arguments.  The return type corresponds to the</span>
<span class="sd">    type of arguments supplied.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: An array of integer or floating-point expressions from which the minimum is to be computed.</span>
<span class="sd">        x: First integer or floating-point expressions from which the minimum is to be computed.</span>
<span class="sd">        y: Second integer or floating-point expressions from which the minimum is to be computed.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; integer expression</span>
<span class="sd">     * (array of integer expressions) =&gt; integer expression</span>
<span class="sd">     * (float expression, float expression) =&gt; float expression</span>
<span class="sd">     * (array of float expressions) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">_expand</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">_no_cpo_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">builtin</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_min</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="minimize"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.minimize">[docs]</a><span class="k">def</span> <span class="nf">minimize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A function to specify an optimization problem.  It asks CP Optimizer to</span>
<span class="sd">    seek to minimize the value of an expression.</span>

<span class="sd">    The function *minimize* specifies to CP Optimizer a floating-point expression</span>
<span class="sd">    whose value is sought to be minimized.  When this function is used and</span>
<span class="sd">    the problem is feasible, CP Optimizer will generate</span>
<span class="sd">    one or more feasible solutions to the problem, with subsequent solutions having</span>
<span class="sd">    a smaller value of *expr* than preceding ones.  The search terminates when</span>
<span class="sd">    either the optimality of the last solution is proved, a search limit is</span>
<span class="sd">    exhausted, or the search is aborted.</span>

<span class="sd">    Args:</span>
<span class="sd">        expr: The expression whose value is to be minimized.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float expression) =&gt; objective</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type objective</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_minimize</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="minimize_static_lex"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.minimize_static_lex">[docs]</a><span class="k">def</span> <span class="nf">minimize_static_lex</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A function to specify an optimization problem.  It asks CP Optimizer to</span>
<span class="sd">    seek to lexicographically minimize the values of a number of expressions.</span>

<span class="sd">    The function *minimize_static_lex* specifies to CP Optimizer a number of</span>
<span class="sd">    floating-point expressions whose values are sought to be minimized in a</span>
<span class="sd">    lexicographic fashion.  When this function is used and</span>
<span class="sd">    the problem is feasible, CP Optimizer will generate</span>
<span class="sd">    one or more feasible solutions to the problem, with subsequent solutions having</span>
<span class="sd">    a lexicographically smaller value of *exprs* than preceding ones.</span>
<span class="sd">    This means that a new solution replaces the preceding one as incumbent if</span>
<span class="sd">    the value of criterion *exprs[i]* is less than in the preceding solution,</span>
<span class="sd">    so long as the values of criteria *exprs[0..i-1]* are not greater than in the</span>
<span class="sd">    preceding solution.  In particular, this means that the newer solution is</span>
<span class="sd">    preferable even if there are arbitrary increases in the values of criteria</span>
<span class="sd">    after position *i* in *exprs*, as compared with the preceding solution.</span>
<span class="sd">    The search terminates when either the optimality of the last solution</span>
<span class="sd">    is proved, a search limit is exhausted, or the search is aborted.</span>

<span class="sd">    Args:</span>
<span class="sd">        exprs: An array of floating-point expressions whose values are to be lexicographically minimized.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of float expressions) =&gt; objective</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type objective</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_minimize_static_lex</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="minus"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.minus">[docs]</a><span class="k">def</span> <span class="nf">minus</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *minus*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; integer expression</span>
<span class="sd">     * (integer expression) =&gt; integer expression</span>
<span class="sd">     * (float expression, float expression) =&gt; float expression</span>
<span class="sd">     * (float expression) =&gt; float expression</span>
<span class="sd">     * (cumul expression, cumul expression) =&gt; cumul expression</span>
<span class="sd">     * (cumul expression) =&gt; cumul expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type cumul expression, float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_minus</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="mod"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.mod">[docs]</a><span class="k">def</span> <span class="nf">mod</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *mod*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_mod</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="no_overlap"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.no_overlap">[docs]</a><span class="k">def</span> <span class="nf">no_overlap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains a set of interval variables not to overlap each others.</span>

<span class="sd">    This function returns a constraint over a set of interval variables {*a1*, ..., *an*} that states that all the present</span>
<span class="sd">    intervals in the set are pairwise non-overlapping. It means that whenever both interval variables *ai* and *aj*, i!=j</span>
<span class="sd">    are present, *ai* is constrained to end before the start of *aj* or *aj* is constrained to end before the start of *ai*.</span>
<span class="sd">    </span>
<span class="sd">    If the no-overlap constraint has been built on an interval sequence variable *sequence*, it means that the no-overlap</span>
<span class="sd">    constraint works on the set of interval variables {*a1*, ..., *an*} of the sequence and that the order of interval</span>
<span class="sd">    variables of the sequence will describe the order of the non-overlapping intervals. That is, if *ai* and *aj*, i!=j are</span>
<span class="sd">    both present and if *ai* appears before *aj* in the sequence value, then *ai* is constrained to end before the start of</span>
<span class="sd">    *aj*. If a transition matrix *distanceMatrix* is specified and if *tpi* and *tpj* respectively denote the types of</span>
<span class="sd">    interval variables *ai* and *aj* in the *sequence*, it means that a minimal distance *distanceMatrix[tpi,tpj]* is to be</span>
<span class="sd">    maintained between the end of *ai* and the start of *aj*. If Boolean flag *isDirect* is true, the transition distance</span>
<span class="sd">    holds between an interval and its immediate successor in the sequence otherwise, if *isDirect* is false (default), the</span>
<span class="sd">    transition distance holds between an interval and all its successors in the sequence.</span>

<span class="sd">    Args:</span>
<span class="sd">        intervals: An array of interval variables.</span>
<span class="sd">        sequence: A sequence variable.</span>
<span class="sd">        distanceMatrix: An optional transition matrix defining the transition distance between consecutive interval variables.</span>
<span class="sd">        isDirect: A Boolean flag stating whether the distance specified in the transition matrix distanceMatrix holds between direct successors (isDirect=1) or also between indirect successors (isDirect=0, default).</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, transition matrix [=0], boolean integer (0, 1) [=0]) =&gt; constraint</span>
<span class="sd">     * (array of interval variables) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_no_overlap</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="overlap_length"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.overlap_length">[docs]</a><span class="k">def</span> <span class="nf">overlap_length</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the length of the overlap of two interval variables.</span>

<span class="sd">    The first function returns an integer expression that represents the length of the overlap of interval variable</span>
<span class="sd">    *interval1* and the interval variable *interval2* whenever the interval variables *interval1* and *interval2* are</span>
<span class="sd">    present. When one of the interval variables *interval1* or *interval2* is absent, the function returns the constant</span>
<span class="sd">    integer value *absentValue* (zero by default).</span>
<span class="sd">    </span>
<span class="sd">    The second function returns an integer expression that represents the length of the overlap of interval variable</span>
<span class="sd">    *interval* and the constant interval [*start*, *end*) whenever the interval variable *interval* is present. When the</span>
<span class="sd">    interval variable *interval* is absent, the function returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        interval1: Interval variable.</span>
<span class="sd">        interval2: Interval variable.</span>
<span class="sd">        start: Start value of a fixed interval.</span>
<span class="sd">        end: End value of a fixed interval.</span>
<span class="sd">        absentValue: Value to return if some interval variable is absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, interval variable, integer constant [=0]) =&gt; integer expression</span>
<span class="sd">     * (interval variable, integer time, integer time, integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_overlap_length</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="pack"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.pack">[docs]</a><span class="k">def</span> <span class="nf">pack</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Maintains the load on a set of containers given objects sizes and assignments.</span>

<span class="sd">    The *pack* constraint is used to represent sub-problems where the requirement</span>
<span class="sd">    is to assign objects to containers such that the capacities or minimum fill levels of the containers are respected. </span>
<span class="sd">    Let&#39;s assume we have *n* objects</span>
<span class="sd">    and *m* containers.  The sizes of the array arguments of *pack* must correspond</span>
<span class="sd">    to these constants.  That is, *load* must be of size *m*, whereas *where*</span>
<span class="sd">    and *size* must be of size *n*.</span>
<span class="sd">    Given assignments to the *where* expressions,</span>
<span class="sd">    the *pack* constraint will calculate the values of the *load* and *used*</span>
<span class="sd">    expressions.</span>
<span class="sd">    </span>
<span class="sd">    All counting is done from 0, and so</span>
<span class="sd">    the interpretation of 5 being assigned to *where[3]* is that object 3</span>
<span class="sd">    (the 4th object) is placed into container 5 (the 6th container). This will be</span>
<span class="sd">    reflected by the inclusion of the size of object 3 (*size[3]*) being</span>
<span class="sd">    included in the calculation of the value of *load[5]*.</span>
<span class="sd">    </span>
<span class="sd">    Naturally, all the arguments (with the exception of *size*) can</span>
<span class="sd">    be constrained by additional constraints.  The most common form is to limit</span>
<span class="sd">    the capacity of a container.  For example, to limit container 2</span>
<span class="sd">    to a capacity of 15, one would write *load[2] &lt;= 15*.  Minimum fill level</span>
<span class="sd">    requirements can also be specified this way: for example *load[2] &gt;= 12*.</span>
<span class="sd">    Other more esoteric constraints are possible, for example to say that only</span>
<span class="sd">    an even number of containers can be used: *(used % 2) == 0*.  If *used*</span>
<span class="sd">    is omitted from the signature, then it will not be possible to specifically</span>
<span class="sd">    constrain the number of containers used.</span>

<span class="sd">    Args:</span>
<span class="sd">        load: An array of integer expressions, each element representing the load (total size of the objects inside) the corresponding container.</span>
<span class="sd">        where: An array of integer expressions, each element representing in which container the corresponding object is placed.</span>
<span class="sd">        size: An array of integers, each element representing the size of the corresponding object.</span>
<span class="sd">        used: (optional) An integer expression indicating the number of used containers.  That is, the number of containers with at least one object inside.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, array of integer expressions, array of integers, integer expression [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_pack</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="plus"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.plus">[docs]</a><span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *plus*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; integer expression</span>
<span class="sd">     * (float expression, float expression) =&gt; float expression</span>
<span class="sd">     * (cumul expression, cumul expression) =&gt; cumul expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type cumul expression, float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_plus</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="power"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.power">[docs]</a><span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *power*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float expression, float expression) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_power</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="presence_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.presence_of">[docs]</a><span class="k">def</span> <span class="nf">presence_of</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the presence status of specified interval variable.</span>

<span class="sd">    This function returns the Boolean expression that represents the presence status of</span>
<span class="sd">    the interval variable *interval*. If *interval* is present then the value of the expression</span>
<span class="sd">    is 1; if *interval* is absent then the value is 0.</span>
<span class="sd">    </span>
<span class="sd">    Use *presence_of* to express logical relationships between interval variables.</span>
<span class="sd">    Note that the most effective are binary relations such as</span>
<span class="sd">    *presence_of(x)=&gt;presence_of(y)* because CP Optimizer is able to take them into</span>
<span class="sd">    account during propagation of other constraints such as *end_before_start* or *no_overlap*.</span>
<span class="sd">    </span>
<span class="sd">    The function *presence_of* can be also used to compute cost associated with</span>
<span class="sd">    execution/non-execution of an interval.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_presence_of</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="previous"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.previous">[docs]</a><span class="k">def</span> <span class="nf">previous</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains an interval variable to be previous to another interval variable in a sequence.</span>

<span class="sd">    This function returns a constraint that states that whenever both interval variables *interval1* and *interval2* are</span>
<span class="sd">    present,</span>
<span class="sd">    *interval1* must be the interval variable that is previous to *interval2* in the sequence variable *sequence*.</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval1: Interval variable.</span>
<span class="sd">        interval2: Interval variable.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, interval variable) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_previous</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="pulse"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.pulse">[docs]</a><span class="k">def</span> <span class="nf">pulse</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an elementary cumul function of constant value between the start and the end of an interval.</span>

<span class="sd">    This function returns an elementary cumul function expression that is equal to a value *h* everywhere between the start</span>
<span class="sd">    and the end of an interval variable *interval* or a fixed interval [*start*,*end*). The function is equal to 0 outside</span>
<span class="sd">    of the interval. When interval variable *interval* is absent, the function is the constant zero function. When a range</span>
<span class="sd">    [*heightMin*, *heightMax*) is specified it means that the height value *h* of the pulse is part of the decisions of the</span>
<span class="sd">    problem and will be fixed by the engine within this specified range.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable contributing to the cumul function.</span>
<span class="sd">        h: Non-negative integer representing the height of the contribution.</span>
<span class="sd">        heightMin: Non-negative integer representing the minimum of the range of possible values for the height of the contribution.</span>
<span class="sd">        heightMax: Non-negative integer representing the maximum of the range of possible values for the height of the contribution.</span>
<span class="sd">        start: Start of the fixed interval [start,end) contributing to the cumul function.</span>
<span class="sd">        end: End of the fixed interval [start,end) contributing to the cumul function.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer time, integer time, positive integer) =&gt; cumul atom</span>
<span class="sd">     * (interval variable, positive integer) =&gt; cumul atom</span>
<span class="sd">     * (interval variable, positive integer, positive integer) =&gt; cumul atom</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type cumul atom</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_pulse</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="range"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.range">[docs]</a><span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Restricts the bounds of an integer or floating-point expression.</span>

<span class="sd">    This Boolean expression (which is interpreted as a constraint outside of</span>
<span class="sd">    an expression) determines whether the value of expression *x* is</span>
<span class="sd">    inside the range *[lb, ub]*.  The returned expression will be true if and</span>
<span class="sd">    only if *x* is no less than *lb* and no greater than *ub*.</span>
<span class="sd">    *range(y, a, b)* is also a more efficient form of</span>
<span class="sd">    writing *a &lt;= y &amp;&amp; y &lt;= b*.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: The integer or floating-point expression.</span>
<span class="sd">        lb: The lower bound.</span>
<span class="sd">        ub: The upper bound.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, float constant, float constant) =&gt; boolean expression</span>
<span class="sd">     * (float expression, float constant, float constant) =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">_expand</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">_no_cpo_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">builtin</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_range</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="same_common_subsequence"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.same_common_subsequence">[docs]</a><span class="k">def</span> <span class="nf">same_common_subsequence</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function creates a same-common-subsequence constraint between two sequence variables.</span>

<span class="sd">    This function creates a same-common-subsequence constraint between sequence variables *seq1* and *seq2*.</span>
<span class="sd">    </span>
<span class="sd">    If no interval variable array is specified as argument, the sequence variables *seq1* and *seq2* should be of the same</span>
<span class="sd">    size and the mapping between interval variables of the two sequences is given by the order of the interval variables in</span>
<span class="sd">    the arrays *array1* and *array2* used in the definition of the sequences.</span>
<span class="sd">    </span>
<span class="sd">    If interval variable arrays *array1* and *array2* are used, these arrays define the mapping between interval variables</span>
<span class="sd">    of the two sequences.</span>
<span class="sd">    </span>
<span class="sd">    The constraint states that the sub-sequences defined by *seq1* and *seq2* by only considering the pairs of present</span>
<span class="sd">    intervals (*array1[i]*,*array2[i]*) are identical modulo the mapping between intervals *array1[i]* and *array2[i]*.</span>

<span class="sd">    Args:</span>
<span class="sd">        seq1: First constrained sequence variables.</span>
<span class="sd">        seq2: Second constrained sequence variables.</span>
<span class="sd">        array1: First array of interval variables defining the mapping between the two sequence variables.</span>
<span class="sd">        array2: Second array of interval variables defining the mapping between the two sequence variables.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, sequence variable) =&gt; constraint</span>
<span class="sd">     * (sequence variable, sequence variable, array of interval variables, array of interval variables) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_same_common_subsequence</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="same_sequence"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.same_sequence">[docs]</a><span class="k">def</span> <span class="nf">same_sequence</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function creates a same-sequence constraint between two sequence variables.</span>

<span class="sd">    This function creates a same-sequence constraint between sequence variables *seq1 and seq2*. Sequence variables *seq1*</span>
<span class="sd">    and *seq2* should be of the same size *n*. If no array of interval variables is specified, the mapping between interval</span>
<span class="sd">    variables of the two sequences is given by the order of the interval variables in the arrays *array1* and *array2* used</span>
<span class="sd">    in the definition of the sequences. If some arrays are specified, they are used to define the mapping. The constraint</span>
<span class="sd">    states that the two sequences *seq1* and *seq2* are identical modulo a mapping between intervals *array1[i]* and</span>
<span class="sd">    *array2[i]*.</span>

<span class="sd">    Args:</span>
<span class="sd">        seq1: First constrained sequence variables.</span>
<span class="sd">        seq2: Second constrained sequence variables.</span>
<span class="sd">        array1: First array of interval variables defining the mapping between the two sequence variables.</span>
<span class="sd">        array2: Second array of interval variables defining the mapping between the two sequence variables.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, sequence variable) =&gt; constraint</span>
<span class="sd">     * (sequence variable, sequence variable, array of interval variables, array of interval variables) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_same_sequence</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="scal_prod"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.scal_prod">[docs]</a><span class="k">def</span> <span class="nf">scal_prod</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the scalar product of two vectors.</span>

<span class="sd">    The function *scal_prod* returns an integer or floating-point expression that</span>
<span class="sd">    represents the scalar product of two vectors *x* and *y*. Depending on the</span>
<span class="sd">    type of *x* and *y* the result is either integer or floating-point</span>
<span class="sd">    expression.</span>
<span class="sd">    </span>
<span class="sd">    The versions with constant arrays (*intArray* or *floatArray*) are preferred</span>
<span class="sd">    because they can be slightly faster.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: First input array (vector) to be multiplied.</span>
<span class="sd">        y: Second input array (vector) to be multiplied.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integers, array of integer expressions) =&gt; integer expression</span>
<span class="sd">     * (array of integer expressions, array of integers) =&gt; integer expression</span>
<span class="sd">     * (array of integer expressions, array of integer expressions) =&gt; integer expression</span>
<span class="sd">     * (array of floats, array of float expressions) =&gt; float expression</span>
<span class="sd">     * (array of float expressions, array of floats) =&gt; float expression</span>
<span class="sd">     * (array of float expressions, array of float expressions) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_scal_prod</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="search_phase"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.search_phase">[docs]</a><span class="k">def</span> <span class="nf">search_phase</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *searchPhase*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions) =&gt; search phase</span>
<span class="sd">     * (chooser of integer variable, chooser of integer value) =&gt; search phase</span>
<span class="sd">     * (array of integer expressions, chooser of integer variable, chooser of integer value) =&gt; search phase</span>
<span class="sd">     * (array of interval variables) =&gt; search phase</span>
<span class="sd">     * (array of sequence variables) =&gt; search phase</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type search phase</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_search_phase</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="select_largest"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.select_largest">[docs]</a><span class="k">def</span> <span class="nf">select_largest</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *selectLargest*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float constant, evaluator of integer variable) =&gt; selector of integer variable</span>
<span class="sd">     * (evaluator of integer variable, float constant [=0]) =&gt; selector of integer variable</span>
<span class="sd">     * (float constant, evaluator of integer value) =&gt; selector of integer value</span>
<span class="sd">     * (evaluator of integer value, float constant [=0]) =&gt; selector of integer value</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type selector of integer value or selector of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_select_largest</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="select_random_value"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.select_random_value">[docs]</a><span class="k">def</span> <span class="nf">select_random_value</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *selectRandomValue*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; selector of integer value</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type selector of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_select_random_value</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="select_random_var"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.select_random_var">[docs]</a><span class="k">def</span> <span class="nf">select_random_var</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *selectRandomVar*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; selector of integer variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type selector of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_select_random_var</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="select_smallest"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.select_smallest">[docs]</a><span class="k">def</span> <span class="nf">select_smallest</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *selectSmallest*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float constant, evaluator of integer variable) =&gt; selector of integer variable</span>
<span class="sd">     * (evaluator of integer variable, float constant [=0]) =&gt; selector of integer variable</span>
<span class="sd">     * (float constant, evaluator of integer value) =&gt; selector of integer value</span>
<span class="sd">     * (evaluator of integer value, float constant [=0]) =&gt; selector of integer value</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type selector of integer value or selector of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_select_smallest</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="sequence"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.sequence">[docs]</a><span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the number of occurrences of the values taken by the different subsets of consecutive *k* variables.</span>

<span class="sd">    This constraint ensures:</span>
<span class="sd">     * that *cards[i]* will be equal to the number of occurrences of the value *values[i]* in the array *vars*,</span>
<span class="sd">     * and that each sequence of *width* consecutive variables (like *vars[j+1]*, *vars[j+2]*, ..., *vars[j+width]*) takes at least *min* and at most *max* values of the array *values*.</span>

<span class="sd">    Args:</span>
<span class="sd">        min: The minimum number of allowable values.</span>
<span class="sd">        max: The maximum number of allowable values.</span>
<span class="sd">        width: The size of the sequences of consecutive variables.</span>
<span class="sd">        vars: The array of variables.</span>
<span class="sd">        values: The array of values.</span>
<span class="sd">        cards: The array of cardinality variables.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer constant, integer constant, integer constant, array of integer expressions, array of integers, array of integer expressions) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_sequence</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="size_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.size_eval">[docs]</a><span class="k">def</span> <span class="nf">size_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates *segmentedFunction* using the size of an interval variable.</span>

<span class="sd">    Evaluate *function* for the x value equal to the size of interval variable *interval*. If *interval*</span>
<span class="sd">    is absent then it does not have any defined size and *absentValue* is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        function: Function to evaluate.</span>
<span class="sd">        absentValue: Value to return if interval variable interval is absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, segmented function, float constant [=0]) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_size_eval</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="size_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.size_of">[docs]</a><span class="k">def</span> <span class="nf">size_of</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the size of a specified interval variable.</span>

<span class="sd">    This function returns an integer expression that is equal to size of the interval</span>
<span class="sd">    variable *interval* if it is present. If it is absent then the value of the</span>
<span class="sd">    expression is *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        absentValue: Value to return if the interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_size_of</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="size_of_next"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.size_of_next">[docs]</a><span class="k">def</span> <span class="nf">size_of_next</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the size of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the size of the interval variable</span>
<span class="sd">    that is next to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        lastValue: Value to return if interval variable interval is the last one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, integer constant [=0], integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_size_of_next</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="size_of_prev"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.size_of_prev">[docs]</a><span class="k">def</span> <span class="nf">size_of_prev</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the size of the interval variable that is previous.</span>

<span class="sd">    This function returns an integer expression that represents the size of the interval variable</span>
<span class="sd">    that is previous to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the first interval of *sequence*, it returns the constant integer value *firstValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        firstValue: Value to return if interval variable interval is the first one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, integer constant [=0], integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_size_of_prev</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="slope_piecewise_linear"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.slope_piecewise_linear">[docs]</a><span class="k">def</span> <span class="nf">slope_piecewise_linear</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *slopePiecewiseLinear*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (float expression, array of floats, array of floats, float constant, float constant) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_slope_piecewise_linear</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="span"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.span">[docs]</a><span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a span constraint between interval variables.</span>

<span class="sd">    This function creates a span constraint between an interval variable *interval*</span>
<span class="sd">    and a set of interval variables in *array*. This constraint states that</span>
<span class="sd">    *interval* when it is present spans over all present intervals from the</span>
<span class="sd">    *array*. That is: *interval* starts together with the first present</span>
<span class="sd">    interval from *array* and ends together with the last one. Interval *interval*</span>
<span class="sd">    is absent if and only if all intervals in *array* are absent.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Spanning interval variable.</span>
<span class="sd">        array: Array of spanned interval variables.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, array of interval variables) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_span</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="spread"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.spread">[docs]</a><span class="k">def</span> <span class="nf">spread</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *spread*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, float expression, float expression) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_spread</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="square"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.square">[docs]</a><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the square of the input.</span>

<span class="sd">    Function *square* computes the square of *x*. Depending on the type of *x* the</span>
<span class="sd">    result is an integer or a floating-point expression.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: Integer or floating-point expression.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression) =&gt; integer expression</span>
<span class="sd">     * (float expression) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_square</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="standard_deviation"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.standard_deviation">[docs]</a><span class="k">def</span> <span class="nf">standard_deviation</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a constrained numeric expression equal</span>
<span class="sd">    to the standard deviation of the values of the variables in an array.</span>

<span class="sd">    This function creates a new constrained numeric expression which is</span>
<span class="sd">    equal to the standard deviation of the values of the variables in the</span>
<span class="sd">    array *x*.  The mean of the values of the variables in the array x is</span>
<span class="sd">    constrained to be in the interval [meanLB, meanUB].</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array of integer expressions.</span>
<span class="sd">        meanLB: A lower bound on the mean of the array.</span>
<span class="sd">        meanUB: An upper bound on the mean of the array.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, float constant, float constant) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_standard_deviation</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="start_at_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_at_end">[docs]</a><span class="k">def</span> <span class="nf">start_at_end</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the delay between the start of one interval variable and end of another one.</span>

<span class="sd">    The function *start_at_end* constrains interval variables *a* and *b* in the</span>
<span class="sd">    following way. If both intervals *a* and *b* are present then interval *b* must</span>
<span class="sd">    end exactly at *start_of(a)+delay*. If *a* or *b* is absent then the constraint</span>
<span class="sd">    is automatically satisfied.</span>
<span class="sd">    </span>
<span class="sd">    The default value for *delay* is zero. Note that *delay* can be negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: First interval variables.</span>
<span class="sd">        b: Second interval variables.</span>
<span class="sd">        delay: Exact delay between start of a and end of b. If not specified then zero is used.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, interval variable, integer expression [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_start_at_end</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="start_at_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_at_start">[docs]</a><span class="k">def</span> <span class="nf">start_at_start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the delay between the starts of two interval variables.</span>

<span class="sd">    The function *start_at_start* constrains interval variables *a* and *b* in the</span>
<span class="sd">    following way. If both intervals *a* and *b* are present then interval *b* must</span>
<span class="sd">    start exactly at *start_of(a)+delay*. If *a* or *b* is absent then the</span>
<span class="sd">    constraint is automatically satisfied.</span>
<span class="sd">    </span>
<span class="sd">    The default value for *delay* is zero. Note that *delay* can be negative.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: First interval variables.</span>
<span class="sd">        b: Second interval variables.</span>
<span class="sd">        delay: Exact delay between starts of a and b. If not specified then zero is used.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, interval variable, integer expression [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_start_at_start</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="start_before_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_before_end">[docs]</a><span class="k">def</span> <span class="nf">start_before_end</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains minimum delay between the start of one interval variable and end of another one.</span>

<span class="sd">    The function *start_before_end* constrains interval variables *predecessor* and</span>
<span class="sd">    *successor* in the following way. If both interval variables *predecessor* and</span>
<span class="sd">    *successor* are present then *successor* cannot end before</span>
<span class="sd">    *start_of(predecessor)+minDelay*. If *predecessor* or *successor* is absent then</span>
<span class="sd">    the constraint is automatically satisfied.</span>
<span class="sd">    </span>
<span class="sd">    The default value for *minDelay* is zero. It is possible to specify a</span>
<span class="sd">    negative *minDelay*; in this case *successor* can actually end before the start</span>
<span class="sd">    of *predecessor* but still not sooner than *start_of(predecessor)+minDelay*.</span>

<span class="sd">    Args:</span>
<span class="sd">        predecessor: Interval variable which starts before.</span>
<span class="sd">        successor: Interval variable which ends after.</span>
<span class="sd">        minDelay: The minimal delay between start of predecessor and end of successor. If not specified then zero is used.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, interval variable, integer expression [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_start_before_end</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="start_before_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_before_start">[docs]</a><span class="k">def</span> <span class="nf">start_before_start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Constrains the minimum delay between starts of two interval variables.</span>

<span class="sd">    The function *start_before_start* constrains interval variables *predecessor* and</span>
<span class="sd">    *successor* in the following way. If both interval variables *predecessor* and</span>
<span class="sd">    *successor* are present then *successor* cannot start before</span>
<span class="sd">    *start_of(predecessor)+minDelay*. If *predecessor* or *successor* is absent then</span>
<span class="sd">    the constraint is automatically satisfied.</span>
<span class="sd">    </span>
<span class="sd">    The default value for *minDelay* is zero. It is possible to specify even</span>
<span class="sd">    negative *minDelay*, in this case *successor* can actually start before the start</span>
<span class="sd">    of *predecessor* but still not sooner than *start_of(predecessor)+minDelay*.</span>

<span class="sd">    Args:</span>
<span class="sd">        predecessor: Interval variable which starts before.</span>
<span class="sd">        successor: Interval variable which starts after.</span>
<span class="sd">        minDelay: The minimal delay between start of predecessor and start of successor. If not specified then zero is used.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, interval variable, integer expression [=0]) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_start_before_start</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="start_eval"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_eval">[docs]</a><span class="k">def</span> <span class="nf">start_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evaluates *segmentedFunction* at the start of an interval variable.</span>

<span class="sd">    Evaluates *function* at the start of interval variable *interval*. However if *interval*</span>
<span class="sd">    is absent then it does not have any defined start and *absentValue* is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        function: Function to evaluate.</span>
<span class="sd">        absentValue: Value to return if interval variable interval is absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, segmented function, float constant [=0]) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_start_eval</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="start_of"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_of">[docs]</a><span class="k">def</span> <span class="nf">start_of</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the start of a specified interval variable.</span>

<span class="sd">    This function returns an integer expression that is equal to start of the interval</span>
<span class="sd">    variable *interval* if it is present. If it is absent, then the value of the</span>
<span class="sd">    expression is *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        absentValue: Value to return if the interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_start_of</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="start_of_next"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_of_next">[docs]</a><span class="k">def</span> <span class="nf">start_of_next</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the start of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the start of the interval variable</span>
<span class="sd">    that is next to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        lastValue: Value to return if interval variable interval is the last one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, integer constant [=0], integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_start_of_next</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="start_of_prev"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.start_of_prev">[docs]</a><span class="k">def</span> <span class="nf">start_of_prev</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the start of the interval variable that is previous.</span>

<span class="sd">    This function returns an integer expression that represents the start of the interval variable</span>
<span class="sd">    that is previous to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the first interval of *sequence*, it returns the constant integer value *firstValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        firstValue: Value to return if interval variable interval is the first one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, integer constant [=0], integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_start_of_prev</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="step_at"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.step_at">[docs]</a><span class="k">def</span> <span class="nf">step_at</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an elementary cumul function of constant value after a given point.</span>

<span class="sd">    This function returns an elementary cumul function expression that is equal to 0 before point *t* and equal to *h* after</span>
<span class="sd">    point *t*.</span>

<span class="sd">    Args:</span>
<span class="sd">        t: Integer.</span>
<span class="sd">        h: Non-negative integer representing the height of the contribution after point t.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer time, positive integer) =&gt; cumul atom</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type cumul atom</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_step_at</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="step_at_end"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.step_at_end">[docs]</a><span class="k">def</span> <span class="nf">step_at_end</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an elementary cumul function of constant value after the end of an interval.</span>

<span class="sd">    This function returns an elementary cumul function expression that, whenever interval variable *interval* is present, is</span>
<span class="sd">    equal to 0 before the end of *interval* and equal to *h* after the end of *interval*. When a range [*heightMin*,</span>
<span class="sd">    *heightMax*) is specified it means that the height value *h* of the function is part of the decisions of the problem and</span>
<span class="sd">    will be fixed by the engine within this specified range. When interval variable *interval* is absent, the function is</span>
<span class="sd">    the constant zero function.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable contributing to the cumul function.</span>
<span class="sd">        h: Non-negative integer representing the height of the contribution.</span>
<span class="sd">        heightMin: Non-negative integer representing the the minimum of the range of possible values for the height of the contribution.</span>
<span class="sd">        heightMax: Non-negative integer representing the maximum of the range of possible values for the height of the contribution.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, positive integer) =&gt; cumul atom</span>
<span class="sd">     * (interval variable, positive integer, positive integer) =&gt; cumul atom</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type cumul atom</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_step_at_end</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="step_at_start"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.step_at_start">[docs]</a><span class="k">def</span> <span class="nf">step_at_start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an elementary cumul function of constant value after the start of an interval.</span>

<span class="sd">    This function returns an elementary cumul function expression that, whenever interval variable *interval* is present, is</span>
<span class="sd">    equal to 0 before the start of *interval* and equal to *h* after the start of *interval*. When a range [*heightMin*,</span>
<span class="sd">    *heightMax*) is specified it means that the height value *h* of the function is part of the decisions of the problem and</span>
<span class="sd">    will be fixed by the engine within this specified range. When interval variable *interval* is absent, the function is</span>
<span class="sd">    the constant zero function.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable contributing to the cumul function.</span>
<span class="sd">        h: Non-negative integer representing the height of the contribution.</span>
<span class="sd">        heightMin: Non-negative integer representing the the minimum of the range of possible values for the height of the contribution.</span>
<span class="sd">        heightMax: Non-negative integer representing the maximum of the range of possible values for the height of the contribution.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, positive integer) =&gt; cumul atom</span>
<span class="sd">     * (interval variable, positive integer, positive integer) =&gt; cumul atom</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type cumul atom</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_step_at_start</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="strong"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.strong">[docs]</a><span class="k">def</span> <span class="nf">strong</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A model annotation to encourage CP Optimizer to produce stronger (higher inference) constraints.</span>

<span class="sd">    The *strong* constraint strengthens the model on the expressions *x*.</span>
<span class="sd">    This is done by creating an *allowed_assignments* constraint in place</span>
<span class="sd">    of the *strong* constraint during presolve. Only the assignments to</span>
<span class="sd">    the expressions which do not result in an immediate inconsistency are</span>
<span class="sd">    added to the tuple set of the *allowed_assignments* constraint.</span>
<span class="sd">    </span>
<span class="sd">    Constraints that can be identified as redundant (when taken together</span>
<span class="sd">    with this new constraint) are removed from the model during presolve.</span>
<span class="sd">    This is the case for constraints that are only over the variables of</span>
<span class="sd">    the array given as argument.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array of integer expressions over which propagation is to be strengthened.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_strong</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="sum"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.sum">[docs]</a><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the sum of the input.</span>

<span class="sd">    The function *sum* computes the sum of *x*. Depending on the type of *x* the</span>
<span class="sd">    result is an integer or a floating-point expression.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: An array of integer or floating-point expressions.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions) =&gt; integer expression</span>
<span class="sd">     * (array of float expressions) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">_expand</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">_no_cpo_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">builtin</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_sum</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="synchronize"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.synchronize">[docs]</a><span class="k">def</span> <span class="nf">synchronize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a synchronization constraint between interval variables.</span>

<span class="sd">    This function creates a synchronization constraint between an interval variable *interval* and a set of interval</span>
<span class="sd">    variables in *array*. This constraint makes all present intervals in *array* start and end together with *interval*, if</span>
<span class="sd">    it is present.</span>

<span class="sd">    Args:</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        array: Array of interval variables synchronized with interval.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (interval variable, array of interval variables) =&gt; constraint</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_synchronize</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="times"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.times">[docs]</a><span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *times*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer expression, integer expression) =&gt; integer expression</span>
<span class="sd">     * (float expression, float expression) =&gt; float expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type float expression or integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_times</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="true"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.true">[docs]</a><span class="k">def</span> <span class="nf">true</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns a true Boolean expression.</span>

<span class="sd">    This function returns a true Boolean expression (*boolExpr*). CP Optimizer</span>
<span class="sd">    usually eliminates *true()* from expressions using partial evaluation.</span>
<span class="sd">    </span>
<span class="sd">    The function *true()* does not have any particular purpose except for being a</span>
<span class="sd">    filler.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; boolean expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type boolean expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_true</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="type_of_next"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.type_of_next">[docs]</a><span class="k">def</span> <span class="nf">type_of_next</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the type of the interval variable that is next.</span>

<span class="sd">    This function returns an integer expression that represents the type of the interval variable</span>
<span class="sd">    that is next to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the last interval of *sequence*, it returns the constant integer value *lastValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        lastValue: Value to return if interval variable interval is the last one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, integer constant [=0], integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_type_of_next</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="type_of_prev"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.type_of_prev">[docs]</a><span class="k">def</span> <span class="nf">type_of_prev</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an integer expression that represents the type of the interval variable that is previous.</span>

<span class="sd">    This function returns an integer expression that represents the type of the interval variable</span>
<span class="sd">    that is previous to *interval* in sequence variable *sequence*. When *interval* is present and is</span>
<span class="sd">    the first interval of *sequence*, it returns the constant integer value *firstValue* (zero by default).</span>
<span class="sd">    When *interval* is absent, it returns the constant integer value *absentValue* (zero by default).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence: Sequence variable.</span>
<span class="sd">        interval: Interval variable.</span>
<span class="sd">        firstValue: Value to return if interval variable interval is the first one in sequence.</span>
<span class="sd">        absentValue: Value to return if interval variable interval becomes absent.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (sequence variable, interval variable, integer constant [=0], integer constant [=0]) =&gt; integer expression</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type integer expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_type_of_prev</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="value"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.value">[docs]</a><span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *value*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; evaluator of integer value</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_value</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="value_impact"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.value_impact">[docs]</a><span class="k">def</span> <span class="nf">value_impact</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *valueImpact*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; evaluator of integer value</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_value_impact</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="value_index"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.value_index">[docs]</a><span class="k">def</span> <span class="nf">value_index</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *valueIndex*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integers, float constant [=-1]) =&gt; evaluator of integer value</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_value_index</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="value_success_rate"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.value_success_rate">[docs]</a><span class="k">def</span> <span class="nf">value_success_rate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *valueSuccessRate*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; evaluator of integer value</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_value_success_rate</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="var_impact"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.var_impact">[docs]</a><span class="k">def</span> <span class="nf">var_impact</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *varImpact*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; evaluator of integer variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_var_impact</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="var_index"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.var_index">[docs]</a><span class="k">def</span> <span class="nf">var_index</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *varIndex*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (array of integer expressions, float constant [=-1]) =&gt; evaluator of integer variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_var_index</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="var_local_impact"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.var_local_impact">[docs]</a><span class="k">def</span> <span class="nf">var_local_impact</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *varLocalImpact*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * (integer constant [=-1]) =&gt; evaluator of integer variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_var_local_impact</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="var_success_rate"><a class="viewcode-back" href="../../../docplex.cp.modeler.py.html#docplex.cp.modeler.var_success_rate">[docs]</a><span class="k">def</span> <span class="nf">var_success_rate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates an expression for operation *varSuccessRate*.</span>

<span class="sd">    Possible argument and return type combinations are:</span>

<span class="sd">     * () =&gt; evaluator of integer variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        An expression of type evaluator of integer variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">create_op</span><span class="p">(</span><span class="n">Oper_var_success_rate</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<span class="c1">###############################################################################</span>
<span class="c1">##  Operators overloading</span>
<span class="c1">###############################################################################</span>

<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__ne__</span> <span class="o">=</span> <span class="n">diff</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__eq__</span> <span class="o">=</span> <span class="n">equal</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__div__</span> <span class="o">=</span> <span class="n">float_div</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__truediv__</span> <span class="o">=</span> <span class="n">float_div</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__rdiv__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">float_div</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__rtruediv__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">float_div</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__gt__</span> <span class="o">=</span> <span class="n">greater</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__ge__</span> <span class="o">=</span> <span class="n">greater_or_equal</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__floordiv__</span> <span class="o">=</span> <span class="n">int_div</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__rfloordiv__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">int_div</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__lt__</span> <span class="o">=</span> <span class="n">less</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__le__</span> <span class="o">=</span> <span class="n">less_or_equal</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__and__</span> <span class="o">=</span> <span class="n">logical_and</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__rand__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__invert__</span> <span class="o">=</span> <span class="n">logical_not</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__or__</span> <span class="o">=</span> <span class="n">logical_or</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__ror__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">logical_or</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__sub__</span> <span class="o">=</span> <span class="n">minus</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__rsub__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">minus</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__mod__</span> <span class="o">=</span> <span class="n">mod</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__rmod__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">mod</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__add__</span> <span class="o">=</span> <span class="n">plus</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__radd__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">plus</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__pow__</span> <span class="o">=</span> <span class="n">power</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__rpow__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__mul__</span> <span class="o">=</span> <span class="n">times</span>
<span class="n">CpoExpr</span><span class="o">.</span><span class="n">__rmul__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">times</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DOcplex.CP: Constraint Programming Modeling for Python V1.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, IBM.
    </div>
  </body>
</html>